{"meta":{"title":"Kwin的学习博客","subtitle":null,"description":"Kwin的学习经历整理。","author":"Kwin Jing","url":"http://kwin1113.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-02-05T08:19:14.154Z","updated":"2019-02-05T08:19:14.154Z","comments":false,"path":"/404.html","permalink":"http://kwin1113.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-02-23T07:50:56.781Z","updated":"2019-02-23T07:50:56.781Z","comments":false,"path":"about/index.html","permalink":"http://kwin1113.github.io/about/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-02-05T08:19:14.153Z","updated":"2019-02-05T08:19:14.153Z","comments":false,"path":"books/index.html","permalink":"http://kwin1113.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-02-05T08:19:14.156Z","updated":"2019-02-05T08:19:14.156Z","comments":true,"path":"links/index.html","permalink":"http://kwin1113.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-02-05T08:19:14.153Z","updated":"2019-02-05T08:19:14.153Z","comments":false,"path":"categories/index.html","permalink":"http://kwin1113.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-02-05T08:19:14.159Z","updated":"2019-02-05T08:19:14.159Z","comments":false,"path":"repository/index.html","permalink":"http://kwin1113.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-02-05T08:19:14.159Z","updated":"2019-02-05T08:19:14.159Z","comments":false,"path":"tags/index.html","permalink":"http://kwin1113.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis云平台Cachecloud","slug":"Tools/Redis/Redis云平台Cachecloud","date":"2019-02-28T03:13:27.000Z","updated":"2019-02-28T03:13:58.017Z","comments":true,"path":"passages/Tools/Redis/Redis云平台Cachecloud/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis云平台Cachecloud/","excerpt":"","text":"Redis云平台CacheCloud Redis规模化运维 快速构建 机器部署 应用接入 用户功能 运维功能 Redis规模化运维困扰 发布构建繁琐，私搭乱盖 节点&amp;机器等运维成本 监控报警初级 CacheCloud 一键开启Redis。（Standalone、Sentinel、Cluster） 机器、应用、实例监控和报警。 客户端：透明使用、性能上报。 可视化运维：配置、扩容、Failover、机器/应用/实例上下线。 已存在Redis直接接入和数据迁移。 开源平台 使用场景 全量视频缓存（视频播放API）：跨机房高可用 消息队列同步（RedisMQ中间件） 分布式布隆过滤器（百万QPS） 计数系统：计数（播放数） 其他：排行榜、社交（直播）、实时计算（反作弊）等。 快速搭建开源平台 机器部署应用接入","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"缓存的使用与设计","slug":"Tools/Redis/缓存的使用与设计","date":"2019-02-28T03:11:51.000Z","updated":"2019-02-28T03:13:19.046Z","comments":true,"path":"passages/Tools/Redis/缓存的使用与设计/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/缓存的使用与设计/","excerpt":"","text":"缓存的使用与设计 缓存的受益与成本 缓存更新策略 缓存粒度控制 缓存穿透优化 无底洞问题优化 缓存雪崩优化 热点key重建优化 缓存的收益与成本收益 加速读写 通过缓存加速读写速度：CPU L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器缓存、Ehcache缓存数据库结果。 降低后端负载 后端服务器通过前端缓存降低负载：业务端使用Redis降低后端MySQL负载等。 成本 数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关。 代码维护成本：多了一层缓存逻辑。 运维成本：例如Redis Cluster 使用场景 降低后端负载： 对高消耗的SQL：join结果集/分组统计结果缓存。 加速请求响应： 利用Redis/Memcache 大量写合并为批量写： 如计数器先Redis累加再批量写DB 缓存更新策略 LRU/LFU/FIFO算法剔除：例如maxmemory-policy。 超时剔除：例如expire。 主动更新：开发控制生命周期。 策略 一致性 维护成本 LRU/LIRS算法剔除 最差 低 超时剔除 较差 低 主动更新 强 高 建议 低一致性：最大内存和淘汰策略 高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。 缓存粒度控制 从MySQL获取用户信息：-select * from user where id={id} 设置用户信息缓存：-set user:{id} select * from user where id={id} 缓存粒度：-全部属性：set user:{id} select * from user where id={id}-部分重要属性：set user:{id} select importantColumn1..importantColumn2 from user where id={id} 三个角度 通用性：全量属性更好。 占用空间：部分属性更好。 代码维护：表面上全量属性更好。 缓存穿透问题 原因 业务代码自身问题 恶意攻击、爬虫等 如何发现 业务的对应时间 业务本身问题 相关指标：总调用数、缓存层命中数、存储层命中数 解决办法 缓存空对象 问题： 需要更多的键。 缓冲层和存储层数据“短期”不一致。 实例代码：1234567891011121314public String getPassThrough(String key)&#123; String cacheValue = cache.get(key); if(StringUtils.isBlank(cacheValue))&#123; String storageValue = storage.get(key); cache.set(key, storageValue); //如果存储数据为空，需要设置一个过期时间（300秒） if(StringUtils.isBlank(storageValue))&#123; cache.expire(key, 60*5); &#125; return storageValue; &#125; else &#123; return cacheValue; &#125;&#125; 布隆过滤器拦截 无底洞问题优化问题关键点： 更多的机器 != 更高的性能 批量接口需求（mget,mset等） 数据增长与水平扩展需求 优化IO的几种方法 命令本身优化：例如慢查询keys、hgetall bigkey 减少网络通信次数 降低接入成本：例如客户端长连接/连接池、NIO等热点key重建优化三个目标和两个解决三个目标 减少重缓存的次数 数据尽可能一致 减少潜在危险 两个解决 互斥锁示例代码： 12345678910111213141516String get(String key)&#123; String value = redis.get(key); if(value == null)&#123; String mutexKey = \"mutex:key:\" + key; if(redis.set(mutexKey, \"1\", \"ex 180\", \"nx\"))&#123; value = db.get(key); redis.set(key, value); redis.delete(mutexKey); &#125; else &#123; //其他线程休息50毫秒后充实 Thread.sleep(50); get(key); &#125; &#125; return value;&#125; 永不过期 缓存层面：没有设置过期时间（没有用expire）。 功能层面：为每个value添加逻辑过期时间，但发现超过逻辑过期时间后，会使用单独的线程去构建缓存。示例代码：12345678910111213141516171819String get(final String key)&#123; V v = redis.get(key); String value = v.getValue(); long logicTimeout = v.getLogicTimeout(); if(logicTimeout &gt;= System.currentTimeMillis())&#123; String mutexKey = \"mutex:key:\" + key; if(redis.set(mutexKey, \"1\", \"ex 180\", \"nx\"))&#123; //异步更新后台异常执行 threadPool.execute(new Runnable()&#123; public void run()&#123; String dbValue = db.get(key); redis.set(key, (dbValue, newLogicTimeout)); redis.delete(keyMutex); &#125; &#125;); &#125; &#125; return value;&#125; 对比 方案 优点 缺点 互斥锁 思路简单、保持一致性 代码复杂度增加、存在死锁的风险 永远不过期 基本杜绝热点key重建问题 不保证一致性、逻辑过期时间增加维护成本和内存成本 总结 缓存收益：加速读写、降低后端存储负载。 缓存成本：缓存和存储数据不一致性、代码维护成本、运维成本。 推荐结合剔除、超时、主动更新三种方案共同完成。 穿透问题：使用缓存空对象和布隆过滤器来解决，注意它们各自的使用场景和局限性。 无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。有四种批量操作方式：串行命令、串行IO、并行IO、hash_tag。 雪崩问题：缓存曾高可用、客户端降级、提前演练是解决雪崩问题的重要方法。 热点key问题：互斥锁、“永远不过期”能够在一定程度上解决热点key问题，开发人员在使用时要了解它们各自的使用成本。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"RedisCluster开发运维常见问题","slug":"Tools/Redis/RedisCluster开发运维常见问题","date":"2019-02-28T03:10:47.000Z","updated":"2019-02-28T03:11:32.655Z","comments":true,"path":"passages/Tools/Redis/RedisCluster开发运维常见问题/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/RedisCluster开发运维常见问题/","excerpt":"","text":"RedisCluster开发运维常见问题 集群完成性 带宽消耗 Pub/Sub广播 数据倾斜 读写分离 数据迁移 集群vs单机 集群完整性 cluster-require-full-coverage默认为yes 集群中16384个槽全部可用：保证集群完整性 节点故障或者正在故障转移（error)CLUSTERDOWN The cluster is down 大多数业务无法容忍，cluster-require-full-coverage建议设置为no 带宽消耗 官方建议：不超过1000个 ping/pong消息 不容忽视的带宽消耗三个方面 消息发送频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息 消息数据量：slots槽数组（2KB空间）和整个集群1/10的状态数据（10个节点状态数据约1KB） 节点部署的及其规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。优化 避免”大“集群：避免多业务使用一个集群，大业务可以多集群 cluster-node-timeout：带宽和故障转移速度的均衡。 尽量均匀分配到多机器上：保证高可用和带宽。 Pub/Sub广播 问题：publish在集群每个节点广播：加重带宽 解决：单独“走”一套Redis Sentinel 集群倾斜数据倾斜：内存不均 节点和槽分配不均 redis-trib.rb info ip:port查看节点、槽、键值分布 redis-trib.rb rebalance ip:port进行均衡（谨慎使用） 不同槽对应键值数量差异较大 CRC16正常情况下比较均匀 可能存在hash_tag cluster countkeysinslot {slot}获取槽对应键值个数 包含bigkey bigkey：例如大字符串、几百万的元素的hash、set等 从节点：redis-cli –bigkeys 优化：优化数据结构 内存相关配置不一致 hash-max-ziplist-value、set-max-intset-entries等 优化：定义“检查”配置一致性请求倾斜：热点 热点key：重要的key或者bigkey 优化： -避免bigkey -热键不要用hash_tag -当一致性不高时，可以使用本地缓存 + MQ 集群读写分离 只读连接：集群模式的从节点不接受任何写请求。 重定向到负责槽的主节点 readonly命令可以读：连接级别命令 读写分离：更加复杂 同样的问题：复制延迟、读取过期数据、从节点故障 修改客户端：cluster slaves {nodeId} 数据迁移离线/在线迁移 官方迁移工具：redis-trib.rb import 只能从单机迁移到集群 不支持在线迁移：source需要停写 不支持断点续传 单线程迁移：影响速度 在线迁移： 唯品会：redis-migrate-tool 豌豆荚：redis-port 集群单机对比集群限制 key批量操作支持有限：例如mget、mset必须在一个slot key事务和lua支持有限：操作的key必须在一个节点 key是数据分区的最小粒度：不支持bigkey分区 不支持多个数据库：集群模式下之后一个db0 复制只支持一层：不支持属性复制结构 分布式Redis不一定好 Redis Cluster：满足容量和性能的扩展性，很多业务“不需要”。 大多数客户端性能会“降低”。 命令无法跨节点使用：mget、keys、scan、flush、sinter等。 lua和事务无法跨节点使用。 客户端伟华更复杂：SDK和应用本身消耗（例如更多的连接池）。 很多场景Redis Sentinel已经足够好。 总结 Redis Cluster数据分区规则采用虚拟槽方式（16384个槽），每个节点负责一部分槽和相关数据，实现数据和请求的负载均衡。 搭建集群划分四个步骤：准备节点、节点握手、分配槽、复制。 redis-trib.rb工具用于快速搭建集群。 集群伸缩通过在节点之间移动槽和相关数据实现。 扩容时根据槽迁移计划把槽从源节点迁移到新节点。 收缩时如果下线的节点有负责的槽需要迁移到其他节点，再通过cluster forget命令让集群内所有节点忘记被下线节点。 集群总结 使用smart客户端操作集群达到通信效率最大化，客户端内部负责计算维护键-》槽-&gt;节点的映射，用于快速定位到目标节点。 集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的从节点触发故障恢复流程，保证集群的可用性。 开发运维常见问题包括：超大规模集群带宽消耗，pub/sub广播问题，集群倾斜问题，单机和集群对比等。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis Cluster","slug":"Tools/Redis/Redis-Cluster","date":"2019-02-28T03:06:05.000Z","updated":"2019-02-28T03:10:26.787Z","comments":true,"path":"passages/Tools/Redis/Redis-Cluster/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis-Cluster/","excerpt":"","text":"Redis Cluster 呼唤集群 数据分布 搭建集群 集群伸缩 客户端路由 集群原理 故障转移 开发运维常见问题 呼唤集群1. 并发量2. 数据量3. 网络流量 解决办法分布式：简单的认为加机器 集群：规模化需求 并发量：OPS 数据量：”大数据” 数据分布分布式数据库-数据分区 顺序分区和哈希分区 顺序分布 哈希分布（例如节点取模） 数据分布对比 分布方式 特点 典型产品 哈希分布 数据分散度高、键值分布业务无关、无法顺序访问、支持批量操作 一致性哈希Memcache、Redis Cluster、其他缓存产品 顺序分布 数据分散度易倾斜、键值业务相关、可顺序访问、支持批量操作 Big Table、HBase 哈希分布 节点取余分区 一致性哈希分区 虚拟槽分区 节点取余分区：hash(key)%nodes 多倍扩容 客户端分片：哈希+取余 节点伸缩：数据节点关系变化，导致数据迁移 迁移数量和添加节点数量有关：建议翻倍扩容 一致性哈希 扩容 客户端分片：哈希+顺时针（优化取余） 节点伸缩：只影响邻近节点，但是还是有数据迁移 翻倍伸缩：保证最小迁移数据和负载均衡 虚拟槽分区 预设虚拟槽：每个槽映射一个数据子集，一般比节点数大 良好的哈希函数：例如CRC16 服务端管理节点、槽、数据：例如Redis Cluster 搭建集群-基本架构单机架构 分布式架构 Redis Cluster架构 节点 meet 指派槽 复制 节点cluster-enabled yes meet所有节点共享消息 指派槽 特性 复制 高可用 分片 Redis Cluster安装 原生命令安装 官方工具安装 原生命令安装-理解架构 配置开启节点 meetcluster meet ip port 12345redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005 Cluster节点主要配置 指派槽cluster addslots slot [slot …] 123redis-cli -h 127.0.0.1 -p 7000 cluster addslots &#123;0..5461&#125;redis-cli -h 127.0.0.1 -p 7001 cluster addslots &#123;5462..10922&#125;redis-cli -h 127.0.0.1 -p 7002 cluster addslots &#123;10923..16383&#125; 设置主从cluster replicate node-id 123redis-cli -h 127.0.0.1 -p 7003 cluster replicate $&#123;node-id-7000&#125;redis-cli -h 127.0.0.1 -p 7004 cluster replicate $&#123;node-id-7001&#125;redis-cli -h 127.0.0.1 -p 7005 cluster replicate $&#123;node-id-7002&#125; 官方工具Ruby安装 下载、编译、安装Ruby 安装rubygem redis 安装redis-trib.rb 其他使用redis-trib.rb create 或者 redis-cli create 命令可视化部署 集群伸缩 伸缩原理 扩容集群 缩容集群 伸缩原理集群伸缩=槽和数据在节点之间的移动 扩容集群 准备新节点 加入集群 迁移槽和数据 准备新节点新节点： 集群模式 配置和其他节点同意 启动后是孤儿节点12redis-server conf/redis-6385.confredis-server conf/redis-6386.conf 加入集群12127.0.0.1:6379 &gt; cluster meet 127.0.0.1 6385127.0.0.1:6379 &gt; cluster meet 127.0.0.1 6386 作用 为他迁移槽和数据实现扩容 作为从节点负责故障转移redis-trib.rb1234redis-trib.rb add-node new_host:new_port existing_hos:existing_port --slave --master-id &lt;arg&gt;redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000//建议使用redis-trib.rb能够避免新节点已经加入了其他集群，造成故障//新版本使用redis-cli --cluster add-node 迁移槽和数据 槽迁移计划 1//新版本使用redis-cli --cluster reshard 迁移数据 添加从节点 槽迁移计划 迁移数据 对目标节点发送：cluster setslot {slot} importing {sourceNodeId} 命令，让目标节点准备导入槽的数据。 对源节点发送：cluster setslot {slot} migrating {targetNodeId} 命令，让源节点准备迁出槽的数据。 源节点循环执行cluster getkeysinslot {slot} {count} 命令，每次获取count个属于槽的键。 在源节点上执行migrate {targetIp} {targetPort} key 0 {timeout} 命令把指定key迁移。 重复执行步骤3~4知道槽下所有的键数据迁移到目标节点。 向集群内所有主节点发送cluster setslot {slot} node {targetNodeId} 命令，通知槽分配给目标节点。 收缩集群 下线迁移槽 忘记节点 关闭节点 下线槽 忘记槽123redis-cli &gt; cluster forget &#123;downNodeId&#125;del-node 客户端路由 moved重定向 ask重定向 smart客户端 moved重定向 槽命中 槽不命中：moved异常 ask重定向 moved和ask 两者都是客户端重定向 moved：槽已经确定迁移 ask：槽还在迁移中smart客户端 smart客户端原理 smart客户端使用：JedisCluster smart客户端原理：追求性能 从集群中选一个可运行节点，使用cluster slots初始化槽和节点映射。 将cluster slots的结果映射到本地，为每个节点创建JedisPool。 准备执行命令。 执行命令 smart客户端使用：JedisClusterJedisCluster基本使用123456789Set&lt;HostAndPort&gt; nodeList = new HashSet&lt;HostAndPort&gt;();nodeList.add(new HostAndPort(HOST1, PORT1));nodeList.add(new HostAndPort(HOST2, PORT2));nodeList.add(new HostAndPort(HOST3, PORT3));nodeList.add(new HostAndPort(HOST4, PORT4));nodeList.add(new HostAndPort(HOST5, PORT5));nodeList.add(new HostAndPort(HOST6, PORT6));JedisCluster redisCluster = new JedisCluster(nodeList, timeout, poolConfig);redisCluster.command... 使用技巧 单例：内置了所有节点的连接池 无需手动借还连接池 合理设置commons-pool整合springspringBoot整合redisCluster(redis集群)模式注意搭建集群时ip的配置，避免整合客户端时连接失败。多节点命令实现12345678910Map&lt;String, JedisPool&gt; jedisPoolMap = jedisCluster.getClusterNodes();for (Entry&lt;String, JedisPool&gt; entry : jedisPoolMap.entrySet())&#123; //获取每个节点的Jedis连接 Jedis jedis = entry.getValue().getResource(); //只删除主节点数据 if(!isMaster(jedis))&#123; continue; &#125; //finally close&#125; 批量命令实现mget mset 必须在一个槽上 四种批量优化的方法 串行mget 串行IO 并行IO hash_tag 四种方案优缺点分析 方案 优点 缺点 网络IO 串行mget 编程简单、少量keys满足需求 大量keys请求延迟严重 O(keys) 串行IO 编程简单、少量节点满足需求 大量node延迟严重 O(nodes) 并行IO 利用并行特性、延迟取决于最慢的节点 编程复杂、超时定位问题难 O(max_slow(node)) hash_tag 性能最高 读写增加tag维护成本、tag分布易出现数据倾斜 O(1) 故障转移故障发现 通过ping/pong消息实现故障发现：不需要sentinel 主观下线/客观下线 尝试客观下线 通知集群内所有节点标记故障节点为客观下线 通知故障节点的从节点触发故障转移流程 故障恢复 资格检查 每个从节点检查与故障主节点的断线时间 超过cluster-node-timeout * cluster-slave-validity-factor取消资格 cluster-slave-validity-factor：默认是10 准备选举时间 选举投票 替换主节点 当前从节点取消复制变为主节点。（slaveof no one） 执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己。 向集群广播自己的pong消息，表明已经替换了故障从节点。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis Sentinel开发运维常见问题","slug":"Tools/Redis/Redis-Sentinel开发运维常见问题","date":"2019-02-28T03:04:43.000Z","updated":"2019-02-28T03:05:29.646Z","comments":true,"path":"passages/Tools/Redis/Redis-Sentinel开发运维常见问题/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel开发运维常见问题/","excerpt":"","text":"常见开发运维问题 节点运维 高可用读写分离 节点运维节点上线和下线 主节点 从节点 sentinel节点 节点下线机器下线：例如过保等情况机器性能不足：例如CPU、内存、硬盘、网络等节点自身故障：例如服务不稳定等 主节点：sentinel failover 从节点：临时下线还是永久下线，例如是否做一些清理工作，但是要考虑读写分离的情况。Sentinel节点：同上 节点上线主节点：sentinel failover进行替换从节点：slaveof即可，sentinel节点可以感知sentinel节点:参考其他sentinel节点启动即可 高可用读写分离从节点的作用 副本：高可用的基础 扩展：读能力三个“消息” +switch-master：切换主节点（从节点晋升主节点） +convert-to-slave：切换从节点（原主节点降为从节点） +sdown：主观下线 Redis Sentinel总结 Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。 Redis Sentinel从Redis2.8版本开始才正式生产可用，之前版本生产不可用。 尽可能在不同物理机上部署Redis Sentinel所有节点。 Redis Sentinel中的Sentinel节点个数应该为大于等于3且最好为奇数。 Redis Sentinel中的数据节点与普通数据节点没有区别。 客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理。 Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控。 Redis Sentinel在对节点做失败判定时分为主观下线和客观下线。 看懂Redis Sentinel故障转移日志对于Redis Sentinel以及问题排查非常有帮助。 Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis Sentinel","slug":"Tools/Redis/Redis-Sentinel","date":"2019-02-28T03:01:09.000Z","updated":"2019-02-28T03:04:04.946Z","comments":true,"path":"passages/Tools/Redis/Redis-Sentinel/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel/","excerpt":"","text":"Redis Sentinel 主从复制高可用 架构说明 安装配置 客户端连接 实现原理 常见开发运维问题 主从复制高可用主从复制问题 手动故障转移 写能力和存储能力受限 Redis Sentinel架构 Redis Sentinel故障转移 多个sentinel发现并确认master有问题 选举出一个sentinel作为领导 选出一个slave作为master 通知其余slave称为新的master的slave 通知客户端主从变化 等待老的master复活称为新master的slave 一套sentinel可以控制多套主从架构 安装与配置 配置开启主从节点 配置开启sentinel监控主节点。（sentinel是特殊的redis） 多机器 详细配置节点 客户端连接 请求响应流程 Jedis 客户端实现基本原理 客户端接入流程 Sentinel地址集合 masterName 不是代理模式 1234567891011JedisSentinelPool sentinelPool = new JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout);Jedis jedis = null;try &#123; jedis = redisSentinelPool.getResource(); //jedis command&#125; catch (Exception e) &#123; logger.error(e.getMessage(), e);&#125; finally &#123; if (jedis != null) jedis.close();&#125; 故障转移 客户端高可用观察 服务端日志分析：数据节点和sentinel节点 三个定时任务 每10秒每个sentinel对master和slave执行info 发现slave节点 确认主从关系 每2秒每个sentinel通过master节点的channel交换信息（pub/sub）（发布订阅） 通过sentinel:hello频道交互 交互对节点的“看法”和自身信息 每1秒每个sentinel对其他sentinel和redis执行ping 心跳检测 失败判定 主观下线和客观下线1234sentinel monitor &lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;sentinel monitor myMaster 127.0.0.1 6379 2sentinel down-after-milliseconds &lt;masterName&gt; &lt;timeout&gt;sentinel down-after-milliseconds mymaster 30000 主观下线：每个sentinel节点对Redis节点失败的“偏见” 客观下线：所有sentinel节点对Redis节点失败的“达成共识”（超过quorum个统一）sentinel is-master-down-by-addr 领导者选举 原因：只有一个sentinel节点完成故障转移 选举：通过sentinel is-master-down-by-addr命令都希望成为领导者 每个做主观下线的Sentinel节点向其他Sentinel节点发送请求，要求将它设置为领导者。 收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将同意该请求，否则拒绝。 如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum，那么它将成为领导者。故障转移（sentinel领导者节点完成） 从slave节点中选出一个“合适的”节点作为新的master节点。 对上面的slave节点执行slaveof no one命令让其成为master节点。 向剩余的slave节点发送命令，让他们成为新的master节点和slave节点，复制规则和parallel-syncs参数有关。 更新对原来的master节点配置为slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。 选择“合适的”slave节点 选择slave-priority（slave节点优先级）最高的slave节点，如果存在则返回，不存在则继续。 选择复制偏移量最大的slave节点（复制的最完整），如果存在则返回，不存在则继续。 选择runId最小的slave节点。","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis复制的原理与优化","slug":"Tools/Redis/Redis复制的原理与优化","date":"2019-02-28T02:58:37.000Z","updated":"2019-02-28T03:00:47.278Z","comments":true,"path":"passages/Tools/Redis/Redis复制的原理与优化/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis复制的原理与优化/","excerpt":"","text":"Redis复制的原理与优化 什么是主从复制 复制的配置 全量复制和部分复制 故障处理 开发运维常见问题 主从复制 主从复制的作用 数据副本 扩展读性能 简单总结 一个master可以有多个slave 一个slave只能由一个master 数据流向是单向的，master到slave 主从复制的配置slaveof命令 配置 比较 方式 命令 配置 优点 无需重启 统一配置 缺点 不便于管理 需要重启 全量复制和部分复制全量复制 全量复制开销 bgsave时间 RDB文件网络传输时间 从节点清空数据时间 从节点加载RDB的时间 可能的AOF重写时间 部分复制 故障处理主从结构-故障转移 slave宕掉 master宕掉 开发运维常见问题 读写分离 主从配置不一致 规避全量复制 规避复制风暴读写分离 读流量分摊到从节点 可能遇到问题： 复制数据延迟 读到过期数据 从节点故障配置不一致 例如maxmemory不一致：丢失数据 例如数据结构优化参数（例如hash-max-ziplist-entried）：内存不一致 规避全量复制 第一次全量复制 第一次不可避免 小主节点、低峰 节点运行ID不匹配 主节点重启（运行ID变化） 故障转移，例如哨兵或集群 复制积压缓冲区不足 网络中断，部分复制无法满足 增大复制缓冲区配置rel_backlog_size，网络“增强” 规避复制风暴 单主节点复制风暴：问题：主节点重启，多从节点复制解决：更换复制拓扑 单机器复制风暴问题：机器宕机后，大量全量复制解决：主从节点分散多机器","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis开发运维常见问题","slug":"Tools/Redis/Redis开发运维常见问题","date":"2019-02-28T02:57:38.000Z","updated":"2019-02-28T02:58:19.201Z","comments":true,"path":"passages/Tools/Redis/Redis开发运维常见问题/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis开发运维常见问题/","excerpt":"","text":"开发运维常见问题fork操作 同步操作 与内存量息息相关：内存越大，耗时越长（与机器类型有关） info：latest_fork_usec改善fork 优先使用物理机或者高效支持fork操作的虚拟化技术 控制Redis实例最大可用内存：maxmemory 合理配置Linux内存分配策略：vm.overcommit_memory=1 降低fork频率：例如放宽AOF重写自动触发时机，不必要的全量复制进程外开销子进程开销和优化 CPU： 开销：RDB和AOF文件生成，属于CPU密集型 优化：不做CPU绑定，不和CPU密集型部署 内存： 开销：fork内存开销，copy-on-write 优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled 硬盘 开销：AOF和RDB文件写入，可以结合iostat，iotop分析 优化： 不要和高硬盘负载服务部署在一起：存储服务、消息队列等 no-appendfsync-on-rewrite=yes 根据写入量决定磁盘类型：例如ssd 单机多实例持久化文件目录可以考虑分盘AOF追加阻塞 单机多实例部署","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis持久化的取舍和选择","slug":"Tools/Redis/Redis持久化的取舍和选择","date":"2019-02-28T02:53:41.000Z","updated":"2019-02-28T02:57:05.018Z","comments":true,"path":"passages/Tools/Redis/Redis持久化的取舍和选择/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis持久化的取舍和选择/","excerpt":"","text":"Redis持久化的取舍和选择 持久化的作用 RDB AOF RDB和AOF的抉择 持久化的作用 什么是持久化 持久化的实现方式什么是持久化redis所有数据保存在内存中，对数据的更新将异步地保存到磁盘上持久化方式 快照——MySql Dump、Redis RDB 写日志——MySql Binlog、Hbase HLog、Redis AOF RDB 什么是RDB 触发机制—主要三种方式 触发机制—不容忽略方式 试验什么是RDB三种方式 save命令 bgsave 自动 命令 save bgsave IO类型 同步 异步 阻塞？ 是 是（阻塞发生在fork） 复杂度 O(n) O(n) 优点 不会消耗额外内存 不阻塞客户端命令 缺点 阻塞客户端命令 需要fork，消耗内存 不容忽略方式 全量复制 debug reload shutdown总结 RDB是Redis内存到硬盘的快照，用于持久化 save通常会阻塞Redis bgsave不会阻塞Redis，但是会fork新进程 save自动配置满足任一就会被执行 有些触发机制不容忽视 AOF RDB现存问题 什么是AOF AOF三种策略 AOF重写 RDB问题 耗时、耗性能 不可控、丢失数据 什么是AOF AOF的三种策略 always everysec no 命令 always everysec no 优点 不丢失数据 每秒一次fsync 丢一秒数据 不用管 缺点 IO开销较大，一般的sata盘只有几百TPS 丢一秒数据 不可控 AOF重写作用 减少硬盘占用量 加速恢复速度AOF重写实现两种方式 bgrewriteaof AOF重写配置AOF重写流程配置RDB与AOF的抉择 命令 RDB AOF 启动优先级 低 高 体积 小 大 恢复速度 快 慢 数据安全性 丢数据 根据策略决定 轻重 重 轻 RDB最佳策略 “关” 集中管理 主从，从开？ AOF最佳策略 “开”：缓存和存储 AOF重写集中管理 everysec 最佳策略 小分片 缓存或者存储 监控（硬盘、内存、负载、网络） 足够的内存","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Redis的功能","slug":"Tools/Redis/Redis的功能","date":"2019-02-28T02:50:24.000Z","updated":"2019-02-28T02:52:43.877Z","comments":true,"path":"passages/Tools/Redis/Redis的功能/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis的功能/","excerpt":"","text":"慢查询 生命周期 两个配置 三个命令 运维经验生命周期两点说明：（1）慢查询发生在第三阶段（2）客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素两个配置slowlog-max-len 先进先出队列 固定长度 保存在内存内slowlog-log-slower-than 慢查询阈值（单位：微秒） slowlog-log-slower-than=0，记录所有命令 slowlog-log-slower-than&lt;0，不记录任何命令配置方法 默认值 config get slowlog-max-len = 128 config get slowlog-log-slower-than = 10000 修改配置文件重启 动态配置 config set slowlog-max-len 1000 config set slowlog-log-slower-than 1000三个命令 slowlog get [n]：获取慢查询队列 slowlog len：获取慢查询队列长度 slowlog reset：清空慢查询队列运维经验 slowlog-max-len不要设置过大，默认10ms，通常设置1ms slowlog-log-slower-than不要设置过小，通常设置1000左右 理解命令生命周期 定期持久化慢查询 pipeline 什么是流水线 客户端实现 与原生操作对比 使用建议一次网络命令通信模型批量网络命令通信模型流水线流水线的作用 命令 N个命令操作 1次pipeline（n个命令） 时间 n次网络+n次命令 1次网络+n次命令 数据量 1条命令 n条命令 两点注意**1. Redis的命令时间是微秒级别。 pipeline每次条数要控制（网络）。**使用建议 注意每次pipeline携带数据量 pipeline每次只能作用在一个Redis节点上 M操作与pipeline区别 发布订阅 角色 模型 API 发布订阅和消息队列Bitmap 位图 相关命令 独立用户统计 HyperLogLogGEO","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Jedis","slug":"Tools/Redis/Jedis","date":"2019-02-28T02:48:53.000Z","updated":"2019-02-28T02:50:38.511Z","comments":true,"path":"passages/Tools/Redis/Jedis/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Jedis/","excerpt":"","text":"Jedis直连123456//#1.生成一个Jedis对象，这个对象负责和指定Redis节点进行通信Jedis jedis = new Jedis(\"127.0.0.1\",6379);//#2.jedis执行set操作jedis.set(\"hello\",\"world\");//#3.jedis执行get操作，value=\"world\"String value = jedis.get(\"hello\"); Jedis(String host, int port, int connectionTimeout, int soTimeout) host：Redis节点的所在机器的IP port：Redis节点的端口 connectionTimeout：客户端连接超时 soTimeout：客户端读写超时Jedis连接池123//初始化Jedis连接池，通常来讲JedisPool是单例的。GenericObjectPoolConfigpoolConfig = new GenericObjectPoolConfig();JedisPool jedisPool = new JedisPool(poolConfig,\"127.0.0.1\",6379); 12345678910111213Jedis jedis = null;try&#123; //1.从连接池获取jedis对象 jedis = jedisPool.getResource(); //2.执行操作 jedis.set(\"hello\",\"world\");&#125; catch(Exception e)&#123; e.printStackTrace();&#125; finally&#123; if(null != jedis)&#123; //如果使用JedisPool，close操作不是关闭连接，代表归还连接池 jedis.close();&#125; 对比 优点 缺点 直连 简单方便、适用于少量长期连接的场景 存在每次新建/关闭TCP开销、资源无法控制，存在连接泄露的可能、Jedis对象线程不安全 连接池 Jedis预先生成，降低开销使用、连接池的形式保护和控制资源的使用 相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"基本特性与基于LinuxZK命令行","slug":"Tools/ZooKeeper/基本特性与基于LinuxZK命令行","date":"2019-02-04T15:45:50.000Z","updated":"2019-02-04T16:56:19.849Z","comments":true,"path":"passages/Tools/ZooKeeper/基本特性与基于LinuxZK命令行/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/ZooKeeper/基本特性与基于LinuxZK命令行/","excerpt":"","text":"zk常用命令行操作 通过./zkCli.sh打开zk的客户端进行命令行后台 ls与ls2命令 get与stat命令 create命令 set命令 delete命令zk特性-session的基本原理 客户端和服务端之间的连接存在会话 每个会话都可以设置一个超时时间 心跳结束，session则过期 Session过期，则临时节点znode会被抛弃 心跳机制：客户端向服务端的ping包请求zk特性-watcher机制 针对每个节点的操作，都会有一个监督者-&gt;watcher 当监控的某个对象（znode）发生了变化，则触发watcher事件 zk中的watcher是一次性的，触发后立即销毁 父节点，子节点增删改都能触发其watcher 针对不同类型的操作，触发的watcher事件也不同 （子）节点创建事件 （子）节点删除事件 （子）节点数据变化事件watcher命令行 通过get path [watcher] 设置watcher 父节点增删改操作触发watcher 子节点增删改操作触发watcherwatcher事件类型 创建父节点触发：NodeCreated 修改父节点数据触发：NodeDataChanged 删除父节点触发：NodeDeleted ls为父节点设置watcher，创建子节点触发：NodeChildrenChanged ls为父节点设置watcher，删除子节点触发：NodeChildrenChanged ls为父节点设置watcher，修改子节点不触发事件使用watcher统一资源配置ACLACL（Access Control Lists）权限控制 针对节点可以设置相关读写等权限，目的为了保障数据安全性 权限permissions可以指定不同的权限范围以及角色ACL命令行 getAcl：获取某个节点的acl权限信息 setAcl：设置某个节点的acl权限信息 addauth：输入认证授权信息，注册时输入明文密码（登陆），但是在zk的系统中，密码是以加密的形式存在的 ACL的构成 zk的acl通过[scheme:id:permissions]来构成权限列表 scheme：代表采用的某种权限机制 id：代表允许访问的用户 permissions：权限组合字符串scheme world：world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是world:anyone:[permissions] auth：代表认证登陆，需要注册用户有权限就可以，形式为auth:user:password:[permissions] digest：需要对密码加密才能访问，组合形式为diges:username:BASE64(SHA1(password)):[permissions] 简而言之，auth和digest的区别就是，前者明文，后者密文，setAcl /path auth:lee:lee:cdrwa与setAcl /path digest:lee:BASE64(SHA1(password))cdrwa是等价的，在通过addauth digest lee:lee后都能操作指定节点的权限 ip：当设置为ip指定的ip地址，此时限制ip进行访问，比如ip：192.168.1.1:[permissions] super：代表超级管理员，拥有所有的权限 permissions权限字符串缩写 crdwa CREATE：创建子节点 READ：获取节点/子节点 DELETE：删除子节点 WRITE：设置节点数据 ADMIN：设置权限ZooKeeper集群搭建 zk集群，主从节点，心跳机制（选举模式）注意点 配置数据文件 myid 1/2/3 对应 server.1/2/3 通过./zkCli.sh -server [ip]:[port] 检测集群是否配置成功真实环境搭建 环境变量的配置，ip配置不同，端口号可以相同 集群测试，选举测试","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"ZooKeeper","slug":"Tools/ZooKeeper","permalink":"http://kwin1113.github.io/categories/Tools/ZooKeeper/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://kwin1113.github.io/tags/ZooKeeper/"}]},{"title":"ZooKeeper简介","slug":"Tools/ZooKeeper/ZooKeeper简介","date":"2019-02-04T15:45:21.000Z","updated":"2019-02-04T16:56:15.462Z","comments":true,"path":"passages/Tools/ZooKeeper/ZooKeeper简介/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/ZooKeeper/ZooKeeper简介/","excerpt":"","text":"ZooKeeper 中间件，提供协调服务 作用于分布式系统，发挥其优势，可以为大数据服务 支持java，提供java和c语言api什么是分布式系统 很多台计算机组成一个整体，一个整体一致对外并且处理同一请求 内部的每台计算机都可以相互通信（rest/rpc） 客户端到服务端的一次请求到相应结束会历经多台计算机分布式系统图解ZooKeeper的特性 一致性：数据一致性，数据按照顺序分批入库 原子性：事务要么成功，要么失败，不会局部化 单一视图：客户端连接集群中的任一zk节点，数据都是一致的 可靠性：每次对zk的操作状态都会保存在服务端 实时性：客户端可以读取到zk服务端的最新数据zoo.cfg配置 tickTime：用于计算的事件单元。比如session超时：N*tickTime。 initLimit：用于集群，允许从节点连接并同步到master节点的初始化连接事件，以tickTime的倍数表示。 syncLimit：用于集群，master主节点与从节点之间发送消息，请求和应答事件长度。（心跳机制） dataDir：数据目录（必须配置。 dataLogDir：日志目录，如果不配置会和dataDir公用 clientPort：连接服务器的端口，默认2181 ZooKeeper基本数据模型 zk的数据模型也可以理解为linux/unix的文件目录：/usr/local/… 每一个节点都称之为znode，它可以有子节点，也可以有数据 每个节点分为临时节点和永久节点，临时节点在客户端断开后消失 每个zk节点都有各自的版本号，可以通过命令行来显示节点信息 每当节点数据发生变化，那么节点的版本号会累加（乐观锁） 删除/修改过时节点，版本号不匹配则会报错 每个zk节点存储的数据不宜过大，几K即可 节点可以设置权限acl，可以通过权限来限制用户访问ZooKeeper数据模型基本操作 客户端连接 查看znode结构 关闭客户端连接zk的作用体现 master节点选举，主节点挂了以后，从节点就会接收工作，并且保证这个节点是唯一的，这也是所谓首脑模式，从而保证我们的集群是高可用的。 统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，此操作在云计算中用的特别多 发布与订阅，类似消息队列MQ（amq，rmq…），dubbo发布者把数据存到znode上，订阅者会读取这个数据 提供分布式锁，分布式环境中不同进程之间争夺资源，类似于多线程中的锁 集群管理，集群中保证数据的强一致性","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"ZooKeeper","slug":"Tools/ZooKeeper","permalink":"http://kwin1113.github.io/categories/Tools/ZooKeeper/"}],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://kwin1113.github.io/tags/ZooKeeper/"}]},{"title":"Tomcat容器等级","slug":"Tools/Servlet/Tomcat容器等级","date":"2019-02-04T15:44:33.000Z","updated":"2019-02-04T16:56:05.842Z","comments":true,"path":"passages/Tools/Servlet/Tomcat容器等级/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Servlet/Tomcat容器等级/","excerpt":"","text":"Tomcate的容器分为四个等级，Servlet的容器管理Context容器，一个Context对应一个Web工程!72b9432000240ce54a5302f40c0379da.png","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Servlet","slug":"Tools/Servlet","permalink":"http://kwin1113.github.io/categories/Tools/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://kwin1113.github.io/tags/Servlet/"}]},{"title":"Servlet","slug":"Tools/Servlet/Servlet","date":"2019-02-04T15:44:10.000Z","updated":"2019-02-04T16:56:02.381Z","comments":true,"path":"passages/Tools/Servlet/Servlet/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Servlet/Servlet/","excerpt":"","text":"Servlet是什么？&emsp;&emsp;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet任务Servlet 执行以下主要任务： 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。Servlet包&emsp;&emsp;Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。Servlet生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。编写一个Servlet 1.继承HttpServlet2.重写doGet()或doPost()3.在web.xml中注册Servlet MyEclipseb编写Servlet1.src -&gt; new -&gt; Servlet2.重写doGet()或doPost()3.部署运行 Servlet容器装载Servlet在下列时刻Servlet容器装载Servlet：Servlet容器启动时自动装载某些Servlet，实现它只需要在web.xml文件中的之间添加如下代码： 1数字越小表示优先级越高 在Servlet容器启动后，客户首次向Servlet发送请求 Servlet类文件被更新后，重新装载Servlet Servlet与JSP内置对象的对应关系 路径跳转绝对路径相对路径 重定向：1response.sendRedirect(request.getContextPath()+\"test.jsp\"); 服务器内部跳转：1234//这里的斜线表示项目的根目录request.getRequestDispatcher(\"/test.jsp\").forward(request,response);//..表示回到上一层目录request.getRequestDispatcher(\"../test.jsp\").forward(request,response); 获取初始化参数在web.xml中配置Servlet时，可以配置一些初始化参数。而在Servlet中可以通过ServletConfig接口提供的方法来获取这些参数。 Model1简介 Model2简介Java Web的Model2开发模型就是MVC思想的体现","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Servlet","slug":"Tools/Servlet","permalink":"http://kwin1113.github.io/categories/Tools/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://kwin1113.github.io/tags/Servlet/"}]},{"title":"Redis的数据结构","slug":"Tools/Redis/Redis的数据结构","date":"2019-02-04T15:43:04.000Z","updated":"2019-02-04T16:55:54.074Z","comments":true,"path":"passages/Tools/Redis/Redis的数据结构/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/Redis的数据结构/","excerpt":"","text":"五种数据类型： 字符串（String） 哈希（Hash） 字符串列表（List） 字符串集合（Set） 有序字符串集合（sorted set） Key定义的注意点 不要过长 不要过短 统一的命名规范 存储String 二进制安全的，存入和获取的数据相同 Value最多可以容纳的数据长度是512M存储String常用命令 赋值取值：set、get、getset 删除：del 数值增减：incr、decr、incrby、decrby 扩展命令：append存储Hash String Key和String Value的map容器 每一个Hash可以存储4294967295个键值对存储Hash常用命令 赋值取值：hset、hget、hmset、hmget、hgetall 删除：del、hdel 自学命令：hexists、hlen、hkeys、hvals存储List ArrayList使用数组方式 LinkedList使用双向链接方式 双向链表中增加数据 双向链表中删除数据存储List常用命令 两端添加、弹出：hpush、rpush、lpop、rpop、lpushx、rpoplpush 查看列表：lrange 获取列表元素个数：llen 扩展命令：lrem、linsert (before)(after)存储Set 和List类型不同的是，Set集合中不允许出现重复的元素 Set可包含的最大元素数量是4294967295存储set常用命令 添加删除元素：sadd、srem、 获得集合中的元素：smembers、sismembers 集合中的差集运算：sdiff 集合中的交集运算：sinter 集合中的并集运算：sunion 扩展命令：scard、srandmember、sdiffstore、sinterstore、sunionstore存储Set使用场景 跟踪一些唯一性数据 用于维护数据对象之间的关联关系存储Sorted-Set Sorted-Set和Set的区别 Sorted-Set中的成员在集合中的位置是有序的存储Sorted-Set常用命令 添加元素、删除元素：zadd、zrem 获得元素：zscore 范围查询：zrange withscores、zrevrange withscores 扩展命令：zcard、zremrangebyrank、zremrangebyscore limit、zcountSorted-Set使用场景 如大型在线游戏积分排行榜 构建索引数据","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"NoSQL、Redis、Jedis","slug":"Tools/Redis/NoSQL、Redis、Jedis","date":"2019-02-04T15:42:33.000Z","updated":"2019-02-04T16:55:50.640Z","comments":true,"path":"passages/Tools/Redis/NoSQL、Redis、Jedis/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Redis/NoSQL、Redis、Jedis/","excerpt":"","text":"NoSQL NoSQL=Not Only SQL 非关系型的数据库 High performance - 高并发读写 Huge Storage - 海量数据的高效率存储和访问 High Scalability &amp;&amp; High Availability - 高可扩展性和高可用性NoSQL数据的四大分类 键值存储 列存储 文档数据库 图形数据库 分类 相关产品 典型应用 数据模型 优点 缺点 键值 Tokto Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 内容缓存、主要用于处理大量数据的高访问负载 一系列键值对 快速查询 存储的数据缺少结构化 列存储数据库 Cassandra、HBase、Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 查找速度快，可扩展性强，更容易进行分布式扩展 功能相对局限 文档型数据库 CouchDB、MongoDB Web应用 一系列键值对 数据结构要求不严格 查询性能不强，而且缺乏统一的查询语法 图形数据库 Neo4J、InfoGrid、Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法 需要对整个图做计算才能得出结果，不容易做分布式的集群方案 NoSQL的特点 易扩展 大数据量，高性能 灵活的数据模型 高可用 RedisRedis概述高性能键值对数据库，支持的键值数据类型： 字符串类型 散列类型 列表类型 集合类型 有序集合类型Redis的应用场景 缓存 任务队列 应用排行榜 网站访问统计 数据过期处理 分布式集群架构中的session分离Jedis引入Jedis的jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.kwin.Jedis;import org.junit.Test;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;import static org.junit.Assert.*;public class JedisTestTest &#123; /** * 单例例子 */ @Test public void demo1() &#123; Jedis jedis = new Jedis(\"192.168.200.25\", 6379); jedis.set(\"name\", \"kwin\"); System.out.println(jedis.get(\"name\")); jedis.close(); &#125; /** * 使用连接池 */ @Test public void demo2() &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(30); config.setMaxIdle(30); JedisPool jedisPool = new JedisPool(config, \"192.168.200.25\", 6379); Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.set(\"name\", \"kk\"); String value = jedis.get(\"name\"); System.out.println(value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally&#123; if (null != jedis) &#123; jedis.close(); &#125; if (null != jedisPool) &#123; jedisPool.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Redis(持更...)","slug":"Tools/Redis-持更","permalink":"http://kwin1113.github.io/categories/Tools/Redis-持更/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://kwin1113.github.io/tags/Redis/"}]},{"title":"Maven","slug":"Tools/Maven/Maven","date":"2019-02-04T15:41:52.000Z","updated":"2019-02-04T16:55:41.798Z","comments":true,"path":"passages/Tools/Maven/Maven/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Maven/Maven/","excerpt":"","text":"Maven介绍及环境搭建Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具maven项目结构src -main . -java . -package -test . -java . -package -resources Maven的常见命令mvn -v 查看maven版本 compile 编译 test 测试 package 打包 clean 删除target install 安装jar包到本地仓库中 创建目录的两种方式： 1.archetype:generate 按照提示进行选择 2.archetype：generate -DgroupId=组织名，公司地址的反写+项目名 -DartifactId=项目名-模块名 -Dversion=版本号 -Dpackage=代码所存在的包名 坐标 构件仓库 本地仓库和远程仓库镜像仓库 完整的项目构建过程包括：清理、编译、测试、打包、集成测试、验证、部署clean、compile、test、package、install Maven的生命周期clean 清理项目 pre-clean 执行清理前的工作 clean 清理上一次构建生成的所有文件 post-clean 执行清理后的文件default 构建项目（最核心） compile test package installsite 生成项目站点 pre-site 在生成项目站点前要完成的工作 site 生成项目的站点文档 post-site 在生成项目站点后要完成的工作 site-deploy发布生成的站点到服务器上 pom.xml常用元素12&lt;!-- 指定了当前pom的版本 --&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 12345678910111213141516171819&lt;!-- 坐标 --&gt;&lt;groupId&gt;&lt;/groupId&gt;&lt;artifactId&gt;&lt;/artifactId&gt;&lt;!-- 第一个0表示大版本号 第二个0表示分支版本号 第三个0表示小版本号 0.0.1 snapshot快照 alpha内部测试 beta公测 Release稳定 GA正式发布--&gt;&lt;version&gt;&lt;/version&gt;&lt;!-- 打包方式 默认是jar war zip pom--&gt;&lt;packaging&gt;&lt;/packaging&gt; 123456789101112&lt;!-- 项目描述名 --&gt;&lt;name&gt;&lt;/name&gt;&lt;!-- 项目地址 --&gt;&lt;url&gt;&lt;/url&gt;&lt;!-- 项目描述 --&gt;&lt;description&gt;&lt;/description&gt;&lt;!-- 开发人员 --&gt;&lt;developers&gt;&lt;/developers&gt;&lt;!-- 许可证 --&gt;&lt;licenses&gt;&lt;/licenses&gt;&lt;!-- 组织信息 --&gt;&lt;organization&gt;&lt;/organization&gt; 12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;type&gt;&lt;/type&gt; &lt;scope&gt;&lt;/scope&gt; &lt;!-- 设置依赖是否可选 --&gt; &lt;optional&gt;&lt;/optional&gt; &lt;!-- 排除依赖传递列表 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 123456&lt;!-- 依赖的管理 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 12345678910&lt;build&gt; &lt;!-- 插件列表 --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;&lt;/artifactId&gt; &lt;version&gt;&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 123456&lt;!-- 继承 --&gt;&lt;parent&gt;&lt;/parent&gt;&lt;!-- --&gt;&lt;modules&gt; &lt;module&gt;&lt;/module&gt;&lt;/modules&gt; 依赖的范围compile：默认provided：在编译和测试时有效runtime：在测试和运行时有效test：只在测试时有效system：与本机系统相关联，可移植性差import：导入的范围，它只使用在dependencyManagement中，表示从其他的pom中导入dependency的配置 Maven依赖传递通过引入依赖通过排除依赖 依赖冲突1.短路优先2.如果路径长度相同，先声明优先 聚合和继承1234&lt;!-- 聚合 --&gt;&lt;modules&gt; &lt;module&gt;&lt;/module&gt;&lt;/modules&gt; 123456789&lt;!-- 依赖的管理 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt;&lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- 继承 --&gt;&lt;parent&gt;&lt;/parent&gt;","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Maven","slug":"Tools/Maven","permalink":"http://kwin1113.github.io/categories/Tools/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://kwin1113.github.io/tags/Maven/"}]},{"title":"Junit4","slug":"Tools/Junit4/Junit4","date":"2019-02-04T15:41:09.000Z","updated":"2019-02-04T16:55:35.862Z","comments":true,"path":"passages/Tools/Junit4/Junit4/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Junit4/Junit4/","excerpt":"","text":"1、测试方法上必须使用@Test进行修饰2、测试方法必须使用public void进行修饰，不能带任何的参数3、新建一个源代码目录来存放我们的测试代码4、测试类的包应该和被测试类保持一致5、测试单元中的每个方法必须可以独立测试，测试方法间不能由任何的依赖6、测试类使用Test作为类名的后缀（不是必须）7、测试方法使用test作为方法名的前缀（不是必须） 1、Failure一般由单元测试使用的断言方法判断失败所引起的，这表示测试点发现了问题，就是说程序输出的结果和我们预期的不一样2、error是由代码异常引起的，它可以产生于测试代码本身的错误，也可以是被测试代码中的一个隐藏bug3、测试用例不是用来证明你是对的，而是用来证明你没有错。 1、@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它，而且在内存中它只会存在一份实例，它比较适合加载配置文件。2、@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接3、@Before和@After会在每个测试方法的前后各执行一次 @Test：将一个普通的方法修饰成为一个测试方法 @Test(expected=XX.class) @Test(timeout=毫秒)@BeforeClass：它会在所有的方法运行前被执行，static修饰@AfterClass：它会在所有的方法运行结束后被执行，static修饰@Before：会在每一个测试方法被运行前执行一次@After：会在每一个测试方法运行后被执行一次@Ignore：所修饰的测试方法会被测试运行器忽略@RunWith：可以更改测试运行器org.junit.runner.Runner 测试套件就是组织测试类一起运行的 写一个作为测试套件的入口类，这个类里不包含其他的方法更改测试运行器Suite.class将要测试的类作为数组传入到Suite.SuiteClasses({ }) 1、更改默认的测试运行期为RunWith(Parameterized.class)2、声明变量来存放预期值和结果值3、声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰4、为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量1234567891011121314151617181920212223242526@RunWith(Parameterized.class)public class ParameterTest &#123; int excepted = 0; int input1 = 0; int input2 = 0; @Parameterized.Parameters public static Collection&lt;Object[]&gt; t() &#123; return Arrays.asList(new Object[][]&#123; &#123;3,1,2&#125;, &#123;4,2,2&#125; &#125;); &#125; public ParameterTest(int excepted, int input1, int input2) &#123; this.excepted = excepted; this.input1 = input1; this.input2 = input2; &#125; @Test public void testAdd() &#123; assertEquals(excepted, new Calculate().add(input1, input2)); &#125;&#125;","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Junit4","slug":"Tools/Junit4","permalink":"http://kwin1113.github.io/categories/Tools/Junit4/"}],"tags":[{"name":"Junit4","slug":"Junit4","permalink":"http://kwin1113.github.io/tags/Junit4/"}]},{"title":"Spring JMS","slug":"Tools/Java消息中间件/Spring-JMS","date":"2019-02-04T15:40:25.000Z","updated":"2019-02-04T16:55:22.874Z","comments":true,"path":"passages/Tools/Java消息中间件/Spring-JMS/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Java消息中间件/Spring-JMS/","excerpt":"","text":"使用Spring集成JMS连接ActiveMQ ConnectionFactory：用于管理连接的连接工厂 JmsTemplate：用于发送和接收消息的模板类 MessageListener：消息监听器ConnectionFactory 一个Spring为我们提供的连接池 JmsTemplate每次发消息都会重新创建连接，会话和productor spring中提供了SingleConnectionFactory和CachingConnectionFactoryJmsTemplate 是spring提供的，只需向spring容器中注册这个类就可以使用JmsTemplate方便的操作jms JmsTemplate类是线程安全的，可以在整个应用范围使用MessageListener 实现一个onMessage方法，该方法只接收一个Messgae参数。123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;!--ActiveMQ为我们提供的ConnectionFactory--&gt; &lt;bean id=\"targetConnectionFactory\" class=\"org.apache.activemq.spring.ActiveMQConnectionFactory\"&gt; &lt;property name=\"brokerURL\" value=\"tcp://192.168.200.25:61616\"/&gt; &lt;/bean&gt; &lt;!--Spring jms为我们提供连接池--&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.SingleConnectionFactory\"&gt; &lt;property name=\"targetConnectionFactory\" ref=\"targetConnectionFactory\"/&gt; &lt;/bean&gt; &lt;!--一个队列目的地，点对点的--&gt; &lt;bean id=\"queueDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg value=\"queue\"/&gt; &lt;/bean&gt; &lt;bean id=\"topicDestination\" class=\"org.apache.activemq.command.ActiveMQTopic\"&gt; &lt;constructor-arg value=\"topic\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--导入公共配置--&gt; &lt;import resource=\"common.xml\"/&gt; &lt;!--配置消息监听器--&gt; &lt;bean id=\"consumerMessageListener\" class=\"com.kwin.jms.consumer.ConsumerMessageListener\"/&gt; &lt;!--配置消息监听容器--&gt; &lt;bean id=\"jmsContainer\" class=\"org.springframework.jms.listener.DefaultMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"destination\" ref=\"queueDestination\"/&gt; &lt;property name=\"messageListener\" ref=\"consumerMessageListener\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;import resource=\"common.xml\"/&gt; &lt;!--配置jmsTemplate，用来发送消息--&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.kwin.jms.producer.ProducerServiceImpl\"/&gt;&lt;/beans&gt; 1234567891011package com.kwin.jms.consumer;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AppConsumer &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"consumer.xml\"); &#125;&#125; 12345678910111213141516171819package com.kwin.jms.consumer;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;public class ConsumerMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"接受消息\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516package com.kwin.jms.producer;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AppProducer &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"producer.xml\"); ProducerService service = context.getBean(ProducerService.class); for (int i = 0; i &lt; 100; i++) &#123; service.sendMessage(\"test\" + i); &#125; ((ClassPathXmlApplicationContext) context).close(); &#125;&#125; 12345package com.kwin.jms.producer;public interface ProducerService &#123; void sendMessage(String message);&#125; 1234567891011121314151617181920212223242526272829package com.kwin.jms.producer;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jms.core.JmsTemplate;import org.springframework.jms.core.MessageCreator;import javax.annotation.Resource;import javax.jms.*;public class ProducerServiceImpl implements ProducerService &#123; @Autowired JmsTemplate jmsTemplate; @Resource(name = \"queueDestination\") Destination destination; public void sendMessage(final String message) &#123; //使用JmsTemplate发送消息 jmsTemplate.send(destination, new MessageCreator() &#123; //创建一个消息 public Message createMessage(Session session) throws JMSException &#123; TextMessage textMessage = session.createTextMessage(message); return textMessage; &#125; &#125;); System.out.println(\"发送消息\" + message); &#125;&#125; Topic模式方法类似","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Java消息中间件","slug":"Tools/Java消息中间件","permalink":"http://kwin1113.github.io/categories/Tools/Java消息中间件/"}],"tags":[{"name":"Java消息中间件","slug":"Java消息中间件","permalink":"http://kwin1113.github.io/tags/Java消息中间件/"}]},{"title":"ActiveMQ","slug":"Tools/Java消息中间件/ActiveMQ","date":"2019-02-04T15:40:05.000Z","updated":"2019-02-04T16:55:19.487Z","comments":true,"path":"passages/Tools/Java消息中间件/ActiveMQ/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Java消息中间件/ActiveMQ/","excerpt":"","text":"使用JMS接口规范连接ActiveMQ 创建生产者 创建消费者 创建发布者 创建订阅者队列模式12345678910111213141516171819202122232425262728293031323334353637383940414243package com.kwin.jms.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppProducer &#123; private static final String url = \"tcp://192.168.200.25:61616\"; private static final String queueName = \"queue-test\"; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6，创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; i++) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage(\"test\" + i); //8.发布消息 producer.send(textMessage); System.out.println(\"发送消息\" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.kwin.jms.queue;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppConsumer &#123; private static final String url = \"tcp://192.168.200.25:61616\"; private static final String queueName = \"queue-test\"; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createQueue(queueName); //6，创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener((new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"接受消息\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); //9.关闭连接 //connection.close(); &#125;&#125; 主题模式12345678910111213141516171819202122232425262728293031323334353637383940414243package com.kwin.jms.topic;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppProducer &#123; private static final String url = \"tcp://192.168.200.25:61616\"; private static final String topicName = \"topic-test\"; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6，创建一个生产者 MessageProducer producer = session.createProducer(destination); for (int i = 0; i &lt; 100; i++) &#123; //7.创建消息 TextMessage textMessage = session.createTextMessage(\"test\" + i); //8.发布消息 producer.send(textMessage); System.out.println(\"发送消息\" + textMessage.getText()); &#125; //9.关闭连接 connection.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.kwin.jms.topic;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;public class AppConsumer &#123; private static final String url = \"tcp://192.168.200.25:61616\"; private static final String topicName = \"topic-test\"; public static void main(String[] args) throws JMSException &#123; //1.创建ConnectionFactory ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url); //2.创建Connection Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.创建会话 Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建一个目标 Destination destination = session.createTopic(topicName); //6，创建一个消费者 MessageConsumer consumer = session.createConsumer(destination); //7.创建一个监听器 consumer.setMessageListener((new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage = (TextMessage) message; try &#123; System.out.println(\"接受消息\" + textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;)); //9.关闭连接 //connection.close(); &#125;&#125;","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Java消息中间件","slug":"Tools/Java消息中间件","permalink":"http://kwin1113.github.io/categories/Tools/Java消息中间件/"}],"tags":[{"name":"Java消息中间件","slug":"Java消息中间件","permalink":"http://kwin1113.github.io/tags/Java消息中间件/"}]},{"title":"消息中间件","slug":"Tools/Java消息中间件/消息中间件","date":"2019-02-04T15:39:02.000Z","updated":"2019-02-04T16:55:26.422Z","comments":true,"path":"passages/Tools/Java消息中间件/消息中间件/","link":"","permalink":"http://kwin1113.github.io/passages/Tools/Java消息中间件/消息中间件/","excerpt":"","text":"通过服务调用让其他系统感知事件发生 通过消息中间件解耦服务调用 消息中间件带来的好处 解耦 异步 横向扩展 安全可靠 顺序保证 ……什么是中间件？&emsp;&emsp;非底层操作系统软件，非业务应用软件，不是直接给最终用户使用的，不能直接给用户带来价值的软件统称为中间件。&emsp;&emsp;关注于数据的发送和接受，利用高效可靠的异步消息传递机制集成分布式系统。消息中间件图示什么是JMS？&emsp;&emsp;Java消息服务（Java Message Service）即JMS，是一个Java平台中关于面向消息中间件的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。什么是AMQP？&emsp;&emsp;AMQP（Advanced Message Queuing Protocol）是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。JMS与AMQP对比 JMS规范 AMQP协议 定义 Java API Wire-protocol 跨语言 否 是 消息模型 提供两种消息模型：p2p，pub/sub 提供了五种消息模型：direct，fanout，topic，headers，system 消息类型 TextMessage，MapMessage，BytesMessage，StreamMessage，ObjectMessage，Message byte[] 综合评价 JMS定义了Java API层面的标准；在Java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全 ActiveMQ特性 多种语言和协议编写客户端。语言：Java、C、C++、C#、Ruby、Perl、Python、PHP。应用协议：OpenWire、Stomp REST、WS Notification、XMPP、AMQP 完全支持JMS1.1和J2EE1.4规范（持久化，XA消息，事务） 虚拟主题、组合目的、镜像队列RabbitMQ特性 支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ACtionScript等 AMQP的完整实现（vhost、Exchange、Bindind、RoutingKey等） 事务支持/发布确认 消息持久化Kafka特性 通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。 高吞吐量：即使是非常普通的硬件Kafka也可以支持每秒数百万的消息。 Partition、Consumer Group综合评价 ActiveMQ RabbitMQ Kafka 跨语言 支持（Java优先） 语言无关 支持（Java优先） 支持协议 OpenWire、Stomp、XMPP、AMQP AMQP 优点 遵循JMS规范，安装部署方便 继承Erlang天生的并发性，最初用于金融行业，稳定性，安全性有保障 依赖zk，可动态扩展节点，高性能、高吞吐量、无限扩容，消息可指定追溯 缺点 根据其他用户反馈，会莫名丢失消息。目前重心在下代产品apolle上，目前社区不活跃，对5.X维护较少 Erlang语言难度较大，不支持动态扩展 严格的顺序机制，不支持消息优先级，不支持标准的消息协议，不利于平台迁移 综合评价 适合中小企业级消息应用场景，不适合上千个队列的应用场景 适合对稳定性要求高的企业级应用 一般应用在大数据日志处理或对实时性（少量延迟），可靠性（少量丢数据）要求稍低的场景使用 JMS相关概念 提供者：实现JMS规范的消息中间件服务器 客户端：发送或接收消息的应用程序 生产者/发布者：创建并发送消息的客户端 消费者/订阅者：接收并处理消息的客户端 消息：应用程序之间传递的数据内容 消息模式：在客户端之间传递消息的方式，JMS中定义了主题和队列两种模式队列模式 客户端包括生产者和消费者 队列中的消息只能被一个消费者消费 消费者可以随时消费队列中的消息主题模式 客户端包括发布者和订阅者 主题中的消息被订阅者消费 消费者不能消费订阅之前就发送到主题中的消息JMS规范JMS编码接口 ConnectionFactory：用于创建连接到消息中间件的连接工厂 Connection：代表了应用程序和消息服务器之间的通信链路 Destination：指消息发布和接收的地点，包括队列或主题 Session：表示一个单线程的上下文，用于发送和接收消息 MessageConsumer：由会话创建，用于接收发送到目标的消息 MessageProducer：由会话创建，用于发送消息到目标 Message：是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体JMS编码接口之间的关系","categories":[{"name":"Tools","slug":"Tools","permalink":"http://kwin1113.github.io/categories/Tools/"},{"name":"Java消息中间件","slug":"Tools/Java消息中间件","permalink":"http://kwin1113.github.io/categories/Tools/Java消息中间件/"}],"tags":[{"name":"Java消息中间件","slug":"Java消息中间件","permalink":"http://kwin1113.github.io/tags/Java消息中间件/"}]},{"title":"Shell基础","slug":"Linux/Shell/Shell基础","date":"2019-02-04T15:37:40.000Z","updated":"2019-02-04T16:54:21.671Z","comments":true,"path":"passages/Linux/Shell/Shell基础/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Shell/Shell基础/","excerpt":"","text":"Shell基础1. Shell是什么 Shell是一个命令行解释器，它为用户提供了一个向Linux内核发送请求一边运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止甚至是编写一些程序。 Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，在Shell中可以直接调用Linux命令。2. Shell的分类 Bourne Shell：从1979起Unix就开始使用Bourne Shell，Bourne Shell的主文件名为sh。 C Shell：C Shell主要在BSD版的Unix系统中使用，其语法和C语言相类似而得名。 Shell的两种主要语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh Bash：Bash与sh兼容，现在使用的Linux就是使用Bash作为用户的基本Shell。3. Linux支持的Shell /etc/shells脚本执行方式1. echo输出命令 echo [选项] [输出内容]-e：支持反斜线控制的字符转换。 控制字符 作用 \\a 输出警告音 \\b 退格键，也就是向左删除键 \\n 换行键 \\r 回车键 \\t 制表符，也就是tab键 \\v 垂直制表符 \\0nnn 按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数 \\xhh 按照十六进制ASCII码表输出字符。其中hh是两位十六进制数 echo -e \\”\\68\\t\\x65\\t\\x6c\\n\\x6c\\t\\x6f\\t”#按照十六进制ASCII码也同样可以输出 echo -e “\\e[1;31m 嫁人就要嫁凤姐 \\e[0m”#输出颜色 #30m=黑色，31m=红色，32m=绿色，33m=黄色 #34m=蓝色，35m=洋红，36m=青色，37m=白色2. 第一个脚本 vim hello.sh #!/bin/bash #The first program echo -e “\\e[1;34m 天上掉下个林妹妹 \\e[0m”3. 脚本执行 赋予执行权限，直接运行chmod 755 hello.sh./hello.sh 通过Bash调用执行脚本bash hello.shBash的基本功能查看与设定别名 alias#查看系统中所有的命令别名 alias 别名=‘原命令’#设定命令别名别名永久生效与删除别名 vi ~/.bashrc#写入环境变量配置文件 unalias 别名#删除别名命令生效顺序 第一顺位执行用绝对路径或相对路径执行的命令 第二顺位执行别名 第三顺位执行Bash的内部命令 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令常用快捷键 ctrl+c：强制终止当前命令 ctrl+l：清屏 ctrl+a：光标移动到命令行首 ctrl+e：光标移动到命令行尾 ctrl+u：从光标所在位置删除到行首 ctrl+z：把命令放在后台 ctrl+r：在历史命令中搜索历史命令1. 历史命令 history [选项] [历史命令保存文件]-c：清空历史命令-w：把缓存中的历史命令写入历史命令保存文件~/.bash_history 历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改历史命令的调用 使用上、下箭头调用以前的历史命令 使用“!n”重复执行第n条历史命令 使用“!!”重复执行上一条命令 使用“!字符”重复执行最后一条以该字符串开头的命令2. 命令与文件补全 在Bash中，命令与文件补全是非常方便与常用的功能，我们只要在输入命令或文件时，按“Tab”键就会自动进行补全。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"Shell(持更...)","slug":"Linux/Shell-持更","permalink":"http://kwin1113.github.io/categories/Linux/Shell-持更/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"VIM编辑器","slug":"Linux/Commands/VIM编辑器","date":"2019-02-04T15:36:28.000Z","updated":"2019-02-04T16:53:32.612Z","comments":true,"path":"passages/Linux/Commands/VIM编辑器/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Commands/VIM编辑器/","excerpt":"","text":"VI编辑器的操作模式 Command Mode - 命令模式 Insert Mode - 输入模式 Last Line Mode - 底行模式常用指令底行模式常用指令:w:q:!:ls:n:15/xxx?xxx命令模式常用指令h：光标左移j：光标下移k：光标上移l：光标右移ctrl+f：向下翻页ctrl+b：向上翻页ctrl+d：向下翻半页ctrl+u：向上翻半夜dd：删除光标所在行o：在光标所在行的下方插入一行并切换到输出模式yy：复制光标所在的行p：在光标所在行的下方粘贴P：在光标所在行的上方粘贴","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"常用命令","slug":"Linux/常用命令","permalink":"http://kwin1113.github.io/categories/Linux/常用命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"用户管理","slug":"Linux/SysManage/用户管理","date":"2019-02-04T15:35:58.000Z","updated":"2019-02-04T16:54:50.354Z","comments":true,"path":"passages/Linux/SysManage/用户管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/用户管理/","excerpt":"","text":"用户和用户组 用户：使用操作系统的人 用户组：具有相同系统权限的一组用户 /etc/group：存储当前系统中所有用户组信息-Group ：x ：123 ：abc,def,xyz-组名称 ：组密码占位符 ：组编号 ：组中用户名列表 /etc/gshadow：存储当前系统中用户组的密码信息-Group ：* ： ：abc,def,xyz-组名称 ：组密码 ：组管理者 ：组中用户名列表 /etc/passwd：存储当前系统中所有用户的信息-user ：x ：123 ：456 ： xxxxxxxxx ：/home/user/ ：/bin/bash-用户名 ：密码占位符 ：用户编号 ：用户组编号 ：用户注释信息 ：用户主目录 ：shell类型 /etc/shadow：存储当前系统中所有用户的密码信息-user ：vf；Zu8sdf… ：：：：：-用户名 ：密码 ：：：：：其他命令 whoami-我是谁？显示当前登陆用户 id kwin-显示指定用户信息，包括用户编号、用户名 groups kwin-显示kwin用户所在的所有组 chfn kwin-设置用户资料，一次输入用户资料 finger kwin-显示用户详细资料","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"磁盘管理","slug":"Linux/SysManage/磁盘管理","date":"2019-02-04T15:35:22.000Z","updated":"2019-02-04T16:54:53.342Z","comments":true,"path":"passages/Linux/SysManage/磁盘管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/磁盘管理/","excerpt":"","text":"磁盘管理 df：查看磁盘分区使用状况-l：仅显示本地磁盘（默认）-a：显示所有文件系统的磁盘使用情况，包含比如/proc/-h：以1024进制计算最合适的单位显示磁盘容量-H：以1000进制计算最合适的单位显示磁盘容量-T：显示磁盘分区类型-t：显示指定类型文件系统的磁盘分区-x：不显示指定类型文件系统的磁盘分区 du：统计磁盘上的文件大小-b：以byte为单位统计文件-k：以KB为单位统计文件-m：以MB为单位统计文件-h：按照1024进制以最合适的单位统计文件-H：按照1000进制以最合适的单位统计文件-s：指定统计目标添加硬盘分区格式化","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"压缩与解压缩命令","slug":"Linux/Commands/压缩与解压缩命令","date":"2019-02-04T15:34:21.000Z","updated":"2019-02-04T16:53:35.284Z","comments":true,"path":"passages/Linux/Commands/压缩与解压缩命令/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Commands/压缩与解压缩命令/","excerpt":"","text":"常用压缩格式 .zip .gz .bz2 .tar.gz .tar.bz2.zip格式压缩 zip 压缩文件名 源文件#压缩文件 zip -r 压缩文件名 源目录#压缩目录.zip格式解压缩 unzip 压缩文件#解压缩.zip文件.gz格式压缩 gzip 源文件#压缩为.gz格式的压缩文件，源文件会消失 gzip -c 源文件 &gt; 压缩文件#压缩为.gz格式，源文件保留例如：gzip -c cangls &gt; cangls.gz gzip -r 目录#压缩目录下所有的子文件，但是不能压缩目录.gz格式解压缩 gzip -d 压缩文件#解压缩文件 gunzip 压缩文件#解压缩文件.bz2格式压缩 bzip2 源文件#压缩为.bz2格式，不保留源文件 bzip2 -k 源文件#压缩之后保留源文件 注意：bzip2命令不能压缩目录.bz2格式解压缩 bzip2 -d 压缩文件#解压缩，-k保留压缩文件 bunzip2 压缩文件#解压缩，-k保留压缩文件打包命令tar tar -cvf 打包文件名 源文件-c：打包-v：显示过程-f：指定打包后的文件名 例如：tar -cvf longzls.tar longzls解打包命令 tar -xvf 打包文件名-x：解打包 例如：tar -xvf longzls.tar.tar.gz压缩格式 .tar.gz格式先打包为.tar格式，再压缩为.gz格式 tar -zcvf 压缩包名.tar.gz 源文件 tar -zxvf 压缩包名.tar.gz-z：压缩为.tar.gz格式-x：解压缩.tar.gz格式.tar.bz2压缩格式 tar -jcvf 压缩包名.tar.bz2 源文件 tar -jxvf 压缩包名.tar.bz2-z：压缩为.tar.bz2格式-x：解压缩.tar.bz2格式","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"常用命令","slug":"Linux/常用命令","permalink":"http://kwin1113.github.io/categories/Linux/常用命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"帮助命令","slug":"Linux/Commands/帮助命令","date":"2019-02-04T15:34:05.000Z","updated":"2019-02-04T16:53:37.359Z","comments":true,"path":"passages/Linux/Commands/帮助命令/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Commands/帮助命令/","excerpt":"","text":"帮助命令man man命令#获取指定命令的帮助 man ls#查看ls的帮助man的级别 1：查看命令的帮助 2：查看可被内核调用的函数的帮助 3：查看函数和函数库的帮助 4：查看特殊文件的帮助（主要是/dev目录下的文件） 5：查看配置文件的帮助 6：查看游戏的帮助 7：查看其他杂项的帮助 8：查看系统管理员可用命令的帮助 9：查看和内核相关文件的帮助查看命令拥有哪个级别的帮助 man -f 命令 相当于 whatis 命令 举例： man -5 passwd man -4 null man -8 ifconfig查看和命令相关的所有帮助 man -k 命令 相当于 apropos 命令 例如： apropos passwdshell内部命令帮助 help shell 内部命令#获取shell内部命令的帮助 例如： whereis cd#确定是否是shell内部命令 help cd#获取内部命令帮助详细命令帮助info info 命令-回车：进入子帮助页面（带有*号标记）-u：进入上层页面-n：进入下一个帮助小结-p：进入上一个帮助小结-q：退出","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"常用命令","slug":"Linux/常用命令","permalink":"http://kwin1113.github.io/categories/Linux/常用命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"文件搜索命令","slug":"Linux/Commands/文件搜索命令","date":"2019-02-04T15:33:47.000Z","updated":"2019-02-04T16:53:42.311Z","comments":true,"path":"passages/Linux/Commands/文件搜索命令/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Commands/文件搜索命令/","excerpt":"","text":"locatelocate格式 locate 文件名在后台数据库中按文件名搜索，搜索速度更快 /var/lib/mlocate#locate updatedb更新数据库/etc/updatedb.conf配置文件 PRUNE_BIND_MOUNTS=”yes”#开启搜索限制 PRUNEFS=#搜索时，不搜索的文件系统 PRUNENAMES=#搜索时，不搜索的文件类型 PRUNEPATHS=#搜索时，不搜索的文件路径搜索命令的命令whereis whereis 命令名#搜索命令所在路径及帮助文档所在位置选项：-b：只查找可执行文件-m：之查找帮助文件which which 文件名#搜索命令所在路径及别名find命令 find [搜索范围] [搜索条件]#搜索文件 find / -name install.log#避免大范围搜索，会非常耗费系统资源#find是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配grep命令 grep [选项] 字符串 文件名#在文件当中匹配符合条件的字符串-i：忽略大小写-v：排除指定字符串find命令与grep命令的区别 find命令：在系统当中搜索符合条件的文件名，如果需要匹配，使用通配符匹配，通配符是完全匹配。 grep命令：在文件当中搜索符合条件的字符串，如果需要匹配，使用正则表达式匹配，正则表达式是包含匹配。PATH环境变量 PATH环境变量：定义的是系统搜索命令的路径 echo $PATH/usr/lib/qt-3.3/bin:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/binLinux中的通配符 符号 匹配内容 * 匹配任意内容 ？ 匹配任意一个字符 [] 匹配任意一个中括号内的字符 find /root -iname install.log#不区分大小写 find /root -user root#按照所有者搜索 find /root -nouser#查找没有所有者的文件 find /var/log/ -mtime +10 -10 10天内修改的文件10 10天当天修改的文件+10 10天前修改的文件 atime 文件访问时间ctime 改变文件属性mtime 修改文件内容 find . -size 25k#查找文件大小是25KB的文件 -25k 小于25KB的文件25k 等于25KB的文件+25k 大于25KB的文件 find . -inum 262422#查找i节点是262422的文件 find /etc -size +20k -a -size -50k#查找/etc/目录下，大于20KB并且小于50KB的文件-a and 逻辑与，两个条件都满足-o or 逻辑或，两个条件满足一个即可 find /etc -size +20k -a -size -50k -exec ls -lh {} \\;#查找/etc/目录下，大于20KB并且小于50KB的文件，并显示详细信息#-exec/-ok命令{} \\；对搜索结果执行操作","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"常用命令","slug":"Linux/常用命令","permalink":"http://kwin1113.github.io/categories/Linux/常用命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"文件处理命令","slug":"Linux/Commands/文件处理命令","date":"2019-02-04T15:33:03.000Z","updated":"2019-02-04T16:53:39.874Z","comments":true,"path":"passages/Linux/Commands/文件处理命令/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/Commands/文件处理命令/","excerpt":"","text":"建立目录：mkdir mkdir -p [目录名]-p：递归创建切换所在目录：cd cd [目录] 简化操作-cd ~：进入当前用户的家目录-cd：进入当前用户的家目录-cd -：进入上次目录-cd ..：进入上一级目录-cd .：进入当前目录 相对路径：参考当前所在目录进行查找如：cd ../usr/local/src/ 绝对路径：从根目录开始指定，一级一级递归查找。在任何目录下都能进入指定位置如：cd /etc/查询目录所在位置：pwd pwd删除空目录：rmdir rmdir [目录名] 删除文件或目录：rm rm -rf [文件或目录][选项]-r：删除目录-f：强制复制命令：cp cp [选项] [原文件或目录] [目标目录][选项]-r：复制目录-p：连带文件属性复制-d：若源文件是链接文件，则复制链接属性-a：相当于-pdr剪切或改名命令：mv mv [原文件或目录] [目标目录]常用目录的作用 /：根目录 /bin：命令保存目录（普通用户就可以读取的命令） /boot：启动目录，启动相关文件 /dev：设备文件保存目录 /etc：配置文件保存目录 /home：普通用户的家目录 /lib：系统库保存目录 /mnt：系统挂载目录 /media：挂载目录 /root：超级用户的家目录 /tmp：临时目录 /sbin：命令保存目录（超级用户才能使用的目录） /proc：直接写入内存的 /sys：系统 /usr：系统软件资源目录/usr/bin/系统命令（普通用户）/usr/sbin/系统命令（超级用户） /var：系统相关文档内容链接命令：ln ln -s [原文件] [目标文件] 生成链接文件 -s：生成软链接 硬链接特征： 拥有相同的i节点和存储block块，可以看作是同一个文件 可通过i节点识别 不能跨分区 不能针对目录使用 软连接特征： 类似windows快捷方式 软连接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据 lrwxrwxrwx |软连接软连接文件全写都为rwxrwxrwx 修改任意文件，另一个都改变 删除源文件，软链接不能使用","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"常用命令","slug":"Linux/常用命令","permalink":"http://kwin1113.github.io/categories/Linux/常用命令/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"源码包服务管理","slug":"Linux/ServiceManage/源码包服务管理","date":"2019-02-04T15:31:14.000Z","updated":"2019-02-04T16:54:09.862Z","comments":true,"path":"passages/Linux/ServiceManage/源码包服务管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/ServiceManage/源码包服务管理/","excerpt":"","text":"1. 源码包安装服务的启动 使用绝对路径，调用启动脚本来启动。不同的源码包的启动脚本不同。可以查看源码包的安装说明，查看启动脚本的方法。/usr/local/apache2/bin/apachectl start|stop2. 源码包服务的自启动 vim /etc/rc.d/rc.local 加入 /usr/local/apache2/bin/apachectl start3. 让源码包服务被服务管理命令识别 让源码包的apache服务能被service命令管理启动ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache或cp /usr/local/apache2/bin/apachectl /etc/init.d/apache 让源码包的apache服务能被chkconfig与ntsysv命令管理自启动 vim /etc/init.d/apache#chkconfig : 35 86 76#指定httpd脚本可以被chkconfig命令管理。格式是：chkconfig：运行级别 启动顺序 关闭顺序#description：source package apache#说明 chkconfig –add apache#把源码包apache加入chkconfig命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"服务管理","slug":"Linux/服务管理","permalink":"http://kwin1113.github.io/categories/Linux/服务管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"RPM包服务管理","slug":"Linux/ServiceManage/RPM包服务管理","date":"2019-02-04T15:30:52.000Z","updated":"2019-02-04T16:54:07.295Z","comments":true,"path":"passages/Linux/ServiceManage/RPM包服务管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/ServiceManage/RPM包服务管理/","excerpt":"","text":"1. RPM包安装服务的位置 RPM安装服务和源码包安装服务的区别就是安装位置的不同 /etc/init.d/：启动脚本位置 /etc/sysconfig/：初始化环境配置文件位置 /etc/：配置文件位置 /etc/xinetd.conf：xinetd配置文件 /etc/xinetd.d/：基于xinetd服务的启动脚本 /var/lib/：服务产生的数据 /var/log/：日志2. 独立服务的启动 /etc/init.d/独立服务名 start|stop|status|restart| service 独立服务名 start|stop|status|restart|3. 独立服务的自启动 chkconfig [–level运行级别] [独立服务名] [on|off] 修改/etc/rc.d/rc.local文件 使用ntsysv命令管理自启动xinetd1. 安装xinetd yum -y install xinetd2. xinetd服务的启动 vim /etc/xinetd.d/rsync 重启xinetd服务 service xinetd restart3. xinetd服务的自启动 chkconfig telnet on ntsysv","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"服务管理","slug":"Linux/服务管理","permalink":"http://kwin1113.github.io/categories/Linux/服务管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"简介与分类","slug":"Linux/ServiceManage/简介与分类","date":"2019-02-04T15:30:31.000Z","updated":"2019-02-04T16:54:13.617Z","comments":true,"path":"passages/Linux/ServiceManage/简介与分类/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/ServiceManage/简介与分类/","excerpt":"","text":"简介与分类运行级别 运行级别 含义 0 关机 1 单用户模式，可以想象为windows的安全模式，主要用于系统修复 2 不完全的命令行模式，不含NFS服务 3 完全的命令行模式，就是标准字符界面 4 系统保留 5 图形模式 6 重启动 运行级别命令 runlevel#查看运行级别命令 init 运行级别#修改运行级别命令系统默认运行级别 vim /etc/inittab-id:3:initdefault:#系统开机后直接进入哪个运行级别服务的分类查询已安装的服务 RPM包安装的服务chkconfig –list#查看服务自启动状态，可以看到所有RPM包安装的服务 源码包安装的服务#查看服务安装位置，一般是/usr/local/下启动与自启动 服务启动：就是在当前系统中让服务运行，并提供功能。 服务自启动：自启动是指让服务在系统开机或重启动之后，随着系统的启动而自动启动服务。RPM安装服务和源码包安装服务的区别 RPM安装服务和源码包安装服务的区别就是安装位置的不同-源码包安装在指定位置，一般是/usr/local/-RPM包安装在默认位置中端口是什么 如果把IP地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个IP地址的端口可以有65536个。端口与服务的对应 /etc/services查询系统中开启的服务 netstat -tlunp-t：列出tcp数据-u：列出udp数据-l：列出正在监听的网络服务（不包含已经连接的网络服务）-n：用端口号来显示服务，而不是用服务名-p：列出该服务的进程ID（PID） 会列出系统中所有的已经启动的服务总结","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"服务管理","slug":"Linux/服务管理","permalink":"http://kwin1113.github.io/categories/Linux/服务管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"不可改变位权限","slug":"Linux/SpecialAuthority/不可改变位权限","date":"2019-02-04T15:29:36.000Z","updated":"2019-02-04T16:54:41.303Z","comments":true,"path":"passages/Linux/SpecialAuthority/不可改变位权限/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SpecialAuthority/不可改变位权限/","excerpt":"","text":"chattr命令格式 chattr [+-=] [选项] 文件或目录名+：增加权限-：删除权限=：等于某权限 chattr选项包括：i和a a等价于appendi等价于insert 选项-i：如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和删除文件。-a：如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许删除。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之特殊权限","slug":"Linux/权限管理之特殊权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之特殊权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"文件特殊权限","slug":"Linux/SpecialAuthority/文件特殊权限","date":"2019-02-04T15:29:16.000Z","updated":"2019-02-04T16:54:43.737Z","comments":true,"path":"passages/Linux/SpecialAuthority/文件特殊权限/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SpecialAuthority/文件特殊权限/","excerpt":"","text":"1. SetUID的功能 只有可以执行的二进制程序才能设定SUID权限 命令执行者要对该程序拥有x（执行）权限 命令执行者在执行该程序时获得该程序文件属主的身份（在执行程序的过程中灵魂附体为文件的属主） SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效 passwd命令拥有SetUID权限，所以普通可以修改自己的密码 ll /usr/bin/passwd-rwsr-xr-x.1 root root 25980 2月 22 2012 /usr/bin/passwd2. 设定SetUID的方法 4代表SUIDchmod 4755 文件名chmod u+s 文件名3. 取消SetUID的方法 chmod 0755 文件名 chmod u-s 文件名4. 危险的SetUID 关键目录应严格控制写权限。比如“/”、“/usr”等 用户的密码设置要严格遵守密码三原则 对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限1. SetGID针对文件的作用 只有可执行的二进制程序才能设置SGID权限 命令执行者要对该程序拥有x（执行）权限 命令执行在执行程序的时候，组身份升级为该程序文件的属组 SetGID权限同样只在该程序执行过程中有效，也就是说组身份改变只在程序执行过程中有效 ll /usr/bin/locate-rwx–s–x 1 root slocate 35612 8月 24 2010 /usr/bin/locate ll /var/lib/mlocate/mlocate.db-rw-r—– 1 root slocate 1838850 1月 20 04:29 /var/lib/mlocate/mlocate.db /usr/bin/locate是可执行二进制程序，可以赋予SGID 执行用户lamp对/usr/bin/locate命令拥有执行权限 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate命令查询mlocate.db数据库 命令结束，lamp用户的组身份返回为lamp组2. SetGID针对目录的作用 普通用户必须对此目录拥有r和x权限，才能进入此目录 普通用户在此目录中的有效组会变成此目录的属组 若普通用户对此目录拥有w权限时，新建的文件的默认属组是这个目录的属组3. 设定SetGID 2代表SGIDchmod 2755 文件名chmod g+s 文件名4. 取消SetGID chmod 0755 文件名 chmod g-s 文件名1. SBIT粘着位作用 粘着位目前只对目录有效 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限 如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下的所有文件，包括其他用户建立的文件。一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件2. 设置与取消粘着位 设置粘着位chmod 1755 目录名chmod o+t 目录名 取消粘着位chmod 0777 目录名chmod o-t 目录名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之特殊权限","slug":"Linux/权限管理之特殊权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之特殊权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"sudo权限","slug":"Linux/SpecialAuthority/sudo权限","date":"2019-02-04T15:29:01.000Z","updated":"2019-02-04T16:54:38.822Z","comments":true,"path":"passages/Linux/SpecialAuthority/sudo权限/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SpecialAuthority/sudo权限/","excerpt":"","text":"1. sudo权限 root把本来只能超级用户执行的命令赋予普通用户执行。 sudo的操作对象是系统命令。2. sudo使用 visudo#实际修改的是/etc/sudoers文件 root ALL=(ALL) ALL#用户名 被管理的主机=（可使用的身份） 授权命令（绝对路径） %wheel ALL=(ALL) ALL#%组名 被管理主机的地址=（可使用的身份） 授权命令（绝对路径）例eg1. visudo -user1 ALL=/sbin/shudown -r noweg.2 su - user1 sudo -l#查看可用的sudo命令 sudo /sbin/shutdown -r now#普通用户执行sudo赋予的命令eg.3 visudo-user1 ALL=/usr/sbin/useradd-user1 ALL=/usr/bin/passwd#授予用户设定密码的权限-user1 ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd “”, !/usr/bin/passwd root#不能设定root用户的密码","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之特殊权限","slug":"Linux/权限管理之特殊权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之特殊权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"ACL权限","slug":"Linux/SpecialAuthority/ACL权限","date":"2019-02-04T15:28:25.000Z","updated":"2019-02-04T16:54:35.967Z","comments":true,"path":"passages/Linux/SpecialAuthority/ACL权限/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SpecialAuthority/ACL权限/","excerpt":"","text":"1. ACL权限简介 2. 查看分区ACL权限是否开启 dumpe2fs -h /dev/sda5#dumpe2fs命令是查询指定分区详细文件系统信息的命令选项：-h：仅显示超级块中信息，而不显示磁盘块组的详细信息3. 临时开启分区ACL权限 mount -o remount,acl /#重新挂载根分区，并挂载加入acl权限4. 永久开启分区ACL权限 vim /etc/fstab UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2 / ext4 defaults,acl 1 1#加入acl mount -o remount /#重新挂载文件系统或重启动系统，使修改生效5. ACL命令操作查看ACL命令 getfacl 文件名#查看acl权限设定ACL权限的命令 setfacl 选项 文件名-m：设定ACL权限-x：删除指定的ACL权限-b：删除所有的ACL权限-d：设定默认ACL权限-k：删除默认ACL权限-R：递归设定ACL权限给用户设定ACL权限 useradd tony groupadd stu mkdir /av chown tony:stu /av chmod 770 /av useradd lw setfacl -m u:lw:rx /av#给用户st赋予r-x权限，使用“u:用户名:权限”格式给用户组设定ACL权限 groupadd tgroup2 setfacl -m g:tgroup2:rwx /av#为组tgroup2分配ACL权限。使用“g:组名:权限”格式最大有效权限mask mask是用来指定最大有效权限的。如果我给用户赋予了ACL权限，是需要和mask的权限“相与”才能得到用户的真正权限。修改最大有效权限 setfacl -m m:rx 文件名#设定mask权限为r-x。使用“m:权限”格式删除ACL权限 setfacl -x u:用户名 文件名#删除指定用户的ACL权限 setfacl -x g:组名 文件名#删除指定用户组的ACL权限 setfacl -b 文件名#会删除文件的所有的ACL权限递归ACL权限 递归是父目录在设定ACL权限时，所有的子文件和子目录也会拥有相同的ACL权限。 setfacl -m u:用户名:权限 -R 文件名默认ACL权限 默认ACL权限的作用是如果给父目录设定了默认ACL权限，那么父目录中所有新建的子文件都会继承父目录的ACL权限。 setfacl -m d:u:用户名:权限 文件名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之特殊权限","slug":"Linux/权限管理之特殊权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之特殊权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"文件的默认权限","slug":"Linux/BasicAuthority/文件的默认权限","date":"2019-02-04T15:27:35.000Z","updated":"2019-02-04T16:53:27.799Z","comments":true,"path":"passages/Linux/BasicAuthority/文件的默认权限/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/BasicAuthority/文件的默认权限/","excerpt":"","text":"查看默认权限的命令 umask查看默认权限 0022-第一位0：文件特殊权限-022：文件默认权限文件的默认权限 例如：-文件默认最大权限666 umask值022–rw-rw-rw- 减去 —–w–w-等于 -rw-r–r– 例如：-文件默认最大权限666 umask值033–rw-rw-rw- 减去 —–wx-wx等于 -rw-r–r– 文件默认不能建立为执行文件，必须手工赋予执行权限 所以文件默认权限最大为666 默认权限需要换算成字母再相减 建立文件之后的默认权限，为666减去umask值目录的默认权限 目录默认权限最大为777 默认权限需要换算成字母再相减 建立文件之后的默认权限，为777减去umask值 例如：-目录默认最大权限为777 umask值022–rwxrwxrwx 减去 —–w–w-等于 -rwxr-xr-x修改umask值 临时修改-umask 0002 永久修改-vi /etc/profile","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之基本权限","slug":"Linux/权限管理之基本权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之基本权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"Linux文件权限的设定","slug":"Linux/BasicAuthority/Linux文件权限的设定","date":"2019-02-04T15:27:15.000Z","updated":"2019-02-04T16:53:23.630Z","comments":true,"path":"passages/Linux/BasicAuthority/Linux文件权限的设定/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/BasicAuthority/Linux文件权限的设定/","excerpt":"","text":"###-rw-r–r–-：文件类型（-文件 d目录 l软链接文件）rw- r– r–u所有者 g所属组 o其他人r读 w写 x执行 chmod命令 chmod [选项] 模式 文件名选项：-R：递归模式：[ugoa] [+-=] [rwx][mode=421]修改权限的方式 chmod u+x cangls.av chmod g+w,o+w furong.av chmod a=rwx fengjie.av权限的数字表示r — 4w — 2x — 1rwxr-xr-x7 5 5权限对文件的作用 r：读取文件内容（cat more head tail） w：编辑、新增、修改文件内容（vi echo）-但是不包含删除文件 x：可执行权限对目录的作用 r：可以查询目录下的文件名（ls） w：具有修改目录结构的权限。如新建文件和目录，删除此目录下文件和目录，重命名此目录下文件和目录，剪切（touch rm mv cp） x：可以进入目录（cd）修改文件的所有者 chown 用户名 文件名-例如：chown ds fengjie.av修改文件的所属组 chgrp 组名 文件名-例如： chgrp group1 fengj.av让用户对文件及目录拥有一定的权限 要求：-拥有一个av目录-让加藤老师拥有所有的权限-让本课程学院由查看的权限-其他所有人不许查看这个目录 分配文件基本权限时的核心原则：在最小权限情况下能够实现要求即可","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"权限管理之基本权限","slug":"Linux/权限管理之基本权限","permalink":"http://kwin1113.github.io/categories/Linux/权限管理之基本权限/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"软件安装","slug":"Linux/SoftwareManage/软件安装","date":"2019-02-04T15:24:11.000Z","updated":"2019-02-04T16:54:30.278Z","comments":true,"path":"passages/Linux/SoftwareManage/软件安装/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SoftwareManage/软件安装/","excerpt":"","text":"RPM包命名原则 httpd-2.2.15-15.el6.centos.1.i686.rpm-httpd 软件包名-2.2.15 软件版本-15 软件发布次数-el6.centos 适合的Linux平台-i686 适合的硬件平台-rpm rpm包扩展名RPM包依赖性 树形依赖：a-&gt;b-&gt;c 环形依赖：a-&gt;b-&gt;c-&gt;a 模块依赖：模块依赖，查询网站：www.rpmfind.net包全名和包名 包全名：操作的包是没有安装的软件报时，使用包全名。而且要注意路径。 包名：操作已经安装的软件包时，使用包名，是搜索/var/lib/rpm/中的数据库RPM操作RPM安装 rpm -ivh 包全名-i（install）：安装-v（verbose）：显示详细信息-h（hash）：显示进度—nodeps：不检测依赖性RPM包升级 rpm -Uvh 包全名-U（upgrade）：升级RPM包卸载 rpm -e 包全名-e（erase）：卸载—nodeps：不检查依赖性RPM包查询RPM包默认安装位置 路径 内容 /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 1. 查询是否安装 rpm -q 包名#查询包是否安装-q（query）：查询 rpm -qa#查询所有已经安装的rpm包-a（all）：所有2. 查询软件包详细信息 rpm -qi 包名-i（information）：查询软件信息-p（package）：查询未安装包信息3. 查询系统文件属于哪个包 rpm -qf 系统文件名-f（file）：查询系统文件属于哪个软件包4. 查询软件包的依赖性 rpm -qR 包名-R（requires）：查询软件包的依赖性-p（package）：查询未安装包信息RPM包校验 rpm -V 包名-V（verify）：校验指定RPM包中的文件 验证内容中的8个信息的具体内容如下： S：文件大小是否改变 M：文件的类型或文件的权限（rwx）是否被改变 5：文件MD5校验和是否改变（可以看成文件内容是否改变） D：设备的主从代码是否改变 L：文件路径是否改变 U：文件的属主（所有者）是否改变 G：文件的属组是否改变 T：文件的修改时间是否改变 文件类型： c（config file）：配置文件 d（documentation）：普通文档 g（ghost file）：“鬼”文件，很少见，该文件不应该被这个RPM包包含 L（license file）：授权文件 r（read me）：描述文件RPM包中文件提取 rpm2cpio 包全名 | cpio -idv .文件绝对路径-rpm2cpio#将rpm包转换为cpio格式的命令-cpio#是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 cpio &lt; [文件|设备]-i：copy-in模式，还原-d：还原时自动新建目录-v：显示还原过程yumyum源文件 vim /etc/yum.repos.d/CentOS-Base.repo-[base]：容器名称，一定要放在[]中-name：容器说明，可以自己随便写-mirrorlist：镜像站点，可以注释掉-baseurl：yum原服务器的地址。默认是CentOS官方的yum源服务器，可以使用，可以改成阿里云等yum源地址-enable：此容器是否生效，如果不写或写成enable=1都是生效，enable=0就是不生效-gpgcheck：如果是1是指RPM的数字证书生效，如果是0则不生效-gpgkey：数字证书的公钥文件保存位置。不用修改将yum源修改为光盘1. 挂载光盘 mkdir /mnt/cdrom#建立挂载点 mount /dev/cdrom /mnt/cdrom/#挂载光盘2. 使网络yum源失效 cd /etc/yum.repos.d/#进入yum源目录 mv CentOS-Base.repo CentOS-Base.repo.bak#修改yum源文件后缀名，使其失效3. 使光盘yum源生效 vim CentOS-Media.repo 常用yum命令1）查询 yum list#查询所有可用软件包列表 yum search 关键字#搜索服务器上所有和关键字相关的包2）安装 yum -y install 包名-install：安装-y：自动回答yes3）升级 yum -y update 包名-update：升级-y：自动回答yes4）卸载 yum -y remove 包名-remove：卸载-y：自动回答yes服务器使用最小化安装，用什么软件安装什么，尽量不卸载yum软件组管理命令 yum grouplist#列出所有可用的软件组名 yum groupinstall 软件组名#安装指定软件组，组名可以由grouplist查询出来 yum groupremove 软件组名#卸载指定软件组源码包区别 安装前的区别：概念上的区别 安装后的区别：安装位置不同源码包安装位置 安装在指定位置当中，一般是/usr/local/软件名/安装位置不同带来的影响 RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：/etc/rc.d/init.d/httpd startservice httpd start 而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如：/usr/local/apache2/bin/apachectl start安装源码包1. 安装准备 安装C语言编译器 下载源码包2. 安装注意事项 源代码保存位置：/usr/local/src/ 软件安装位置：/usr/local/ 如何确定安装过程报错：-安装过程停止-并出现error、warning或no的提示3. 源码包安装过程 下载源码包 解压缩下载的源码包 进入解压缩目录 ./configure 软件配置与检查-定义需要的功能选项-检测系统环境是否符合安装要求-把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑 make 编译-make clean make install 编译安装4. 源码包的卸载 不需要卸载命令，直接删除安装目录即可。脚本安装centos.sh脚本分析 所谓的一键安装包，实际上还是安装的源码包和RPM包，只是把安装过程写成了脚本，便于初学者安装。 优点：简单、快速、方便 缺点：-不能定义安装软件的版本-不能定义所需要的软件功能-源码包的优势丧失准备工作 保证yum源正常使用 关闭SELinux和防火墙安装步骤参考lnmp.org","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"软件管理","slug":"Linux/软件管理","permalink":"http://kwin1113.github.io/categories/Linux/软件管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"软件包分类","slug":"Linux/SoftwareManage/软件包分类","date":"2019-02-04T15:23:33.000Z","updated":"2019-02-04T16:54:27.073Z","comments":true,"path":"passages/Linux/SoftwareManage/软件包分类/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SoftwareManage/软件包分类/","excerpt":"","text":"软件包分类 源码包-脚本安装包 二进制包 源码包的缺点 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错新手很难解决RPM包二进制包的优点： 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 安装速度比源码包安装快的多二进制包的缺点： 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性脚本安装包 所谓的脚本安装包，就是把复杂的软件包安装过程写成了程序脚本，初学者可以执行程序脚本实现一键安装。但实际安装还是源码包和二进制包 优点：安装简单、快捷 缺点：完全丧失了自定义性","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"软件管理","slug":"Linux/软件管理","permalink":"http://kwin1113.github.io/categories/Linux/软件管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"远程登陆","slug":"Linux/NetworkManage/远程登陆","date":"2019-02-04T15:21:57.000Z","updated":"2019-02-04T16:54:00.617Z","comments":true,"path":"passages/Linux/NetworkManage/远程登陆/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/NetworkManage/远程登陆/","excerpt":"","text":"远程登陆对称加密算法 采用钥密码系统的加密算法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。非对称加密算法 非对称加密算法（asymmetric cryptographic algorithm）又名“公开密钥加密算法”，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。SSH安全外壳协议SSH命令 ssh 用户名@ip#远程管理指定Linux服务器 scp [-r] 用户名@ip:文件路径 本地路径#下载文件 scp [-r] 本地文件 用户名@ip:上传路径#上传文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"网络管理","slug":"Linux/网络管理","permalink":"http://kwin1113.github.io/categories/Linux/网络管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"Linux网络命令","slug":"Linux/NetworkManage/Linux网络命令","date":"2019-02-04T15:21:40.000Z","updated":"2019-02-04T16:53:49.448Z","comments":true,"path":"passages/Linux/NetworkManage/Linux网络命令/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/NetworkManage/Linux网络命令/","excerpt":"","text":"1. ifconfig命令ifconfig命令：查看与配置网络状态命令 2. 关闭与启动网卡 ifdown 网卡设备名#禁用该网卡设备 ifup 网卡设备名#启用该网卡设备3. 查询网络状态 netstat 选项-t：列出TCP协议端口-u：列出UDP协议端口-n：不适用域名与服务名，而使用IP地址和端口号-l：仅列出在监听状态网络服务-a：列出所有的网络连接 netstat -rn-r：列出路由器列表，功能和route命令一致4. route命令 route -n#查看路由列表（可以看到网关） route add default gw 192.168.1.1#临时设定网关5. 域名解析命令 nslookup [主机名或IP]#进行域名与IP地址解析 nslookup server #查看本机DNS服务器1. ping命令 ping [选项] ip或域名#探测指定IP或域名的网络状况 选项：&emsp;&emsp;-c 次数：指定ping报的次数 2. telnet命令 telnet [域名或IP] [端口]#远程管理与端口探测命令 telnet 192.168.0.252 80ICMP是（Internet Control Message Protocol）Internet控制报文协议。3. traceroute traceroute [选项] IP或域名#路由跟踪命令选项：&emsp;&emsp;-n：使用IP，不使用域名，速度更快4. wget命令 wget http://soft.vpser.net/lnmp/lnmp1.1-full.tar.gz#下载命令5. tcpdump命令 tcpdump -i eth0 -nnX port 21-i：指定网卡接口-nn：将数据包中的域名与服务器转为IP和端口-X：以十六进制和ASCII码显示数据包内容port：指定监听的端口","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"网络管理","slug":"Linux/网络管理","permalink":"http://kwin1113.github.io/categories/Linux/网络管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"Linux网络配置","slug":"Linux/NetworkManage/Linux网络配置","date":"2019-02-04T15:21:19.000Z","updated":"2019-02-04T16:53:53.208Z","comments":true,"path":"passages/Linux/NetworkManage/Linux网络配置/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/NetworkManage/Linux网络配置/","excerpt":"","text":"Linux配置IP地址的方法（1）ifconfig命令临时配置IP地址（2）setup工具永久配置IP地址（3）修改网络配置文件（4）图形界面配置IP地址 ifconfig命令 ifconfig命令：查看与配置网络状态命令 ifconfig eth0 192.168.0.200 netmask 255.255.255.0#临时设置eth0网卡的IP地址与子网掩码1. 网卡信息文件2. 主机名文件 vim /etc/sysconfig/network hostname [主机名]#查看与临时设置主机名命令3. DNS配置文件 vim /etc/resolv.confLinux虚拟机网络参数配置1. 配置LinuxIP地址 setup#修改并配置IP地址2. 启动网卡 vim /etc/sysconfig/network-scripts/ifcfg-eth0把 ONBOOT=no改为 ONBOOT=yes service network restart#重启网络服务3. 修改UUID1）vim /etc/sysconfig/network-scripts/ifcfg-eth0#删除MAC地址行2）rm -rf /etc/udev/rules.d/70-persistent-net.rules#删除网卡和MAC地址绑定文件3）重启动系统4. 设置虚拟机网络连接方式5. 修改桥接网卡","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"网络管理","slug":"Linux/网络管理","permalink":"http://kwin1113.github.io/categories/Linux/网络管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"网络基础","slug":"Linux/NetworkManage/网络基础","date":"2019-02-04T15:20:39.000Z","updated":"2019-02-04T16:53:56.746Z","comments":true,"path":"passages/Linux/NetworkManage/网络基础/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/NetworkManage/网络基础/","excerpt":"","text":"iso/osi七层模型 层 作用 应用层 用户接口 表示层 数据的表现形式、特定功能的实现如加密 会话层 对应用会话的管理、同步 传输层 可靠与不可靠的传输、传输前的错误检测、流控 网络层 提供逻辑地址、选路 数据链路层 成帧、用MAC地址访问媒介、错误检测与修正 物理层 设备之间的比特流的传输、物理接口、电气特性等 TCP/IP四层模型 TCP/IP模型与OSI模型的对应 网络接口层 网络接口层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互联的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。网际互联层 网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。该层由三个主要协议：网际协议（IP）、互联网管理协议（IGMP）和互联网控制报文协议（ICMP）。传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送即数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP）。TCP/IP三次握手应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等。数据封装过程TCP/IP模型与OSI模型的比较 共同点（1）OSI参考模型和TCP/IP参考模型都采用了层次结构的概念。（2）都能够提供面向连接和无连接两种通信服务机制。 不同点（1）前者是七层模型，后者是四层模型。（2）对可靠性要求不同（后者更高）。（3）OSI模型是在协议开发前设计的，具有通用性。TCP/IP是先有协议集然后建立模型，不适用于非TCP/IP网络。（4）实际市场应用不同（OSI模型只是理论上的模型，并没有成熟的产品，而TCP/IP已经成为“实际上的国际标准”）IP地址详解IP包头IP地址00000000.00000000.00000000.0000000011111111.11111111.11111111.11111111 0.0.0.0255.255.255.255 IP地址分类 网络类别 最大网络数 IP地址范围 最大主机数 私有IP地址范围 A 126（2^7-2） 1.0.0.0–126.255.255.255 2^24-2 10.0.0.0–10.255.255.255 B 16384（2^14） 128.0.0.0–191.255.255.255 2^16-2 172.16.0.0–172.31.255.255 C 2097152（2^21） 192.0.0.0–223.255.255.255 2^8-2 192.168.0.0–192.168.255.255 子网掩码的使用 变长子网掩码及子网规划 TCP协议包头 UDP协议包头 常见端口号FTP（文件传输协议）：端口号 20 21SSH（安全shell协议）：端口号 22telnet（远程登陆协议）：端口号 23DNS（域名系统）：端口号 53http（超文本传输协议）：端口号 80SMTP（简单邮件传输协议）：端口号 25POP3（邮局协议3代）：端口号 110 Linux查看本机启用的端口 netstat -an选项：&emsp;&emsp;-a：查看所有链接和监听端口&emsp;&emsp;-n：显示IP地址和端口号，而不显示域名和服务名名称解析概述 在互联网中，通过IP地址来进行通信。 IP地址用数字表示，记忆起来困难。 人对域名更加敏感。 DNS为Domain Name System的缩写也就是域名系统的缩写，也称作名称解析 从Hosts文件到DNS 早期Hosts文件解析域名&emsp;&emsp;- 名称解析效能下降&emsp;&emsp;- 主机维护困难 DNS服务&emsp;&emsp;- 层次性&emsp;&emsp;- 分布式DNS服务的作用 将域名解析为IP地址-客户机向DNS服务器发送域名查询请求-DNS服务器告知客户机Web服务器的IP地址-客户机与Web服务器通信域名空间结构 根域 顶级域-组织域-国家或地区域 二级域 主机名DNS查询过程DNS查询类型 从查询方式上分 – 递归查询 &emsp;&emsp;- 要么做出查询成功响应，要么做出查询失败的响应。一般客户机和服务器之间属递归查询，即当客户机向DNS服务器发出请求后，若DNS服务器本身不能解析，则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机。 – 迭代查询 &emsp;&emsp;- 服务器收到一次迭代查询回复一次结果，这个结果不一定是目标IP与域名的映射关系，也可以是其他DNS服务器的地址。 从查询内容上分– 正向查询由域名查找IP地址– 反向查询由IP地址查找域名网关作用 网关（Gateway）又称网间连接器、协议转换器。 网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。 网关既可以用于广域网互连，亦可以用于局域网互连。 网关是一种充当转换重任的服务器或路由器。网关示意图","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"网络管理","slug":"Linux/网络管理","permalink":"http://kwin1113.github.io/categories/Linux/网络管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"系统定时任务","slug":"Linux/SysManage/系统定时任务","date":"2019-02-04T15:19:42.000Z","updated":"2019-02-04T16:54:57.108Z","comments":true,"path":"passages/Linux/SysManage/系统定时任务/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/系统定时任务/","excerpt":"","text":"系统定时任务 at一次性定时任务 crontab循环定时任务 系统的crontab设置 anacron配置 at一次执行系统定时任务1. 确定at安装 chkconfig –list | grep atd#at服务是否安装 service atd start#at服务的启动2. at的访问控制 如果系统中有/etc/at.allow文件，那么只有写入/etc/at.allow文件（白名单）中的用户可以使用at命令（/etc/at.deny文件会被忽略） 如果系统中没有/etc/at.allow文件，只有/etc/at.deny文件，那么写入/etc/at.deny文件（黑名单）中的用户不能使用at命令。对root不起作用。 如果系统中这两个文件都不存在，那么只有root用户可以使用at命令3. at命令 at [选项] 时间 选项：&emsp;&emsp;-m：当at工作完成后，无论是否命令有输出，都用email通知执行at命令的用户&emsp;&emsp;-c 工作号：显示该at工作的实际内容 时间：&emsp;&emsp;-HH:MM &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;例如：02：30&emsp;&emsp;-HH:MM YYYY-MM-DD &emsp;&emsp; &emsp;&emsp; &emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp; &emsp;&emsp; 例如：02：30 2013-07-25&emsp;&emsp;-HH:MM[am|pm] [month] [date] &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; &emsp;&emsp;例如：02：30 July 25&emsp;&emsp;-HH:MM[am|pm] + [minutes|hours|days|weeks] &emsp;&emsp; 例如：now + 5 minutes eg. at 02：00 2013-07-25#在指定的时间重启at&gt; /bin/syncat&gt; /sbin/shutdown -r now其他at管理命令 atq#查询当前服务器上的at工作 atrm [工作号]#删除指定的at任务 crontab系统定时任务crond服务管理与访问控制 service crond restart chkconfig crond on访问控制 如果系统中有/etc/cron.allow文件，那么只有写入/etc/cron.allow文件（白名单）中的用户可以使用crontab命令（/etc/cron.deny文件会被忽略） 如果系统中没有/etc/cron.allow文件，只有/etc/cron.deny文件，那么写入/etc/cron.deny文件（黑名单）中的用户不能使用crontab命令。用户的crontab设置 crontab [选项] 选项：&emsp;&emsp;-e：编辑crontab定时任务&emsp;&emsp;-l：查询crontab任务&emsp;&emsp;-r：删除当前用户所有的crontab任务 crontab -e#进入crontab编辑界面。会打开vim编辑你的工作。 / * 执行的任务 项目 含义 范围 第一个“*” 一小时当中的第几分钟 0-59 第二个“*” 一天当中的第几小时 0-23 第三个“*” 一个月当中的第几天 1-31 第四个“*” 一年当中的低级月 1-12 第五个“*” 一周当中的星期几 0-7（0和7都代表星期日） 特殊符号 含义 * 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思 ， 代表不连续的时间。比如“0 8，12，16 * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 - 代表连续的时间范围。比如“0 5 1-6 命令”，代表在周一到周六的凌晨5点0分执行命令 */n 代表每隔多久执行一次。比如“/10 * 命令”，代表每隔10分钟就执行一遍命令 常用命令 crontab -l#查看root用户的crontab任务 crontab -r#删除root用户所有的定时任务 crontab注意事项 六个选项都不能为空，必须填写。如果不确定使用“*”代表 crontab定时任务，最小有效时间是分钟，最大时间范围是年。像2018年某时执行，3点30分30秒这样的事件都不能识别。 在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天作为单位，非常容易让管理员混乱。 在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。系统的定时任务 “crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可是有些定时任务需要系统执行，这是我们就需要编辑/etc/crontab这个配置文件了CentOS 5 中的配置文件CentOS 6 中的配置文件 执行系统的定时任务的方法 手工执行定时任务 系统定时任务&emsp;&emsp;-第一种是把需要定时执行的脚本复制到/etc/cron.{daily,weekly,monthly}目录中的任意一个&emsp;&emsp;-第二种是修改/etc/crontab配置文件 anacron系统定时任务简介 anacron是用来保证在系统关机的时候错过的定时任务，可以在系统开机之后再执行。anacron检测周期 anncron会使用一天，一周，一个月作为检测周期 在系统的/var/spool/anacron/目录中存在cron.{daily,weekly,monthly}文件，用于记录上次执行cron的时间 和当前时间做比较，如果两个时间的插值超过了anacron的指定时间差值，证明有cron任务被漏执行。CentOS 6.x 的区别 在老的CentOS版本中，/etc/cron.{daily,weekly,monthly}这些目录既会被cron调用，也会被anacron调用，容易重复执行。 在CentOS 6.x中则只会被anacron调用，避免了重复执行。 在CentOS 6.x中，anacron不再是服务，而是系统命令。anacron配置文件 vi /etc/anacrontab-RANDOM_DELAY=45#最大随机延迟-START_HOURS_RANGE=3-22-1 5 cron.daily nice run-parts /etc/cron.daily-7 25 cron.weekly nice run-parts /etc/cron.weekly-@monthly 45 cron.monthly nice run-parts /etc/cron.monthly#天数 强制延迟（分） 工作名称 实际执行的命令cron.daily工作来说明执行过程 首先读取/var/spool/anacron/cron.daily中的上一次anacron执行的时间 和当前时间比较，如果两个时间的插值超过一天，就执行cron.daily工作 执行这个工作只能在03：00-22：00之间 执行工作时强制延迟时间为5分钟，再随机延迟0-45分钟时间 使用nice命令指定默认优先级，使用run-parts脚本执行/etc/cron.daily目录中的所有可执行文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"系统资源查看","slug":"Linux/SysManage/系统资源查看","date":"2019-02-04T15:19:11.000Z","updated":"2019-02-04T16:54:59.587Z","comments":true,"path":"passages/Linux/SysManage/系统资源查看/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/系统资源查看/","excerpt":"","text":"1. vmstat命令监控系统资源 vmstat [刷新延时 刷新次数] eg.&emsp;&emsp;- vmstat 1 3 procs：进程信息字段：&emsp;&emsp;- r：等待运行的进程数，数量越大，系统越繁忙。&emsp;&emsp;- b：不可被唤醒的进程数量，数量越大，系统越繁忙。 memory：内存信息字段：&emsp;&emsp;- swpd：虚拟内存的使用情况，单位KB&emsp;&emsp;- fress：空闲的内存容量，单位KB&emsp;&emsp;- buff：缓冲的内存容量，单位KB&emsp;&emsp;-cache：缓存的内存容量，单位KB缓存和缓冲的区别简单来说缓存（cache）是用来加速数据从硬盘中”读取“的，而缓冲（buffer）是用来加速数据“写入”硬盘的。 swap：交换分区的信息字段：&emsp;&emsp;- si：从磁盘中交换到内存中数据的数量，单位KB&emsp;&emsp;- so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。 io：磁盘读写信息字段：&emsp;&emsp;- bi：从块设备读入数据的总量，单位是块。&emsp;&emsp;- bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I/O越繁忙。 system：系统信息字段&emsp;&emsp;- in：每秒被中断的进程次数。&emsp;&emsp;- cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。 CPU：CPU信息字段：&emsp;&emsp;- us：非内核进程消耗CPU运算时间的百分比。&emsp;&emsp;- sy：内核进程消耗CPU运算时间的百分比。&emsp;&emsp;- id：空闲CPU的百分比。&emsp;&emsp;- wa：等待I/O所消耗的CPU百分比。&emsp;&emsp;- st：被虚拟机所盗用的CPU百分比。 2. dmesg开机时内核检测信息 dmesg dmesg | grep CPU 3. free命令查看内存使用状态 free [-b|-k|-m|-g] 选项：&emsp;&emsp;-b：以字节为单位显示&emsp;&emsp;-k：以KB为单位显示，默认就是以KB为单位显示&emsp;&emsp;-m：以MB为单位显示&emsp;&emsp;-g：以GB为单位显示 第一行：total是总内存数，used是已经使用的内存数，free是空闲的内存数，shared是多个进程共享的内存总数，buffers是缓冲内存数，cached是缓存内存数。默认单位是KB。 第二行：-/buffers/cache的内存数，相当于第一行的used-buffers-cached。+/buffers/cache的内存数，相当于第一行的free+buffers+cached。 第三行：total是swap的总数；used是已经使用的swap数，free是空闲的swap数。默认单位是KB 4. 查看CPU信息 cat /proc/cpuinfo 5. uptime命令 uptime #显示系统的启动时间和平均负载，也就是top命令的第一行。w命令也可以看到这个数据。 6. 查看系统与内核相关信息 uname [选项] 选项：&emsp;&emsp;-a：查看系统所有相关信息；&emsp;&emsp;-r：查看内核版本；&emsp;&emsp;-s：查看内核名称。判断当前系统的位数 file /bin/ls查询当前Linux系统的发行版本 lsb_release -a 7. 列出进程打开或使用的文件信息 lsof [选项]#列出进程调用或打开的文件的信息 选项：&emsp;&emsp;-c 字符串：只列出以字符串开头的进程打开的文件&emsp;&emsp;-u 用户名：只列出某个用户的进程打开的文件&emsp;&emsp;-p pid：列出某个PID进程打开的文件 lsof | more&emsp;&emsp;#查询系统中所有进程调用的文件 lsof /sbin/init&emsp;&emsp;#查询某个文件被哪个进程调用 lsof -c httpd&emsp;&emsp;#查看httpd进程调用了哪些文件 lsof -u root&emsp;&emsp;#按照用户名，查询某用户的进程调用的文件名","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"工作管理","slug":"Linux/SysManage/工作管理","date":"2019-02-04T15:18:55.000Z","updated":"2019-02-04T16:54:48.081Z","comments":true,"path":"passages/Linux/SysManage/工作管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/工作管理/","excerpt":"","text":"工作管理简介 工作管理是指在单个登陆终端中（也就是登陆shell界面中）同时管理多个工作的行为。注意事项 当前的登陆终端，只能管理当前终端的工作，而不能管理其他登陆终端的工作 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行1. 把进程放入后台 &amp; eg1.&emsp;&emsp;tar -zcf etc.tar.gz /etc &amp; ctrl+z eg2.&emsp;&emsp;按下ctrl+z快捷键，放在后台暂停2. 查看后台的工作 jobs [-l] 选项：&emsp;&emsp;-l:显示工作的PID 注：”+“号代表最近一个放入后台的工作，也就是工作恢复时，默认恢复的工作。”-“号代表倒数第二个放入后台的工作 3. 将后台暂停的工作恢复到前台执行 fg %工作号 参数：&emsp;&emsp;-%工作号：%号可以省略，但是注意工作号和PID的区别4. 把后台暂停的工作恢复到后台执行 bg %工作号注1：后台恢复执行的命令，是不能和前台有交互的，否则不能恢复到后台执行注2：把命令放入后台，只能在当前登陆终端执行。一旦退出或关闭终端，后台程序就会停止。后台命令脱离登陆终端执行的方法 第一种方法是把需要后台执行的命令加入/etc/rc.local文件 第二种方法是使用系统定时任务，让系统在指定时间执行某个后台任务 第三种方法是使用nohup命令nohup命令 nohup [命令] &amp;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"进程管理","slug":"Linux/SysManage/进程管理","date":"2019-02-04T15:17:41.000Z","updated":"2019-02-04T16:55:03.309Z","comments":true,"path":"passages/Linux/SysManage/进程管理/","link":"","permalink":"http://kwin1113.github.io/passages/Linux/SysManage/进程管理/","excerpt":"","text":"1. 进程简介进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。 2. 进程管理的作用 判断服务器健康状态 查看系统中所有进程 杀死进程3. 进程管理查看所有进程ps命令 ps aux#查看系统中所有进程，使用BSD操作系统格式 ps -le#查看系统中所有进程，使用Linux标准命令格式 选项 -a：显示一个终端的所有进程，除了会话引线 -u：显示进程的归属用户及内存的使用情况 -x：显示没有控制终端的进程 -l：长格式显示。显示更加详细的信息 -e：显示所有进程，和-A作用一致ps命令的输出 USER：该进程是由哪个用户产生的； PID：进程的ID号； %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源； %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源； VSZ：该进程占用虚拟内存的大小，单位KB； RSS：该进程占用实际物理内存的大小，单位KB； TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端。 STAT：进程状态。常见的状态有：&emsp;&emsp;R：运行&emsp;&emsp;S：睡眠&emsp;&emsp;T：停止状态&emsp;&emsp;s：包含子进程&emsp;&emsp;+：位于后台 START：该进程的启动时间 TIME：该进程占用CPU的运算时间，注意不是系统时间 COMMAND：产生此进程的命令名查看系统健康状态top命令 top [选项]&emsp;&emsp;-d秒数：指定top命令每隔几秒更新。默认3秒。&emsp;&emsp;-b：使用批处理模式输出。一般和”-n”选项合用。&emsp;&emsp;-n次数：指定top命令执行的次数。一般和”-b”选项合用。 在top命令的交互模式当中可以执行的命令：&emsp;&emsp;?或h：显示交互模式的帮助&emsp;&emsp;P：以CPU使用率排序，默认就是此项&emsp;&emsp;M：以内存的使用率排序&emsp;&emsp;N：以PID排序&emsp;&emsp;q：退出top使用top查看所有进程 top -b -n 1 &gt; /root/top.log杀死进程1. kill命令 kill -l#查看可用的进程信号 信号代号 信号名称 说明 1 SIGHUP 该信号让进程立即关闭，然后重新读取配置文件之后重启。 2 SIGINT 程序终止信号，用于终止前台程序。相当于输出ctrl+c快捷键。 8 SIGFPE 在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误。 9 SIGKILL 用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。 14 SIGALRM 时钟定时信号，计算的是实际的时间或时钟时间。alarm函数使用该信号。 15 SIGTERM 正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SGKILL信号，也就是信号9。 18 SIGCONT 该信号可以让暂停的进程恢复执行，本信号不能被阻断。 19 SIGSTOP 该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。 2. killall命令 killall [选项] [信号] 进程名#按照进程名杀死进程 选项：&emsp;&emsp;-i：交互式，询问是否要杀死某个进程&emsp;&emsp;-I：忽略进程名的大小写3. pkill命令 pkill [选项] [信号] 进程名#按照进程名终止进程 选项：&emsp;&emsp;-t 终端号： 按照终端号踢出用户按照终端号踢出用户w命令 w#使用w命令查询本机已经登陆的用户 pkill -9 -t pts/1#强制杀死从pts/1虚拟终端登陆的进程 进程优先级简介 Linux操作系统是一个多用户、多任务的操作系统，Linux系统中通知运行着非常多的进程。但是CPU在同一个时钟周期内只能运算一个指令。进程优先级决定了每个进程处理的先后顺序。 PRI代表Priority，NI代表Nice。这两个值都是优先级，数字越小代表该进程优先级越高。修改NI值时有几个注意事项 NI的值的范围是-20到19； 普通用户调整NI值的范围是0到19，而且只能调整自己的进程； 普通用户只能调高NI值，而不能降低，如原本NI值为0，则只能调整为大于0； root用户才能设定进程NI值为负值，而且可以调整任何用户的进程； PRI（最终值）=PRI（原始值）+ NI； 用户只能修改NI的值，不能直接修改PRI。nice命令 nice [选项] 命令#nice命令可以给新执行的命令直接赋予NI值，但是不能修改已经存在的进程的NI值 选项：&emsp;&emsp;-n NI值：给命令赋予NI值。 eg.&emsp;&emsp;nice -n -5 service httpd startrenice命令 renice [优先级] PID#renice命令是修改已经存在进程的NI值的命令 eg.&emsp;&emsp;renice -10 2125","categories":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/categories/Linux/"},{"name":"系统管理","slug":"Linux/系统管理","permalink":"http://kwin1113.github.io/categories/Linux/系统管理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://kwin1113.github.io/tags/Linux/"}]},{"title":"Spring单元测试","slug":"Frames/SSM/Spring单元测试","date":"2019-02-04T15:15:48.000Z","updated":"2019-02-04T16:53:07.634Z","comments":true,"path":"passages/Frames/SSM/Spring单元测试/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SSM/Spring单元测试/","excerpt":"","text":"1234567891011121314@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = &#123;\"classpath*:applicationContext*.xml\"&#125;)public class DepartmentTest &#123; @Autowired DepartmentMapper departmentMapper; @Test public void testDepartment() &#123; departmentMapper.insert(new Department(1, \"开发部\")); departmentMapper.insert(new Department(2, \"测试部\")); &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SSM","slug":"Frames/SSM","permalink":"http://kwin1113.github.io/categories/Frames/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://kwin1113.github.io/tags/SSM/"}]},{"title":"补充","slug":"Frames/SSM/补充","date":"2019-02-04T15:15:07.000Z","updated":"2019-02-04T16:53:11.856Z","comments":true,"path":"passages/Frames/SSM/补充/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SSM/补充/","excerpt":"","text":"web.xml12345678910111213141516171819202122232425262728293031&lt;!--字符编码过滤器 一定要放在所有过滤器之前--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!--使用Rest风格的URL 将页面普通的post请求转为指定的delete或者put请求--&gt;&lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; mybatis.xml1234&lt;!--驼峰命名规则--&gt;&lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;&lt;/settings&gt; mybatis逆向工程生成java实体类mbg.xml (src/main/resources)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt; &lt;context id=\"context\" targetRuntime=\"MyBatis3\"&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;property name=\"suppressDate\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库连接信息--&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud\" userId=\"root\" password=\"123456\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!--指定javabean生成的为知--&gt; &lt;javaModelGenerator targetPackage=\"com.test.crud.bean\" targetProject=\".\\src\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定sql映射文件生成的位置--&gt; &lt;sqlMapGenerator targetPackage=\"\\mapper\" targetProject=\".\\src\\resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!--指定dao接口生成的位置，mapper接口--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.test.crud.dao\" targetProject=\".\\src\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!--table指定每个表的生成策略--&gt; &lt;table tableName=\"tbl_emp\" domainObjectName=\"Employee\"&gt;&lt;/table&gt; &lt;table tableName=\"tbl_dept\" domainObjectName=\"Department\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; pom.xml123456789101112131415161718192021222324252627282930313233343536&lt;plugins&gt; &lt;plugin&gt; &lt;!--Mybatis-generator插件,用于自动生成Mapper和POJO--&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;!--配置文件的位置--&gt; &lt;configurationFile&gt;src/main/resources/mbg.xml&lt;/configurationFile&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt; &lt;phase&gt;deploy&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.13&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt;&lt;/plugins&gt; 点击idea右侧maven-plugins-mybatis-generator执行 springjunit测试123456789101112131415161718192021222324252627282930313233343536373839404142434445/** 测试dao层的工作* 推荐spring的项目就可以使用spring的单元测试，可以自动注入我们需要的组件* 1、导入springtest模块* 2、@ContextConfiguration指定spring配置文件的位置* 3、直接@Autowired要使用的组件即可* */@ContextConfiguration(locations = &#123;\"classpath:applicationContext.xml\"&#125;)@RunWith(SpringJUnit4ClassRunner.class)public class DepartmentMapperTest &#123; @Autowired DepartmentMapper departmentMapper; @Autowired EmployeeMapper employeeMapper; @Autowired SqlSession sqlSession; @Test public void test() &#123; //1、创建springioc容器// ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2、从容器中获取mapper// DepartmentMapper bean = context.getBean(DepartmentMapper.class); System.out.println(departmentMapper);// 1、插入几个部门// departmentMapper.insertSelective(new Department(null, \"开发部\"));// departmentMapper.insertSelective(new Department(null, \"测试部\"));// 2、插入员工 employeeMapper.insertSelective(new Employee(null, \"Kwin\", \"M\", \"Kwin@Kwin.com\", 1));// 3、批量插入多个员工：批量，使用可以执行批量操作的sqlSession EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class); for(int i = 0; i &lt; 1000; i++)&#123; String uuid = UUID.randomUUID().toString().substring(0, 5); mapper.insertSelective(new Employee(null, uuid, \"M\", uuid+\"@kwin.com\", 1)); &#125; &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SSM","slug":"Frames/SSM","permalink":"http://kwin1113.github.io/categories/Frames/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://kwin1113.github.io/tags/SSM/"}]},{"title":"整合springmvc + spring + mybatis","slug":"Frames/SSM/整合springmvc-spring-mybatis","date":"2019-02-04T15:14:45.000Z","updated":"2019-02-04T16:53:09.830Z","comments":true,"path":"passages/Frames/SSM/整合springmvc-spring-mybatis/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SSM/整合springmvc-spring-mybatis/","excerpt":"","text":"1、导入相关jar包2、编写配置文件web.xml—配置spring 配置springmvc1234567891011121314151617181920212223&lt;!--配置spring--&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!--配置springmvc--&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; springmvc-servlet.xml—-springmvc—使用注解扫描 如果需要json或其他处理需填写相关配置1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"com.study\"/&gt;&lt;/beans&gt; applicationContext.xml—-spring123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!--配置dataSource--&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt; &lt;/bean&gt; &lt;!--配置SqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;!--&lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt;--&gt; &lt;/bean&gt; &lt;!--配置声明式事务--&gt; &lt;!--事务管理器--&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"save\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"get\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.study.ServiceImpl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt; &lt;context:component-scan base-package=\"com.study\"/&gt;&lt;/beans&gt; mybatis-config.xml—–mybatis123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"com.study.entity\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=\"com/study/entity/user-mapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3、编码User.java12345678910111213141516171819202122232425262728293031323334353637383940package com.study.entity;public class User &#123; private int id; private String name; private String pwd; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '&#125;'; &#125;&#125; user-mapper.xml1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.study.entity.User\"&gt; &lt;select id=\"select\" resultType=\"User\"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; UserDao.java123public interface UserDao &#123; public List&lt;User&gt; select();&#125; UserDaoImpl.java1234567891011121314@Repository(\"userDao\")public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Autowired @Override public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; super.setSqlSessionFactory(sqlSessionFactory); &#125; @Override public List&lt;User&gt; select() &#123; return getSqlSession().selectList(\"com.study.entity.User.select\"); &#125;&#125; Service.java123public interface UserService &#123; List&lt;User&gt; select();&#125; ServiceImpl.java1234567891011121314@Service(\"userService\")public class UserServiceImpl implements UserService &#123; private UserDao userDao; @Autowired public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public List&lt;User&gt; select() &#123; return userDao.select(); &#125;&#125; UserController.java12345678910111213141516@Controllerpublic class UserController &#123; private UserService userService; @Autowired public void setUserService(UserService userService) &#123; this.userService = userService; &#125; @RequestMapping(\"/select\") public String select(ModelMap map) &#123; map.addAttribute(\"select\", userService.select()); return \"/select.jsp\"; &#125;&#125; select.jsp1234567891011121314151617181920212223&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;List&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;select&#125;\" var=\"bean\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;bean.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;bean.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;bean.pwd&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SSM","slug":"Frames/SSM","permalink":"http://kwin1113.github.io/categories/Frames/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://kwin1113.github.io/tags/SSM/"}]},{"title":"拦截器","slug":"Frames/SpringMVC/拦截器","date":"2019-02-04T15:14:08.000Z","updated":"2019-02-04T16:52:51.351Z","comments":true,"path":"passages/Frames/SpringMVC/拦截器/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/拦截器/","excerpt":"","text":"Struts2中拦截器的概念：1、拦截器是基于java的反射机制的，而过滤器是基于函数回调2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次 一.概念 拦截器(Interceptor)是动态拦截Action调用的对象，类似于Servlet中的过滤器，在执行Action的业务逻辑处理方法(execute())之前，struts2会首先执行在struts.xml中引用的拦截器。 拦截器是struts2的一个重要特性，Struts2框架的大多数核心功能都是通过拦截器来实现的，像避免表单重复提交，类型转换，对象组装，验证，文件上传等，都是在拦截器的帮助下实现的。拦截器可以在Action执行之前和执行之后拦截调用。二.拦截器实现原理 struts2拦截器的基本实现相当于方法的嵌套调用。 Struts2的拦截器机制采用了使用动作调用链的方式来嵌套调用拦截器，并将动作调用链封装在实现ActionInvocation接口的类中，而且每一个拦截器方法都有一个ActionInvocation类型的参数，在ActionInvocation接口中有一个invoke方法，在某一个拦截器方法中调用invoke方法时，就会调用下一个拦截器方法，如果当前拦截器是最后一个拦截器，就会调用Action的execute方法。","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"spingmvc中ajax的处理","slug":"Frames/SpringMVC/spingmvc中ajax的处理","date":"2019-02-04T15:13:41.000Z","updated":"2019-02-04T16:52:37.735Z","comments":true,"path":"passages/Frames/SpringMVC/spingmvc中ajax的处理/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/spingmvc中ajax的处理/","excerpt":"","text":"使用HttpServletResponse来处理—不需要配置解析器12345678@RequestMapping(\"/ajax\")public void ajax（String name, HttpServletResponse response) throws IOException&#123; if(\"siggy\".equals(name))&#123; response.getWriter().print(\"true\"); &#125;else&#123; response.getWriter().print(\"false\"); &#125;&#125; JSONJson是一种轻量级的数据交换格式ContentNegotiatingViewResolver ResponseEntity@ResponseBody / @RequestBody springmvc 处理 json 数据导入jar包配置json转换器1234567891011121314151617&lt;!--用于将对象转换为JSON--&gt;&lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;test/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"jsonConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"stringConverter\"/&gt; &lt;ref bean=\"jsonConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; controller12345678910111213@Controllerpublic class JsonController&#123; @RequestMapping(\"/json\") @ResponseBody public List&lt;User&gt; json()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(1,\"zhangsan\",\"male\")); list.add(new User(2,\"nico\",\"female\")); list.add(new User(3,\"jackson\",\"male\")); return list; &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"文件上传","slug":"Frames/SpringMVC/文件上传","date":"2019-02-04T15:13:19.000Z","updated":"2019-02-04T16:52:56.119Z","comments":true,"path":"passages/Frames/SpringMVC/文件上传/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/文件上传/","excerpt":"","text":"单个文件上传通过commons-fileupload来实现导入相关jar包commons-fileupload commons-io 配置springmvc的配置解析器123456&lt;context:component-scan base-package=\"com.test.controller\"/&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;property name=\"maxUploadSize\" value=\"10485760000\"&gt;&lt;/property&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"&gt;&lt;/property&gt;&lt;/bean&gt; jsp页面12345&lt;body&gt; &lt;form action=\"upload.do\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件上传：&lt;input type=\"file\" name=\"file\"/&gt;&lt;input type=\"submit\" value=\"upload\"/&gt; &lt;/form&gt;&lt;/body&gt; controller123456789101112131415161718@Controllerpublic class FileUploadController &#123; @RequestMapping(\"upload\") public String upload(@RequestParam(\"file\")CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; String path = request.getRealPath(\"/fileupload\"); InputStream is = file.getInputStream(); OutputStream os = new FileOutputStream(new File(path, file.getOriginalFilename())); int len = 0; byte[] buffer = new byte[400]; while ((len = is.read(buffer)) != -1) &#123; os.write(buffer, 0, len); &#125; is.close(); os.close(); return \"/index.jsp\"; &#125;&#125; 批量上传controller1234567891011121314151617181920@Controllerpublic class FileUploadController &#123; @RequestMapping(\"batch\") public String upload(@RequestParam(\"file\") CommonsMultipartFile file[], HttpServletRequest request) throws IOException &#123; String path = request.getRealPath(\"/fileupload\"); for (int i = 0; i &lt; file.length; i++) &#123; InputStream is = file[i].getInputStream(); OutputStream os = new FileOutputStream(new File(path, file[i].getOriginalFilename())); int len = 0; byte[] buffer = new byte[400]; while ((len = is.read(buffer)) != -1) &#123; os.write(buffer, 0, len); &#125; is.close(); os.close(); &#125; return \"/index.jsp\"; &#125;&#125; jsp1234567&lt;body&gt; &lt;form action=\"batch.do\" method=\"post\" enctype=\"multipart/form-data\"&gt; 文件上传：&lt;input type=\"file\" name=\"file\"/&gt; 文件上传：&lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"上传\"/&gt; &lt;/form&gt;&lt;/body&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"乱码及Restful风格","slug":"Frames/SpringMVC/乱码及Restful风格","date":"2019-02-04T15:13:01.000Z","updated":"2019-02-04T16:52:42.776Z","comments":true,"path":"passages/Frames/SpringMVC/乱码及Restful风格/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/乱码及Restful风格/","excerpt":"","text":"乱码的解决—通过过滤器来解决乱码：springmvc中提供CharacterEncodingFilter解决post乱码123456789101112&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get乱码修改tomcat配置解决自定义乱码解决的过滤器 Restful风格的url优点：轻量级，安全，效率高1234567//http://localhost:8080/restful/1/123/delete.do@RequestMapping(\"/&#123;id&#125;/&#123;uid&#125;/delete\")public String hello(@PathVariable int uid, @PathVariable int id)&#123; System.out.println(\"id=\" + id); System.out.println(\"uid=\" + uid); return \"/index.jsp\";&#125; 同一个controller通过参数来到达不同的处理方法提交url: http://localhost:8080/restful/hello.do?method=add处理代码：12345678910111213141516171819202122@Controller@RequestMapping(\"/hello\")public class HelloController &#123; @RequestMapping(params = \"method=add\", method = RequestMethod.GET) public String add() &#123; System.out.println(\"add\"); return \"redirect:/index.jsp\"; &#125; @RequestMapping(params = \"method=update\") public String update() &#123; System.out.println(\"update\"); return \"redirect:/index.jsp\"; &#125; @RequestMapping(params = \"method=delete\") public String delete() &#123; System.out.println(\"delete\"); return \"redirect:/index.jsp\"; &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"数据的处理","slug":"Frames/SpringMVC/数据的处理","date":"2019-02-04T15:12:43.000Z","updated":"2019-02-04T16:52:53.798Z","comments":true,"path":"passages/Frames/SpringMVC/数据的处理/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/数据的处理/","excerpt":"","text":"1.提交数据的处理 提交的域名称和处理方法参数名一致提交的数据 &emsp;&emsp;处理方法12345@RequestMapping(\"/hello\")public String hello(String name) &#123; System.out.println(name); return \"index.jsp\";&#125; 提交的域名称和处理方法参数名不一致提交的数据 &emsp;&emsp;处理方法12345678/**@RequestParam(\"uname\")是提交域名的名称 */@RequestMapping(\"/hello\")public String hello(@RequestParam(\"uname\")String name) &#123; System.out.println(name); return \"index.jsp\";&#125; 提交的是一个对象提交数据 &emsp;&emsp;处理方法12345@RequestMapping(\"/user\")public String user(User user) &#123; System.out.println(user); return \"index.jsp\";&#125; &emsp;&emsp;用户类123456public class User &#123; public String username; public String password; //set、get&#125; 2.将数据显式到UI层 第一种通过ModelAndView—需要视图解析器 12345678910@RequestMapping(\"/hello\")public ModelAndView hello() &#123; ModelAndView mv = new ModelAndView(); //视图名 mv.setViewName(\"hello\"); //封装要显示到视图中的数据 //相当于request.setAttribute(\"msg\",\"hellospring\"); mv.addObject(\"msg\", \"hello\"); return mv;&#125; 第二种通过ModelMap来实现—不需要视图解析器ModelMap需要作为处理方法的参数 1234567@RequestMapping(\"/hello\") public String hello(@RequestParam(\"uname\")String name, ModelMap modelMap) &#123; //相当于request.setAttribute(\"name\", name); modelMap.addAttribute(\"name\", name); System.out.println(name); return \"index.jsp\"; &#125; ModelAndView 和 ModelMap 的区别 相同点都可以将数据封装显示到表示层页面中 不同点 ModelAndView 可以指定跳转的视图，而 ModelMap 不能 ModelAndView 需要视图解析器，ModelMap 不需要配置 Binding将请求中的字段按照名字匹配的原则填入模型对象@ModelAttribute （on Method forward / redirect）","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"结果跳转方式","slug":"Frames/SpringMVC/结果跳转方式","date":"2019-02-04T15:12:28.000Z","updated":"2019-02-04T16:52:58.358Z","comments":true,"path":"passages/Frames/SpringMVC/结果跳转方式/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/结果跳转方式/","excerpt":"","text":"1.设置ModelAndView对象。&emsp;&emsp;根据View的名称，和视图解析器跳转到指定的页面。&emsp;&emsp;页面：视图解析器的前缀 + viewname +视图解析器的后缀 2.通过ServletAPI来实现，不需要配置视图解析器通过HttpServletResponse输出1response.getWriter().println(\"hello\"); 通过HttpServletResponse实现重定向1response.sendRedirect(\"index.jsp\"); 通过HttpServletRequest转发实现12request.setAttribute(\"msg\", \"servlet api forward\");request.getRequestDispatcher(\"index.jsp\").forward(request, response); 3.通过 springmvc 来实现转发和重定向—没有视图解析器转发的实现1234567@RequestMapping(\"/hello1\")public String hello() &#123; //转发1 return \"index.jsp\"; //转发2 return \"forward:index.jsp\";&#125; 重定向1234@RequestMapping(\"/hello1\")public String hello() &#123; return \"redirect:index.jsp\";&#125; 4.通过 springmvc 来实现转发和重定向—有视图解析器转发1234@RequestMapping(\"/hello1\")public String hello() &#123; return \"index\";&#125; 注意：重定向 return “redirect:index.jsp”; 不需要视图解析器","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"Controller配置方式","slug":"Frames/SpringMVC/Controller配置方式","date":"2019-02-04T15:12:09.000Z","updated":"2019-02-04T16:52:30.815Z","comments":true,"path":"passages/Frames/SpringMVC/Controller配置方式/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/Controller配置方式/","excerpt":"","text":"第一种 URL对应Bean&emsp;&emsp;如果要使用此类配置方式，需要在XML中做如下样式配置123&lt;!--表示将请求的URL和Bean名字映射--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"/&gt;&lt;bean name=\"/hello.do\" class=\"test.HelloController\"/&gt; 以上配置，访问/hello.do就会寻找ID为/hello.do的Bean，此类方式仅适用于小型的应用系统 第二种 为URL分配Bean&emsp;&emsp;使用一个统一配置集合，对各个URL对应的Controller做关系映射1234567891011&lt;!--最常用的映射配置方式--&gt;&lt;!--&lt;prop key=\"/hello*.do\"&gt;helloController&lt;/prop&gt;--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\"&gt; &lt;property name=\"mappings\"&gt; &lt;props&gt; &lt;!-- key对应url请求 value对应处理器的id --&gt; &lt;prop key=\"/hello.do\"&gt;helloController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean name=\"helloController\" class=\"test.HelloController\"&gt;&lt;/bean&gt; &emsp;&emsp;此类配置还可以使用通配符，访问/hello.do时，Spring会把请求分配给helloController进行处理 第三种 URL匹配Bean&emsp;&emsp;如果定义的Controller名称规范，也可以使用如下配置123&lt;!--将hello*.do交给helloController处理--&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping\"&gt;&lt;/bean&gt;&lt;bean name=\"helloController\" class=\"test.HelloController\"&gt;&lt;/bean&gt; 第四种 注解&emsp;&emsp;首先在配置文件中开启注解1234&lt;!--启用Spring注解--&gt;&lt;context:component-scan base-package=\"test\"/&gt;&lt;bean id=\"\" class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt;&lt;/bean&gt; &emsp;&emsp;在编写类上使用注解&emsp;&emsp;@org.springframework.stereotype.Controller标记这是个Controller对象使用@RequestMapping(“/hello.do”)指定方法对应处理的路径，这里只是简单示例，会有更复杂的配置12345678910@Controllerpublic class HelloController &#123; @SuppressWarnings(\"deprecation\") @RequestMapping(\"/hello.do\") public String hello(HttpServletRequest request, HttpServletResponse response) &#123; request.getAttribute(\"user\", request.getParameter(\"user\") + \"--&gt;\" + new Date().toLocalString()); return \"hello\"; &#125;&#125; json配置1234567891011121314151617&lt;!--用于将对象转换为JSON--&gt;&lt;bean id=\"stringHttpMessageConverter\" class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;test/plain;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"jsonConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"stringConverter\"/&gt; &lt;ref bean=\"jsonConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 文件上传配置1234567&lt;!--扫描该包下的注解--&gt;&lt;context:component-scan base-package=\"com.test\"/&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;property name=\"maxUploadSize\" value=\"10485760000\"&gt;&lt;/property&gt; &lt;property name=\"maxInMemorySize\" value=\"40960\"&gt;&lt;/property&gt;&lt;/bean&gt; 12345678910111213141516@RequestMapping(\"/upload\")public String upload(@RequestParam(\"file\")CommonsMultipartFile file, HttpServletRequest request) throws IOException &#123; System.out.println(\"fileName:\" + file.getOriginalFilename()); String path = request.getRealPath(\"/upload\"); InputStream is = file.getInputStream(); OutputStream os = new FileOutputStream(new File(path, file.getOriginalFilename())); byte[] buffer = new byte[400]; int len = 0; while ((len = is.read(buffer)) != -1) &#123; os.write(buffer, 0, len); &#125; os.close(); is.close(); return \"redirect:index.jsp\";&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"mvc框架要做哪些事情","slug":"Frames/SpringMVC/mvc框架要做哪些事情","date":"2019-02-04T15:11:45.000Z","updated":"2019-02-04T16:52:35.014Z","comments":true,"path":"passages/Frames/SpringMVC/mvc框架要做哪些事情/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/mvc框架要做哪些事情/","excerpt":"","text":"mvc框架要做哪些事情：&emsp;&emsp;1.将url映射到Java类或Java类中的方法&emsp;&emsp;2.封装用户提交的数据&emsp;&emsp;3.处理请求—调用相关的业务处理—封装响应的数据&emsp;&emsp;4.将相应的数据进行渲染，jsp、html、freemarker等 SpringMVC是一个轻量级的，基于请求响应的mvc框架 spring mvc 的优点： 性能比 struts2 好。 简单轻便易学。 和 spring 无缝集成（使用spring ioc aop）。 使用约定优于配置。 能够进行简单的 Junit 测试。 支持 Restful 风格。 异常处理。 本地化、国际化。 数据验证、类型转换。 拦截器 hello springmvc的案例步骤： 1.导入相关jar包2.配置web.xml文件—配置分发器123456789&lt;servlet&gt; &lt;servlet-name&gt;servletmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;servletmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3.添加springmvc配置文件：默认在WEB-INF下添加[DispatcherServletName]-servlet.xml文件12345678910111213//springmvc配置文件头：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlms=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;/beans&gt; 4.编写 HelloController.java12345678910public class HelloController implements Controller &#123; @Override public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\", \"Hello SpringMVC\"); mv.setViewName(\"Hello\"); return mv; &#125;&#125; 5.编写springmvc配置文件1234567891011121314&lt;!--配置handlermapping--&gt;&lt;bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"&gt;&lt;/bean&gt;&lt;!--配置handleradapter--&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\"&gt;&lt;/bean&gt;&lt;!--配置渲染器--&gt;&lt;bean id=\"jspViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"&gt;&lt;/property&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置请求和处理器--&gt;&lt;bean name=\"/Hello.do\" class=\"com.test.controller.HelloController\"&gt;&lt;/bean&gt; 6.测试使用注解开发springmvc1.导入jar包2.web.xml配置123456789&lt;servlet&gt; &lt;servlet-name&gt;mvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; //*********// &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; //*********// &lt;param-value&gt;classpath:mvc.xml&lt;/param-value&gt; //*********// &lt;/init-param&gt; //*********// &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 3.Controller1234567891011@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public ModelAndView hello(HttpServletRequest request, HttpServletResponse response) &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"msg\", \"hellospringmvc annotation\"); mv.setViewName(\"hello\"); return mv; &#125;&#125; 4.springmvc配置12345678910&lt;!--配置视图渲染器/解析器--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" name=\"jspViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;!--结果视图的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;!--结果视图的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt;&lt;/bean&gt;&lt;!--扫描该包下的注解--&gt;&lt;context:component-scan base-package=\"com.test\"/&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"SpringMVC配置","slug":"Frames/SpringMVC/SpringMVC配置","date":"2019-02-04T15:11:23.000Z","updated":"2019-02-04T16:52:40.320Z","comments":true,"path":"passages/Frames/SpringMVC/SpringMVC配置/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/SpringMVC配置/","excerpt":"","text":"1. web.xml文件&emsp;&emsp;新建web项目之后webRoot目录下面会有一个web.xml文件，我们先来对其进行配置。1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &emsp;&emsp;这里定义了一个servlet，servlet名自己取后面要用到，class固定的，不可改变。&emsp;&emsp;然后就是初始化init后要加载的xml文件，默认名为servlet名-servlet.xml，这个是要加载到webroot-webinf-classes下的，我们将其放到项目目录下的src目录，它会自动加载到classes目录。&emsp;&emsp;于是我们在src下新建一个xxx-servlet.xml文件。 2. springmvc-servlet.xml&emsp;&emsp;这里配置上面所提到的servlet名-servlet.xml文件，放在项目目录下的src目录！！！123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd\"&gt; &lt;!-- spring扫描的包 --&gt; &lt;context:component-scan base-package=\"com.eco.controllor\"/&gt; &lt;!-- DispatcherServlet不处理静态资源,交给服务器默认的servlet处理 --&gt; &lt;mvc:default-servlet-handler /&gt; &lt;!-- 启用annotation --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 视图渲染器 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"&gt; &lt;!-- 前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt; &lt;/bean&gt;&lt;/beans&gt; &emsp;&emsp;鉴于annotation开发的高效率，这里一致使用annotation。&emsp;&emsp;上面视图渲染器定义，如果要访问项目名/hello实际上就是访问项目名/WEB-INF/jsp/hello.jsp，这样是符合编程开发的“约定优于配置”原则。就像数据库有个表student，那么它的持久化类就应该是Student，我想在浏览器访问项目下的hello页面，你就应该帮我指向项目名/WEB-INF/jsp/目录下的hello.jsp页面。 3. 创建JSP页面&emsp;&emsp;WEB-INF/jsp/目录下创建hello.jsp页面，随便在body中添加几句话。 4. 创建Controller类123456789101112131415@Controllerpublic class Controller &#123; @RequestMapping(\"/eco\") public String hello()&#123; return \"hello\"; &#125; @RequestMapping(\"/hi\") public ModelAndView show()&#123; ModelAndView mv=new ModelAndView(); mv.addObject(\"msg\", \"world\"); mv.setViewName(\"hi\"); return mv; &#125;&#125; &emsp;&emsp;类名自定义，下面看注解的意思&emsp;&emsp;@Controller注解，声明这个类是一个控制器Controller。&emsp;&emsp;@RequestMapping(“/hello”) 这个注解当浏览器访问项目名/eco时，跳转到（return）到hello.jsp这个页面，也可以是其他页面。下面一个Mapping注解呢，不仅实现了页面跳转（hi.jsp），还设置了一个msg变量，可以在hi.jsp中用el表达式来调用它的值；hello ${msg} 输出 hello world。 5. 测试&emsp;&emsp;接下来在浏览器输入localhost:8080/webmvc/hi","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"基本概念","slug":"Frames/SpringMVC/基本概念","date":"2019-02-04T15:10:42.000Z","updated":"2019-02-04T16:52:47.863Z","comments":true,"path":"passages/Frames/SpringMVC/基本概念/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringMVC/基本概念/","excerpt":"","text":"前端控制器 MVC本质MVC的核心思想是业务数据抽取同业务数据呈现相分离 MVC：Model - View - Controller View视图层：为用户提供UI，重点关注数据的呈现 Model模型层：业务数据的信息表示，关注支撑业务的信息构成，通常是多个业务实体的组合 Controller控制层：调用业务逻辑产生合适的数据（Model），传递数据给视图层用于呈现 MVC是一种架构模式&emsp;&emsp;程序分层，分工合作，既相互独立，又协同工作MVC是一种思考方式&emsp;&emsp;需要将什么信息展示给用户？如何布局？调用哪些业务逻辑？ Spring MVC基本概念DispatcherServlet Controller HandlerAdapter HandlerInterceptorHandlerMappingHandlerExecutionChain ModerAndViewViewResolverView","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringMVC","slug":"Frames/SpringMVC","permalink":"http://kwin1113.github.io/categories/Frames/SpringMVC/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://kwin1113.github.io/tags/SpringMVC/"}]},{"title":"Optional","slug":"Frames/SpringBoot/Optional","date":"2019-02-04T15:08:50.000Z","updated":"2019-02-04T16:52:19.479Z","comments":true,"path":"passages/Frames/SpringBoot/Optional/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringBoot/Optional/","excerpt":"","text":"Optional Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。 Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。 Optional 类的引入很好的解决空指针异常。 序号 方法描述 1 static Optional empty()返回空的 Optional 实例。 2 boolean equals(Object obj)判断其他对象是否等于 Optional。 3 Optional filter(Predicate&lt;? super predicate)如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。 4 Optional flatMap(Function&lt;? super T,Optional&gt; mapper)如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional 5 T get()如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException 6 int hashCode()返回存在值的哈希码，如果值不存在 返回 0。 7 void ifPresent(Consumer&lt;? super T&gt; consumer)如果值存在则使用该值调用 consumer , 否则不做任何事情。 8 boolean isPresent()如果值存在则方法会返回true，否则返回 false。 9 Optional map(Function&lt;? super T,? extends U&gt; mapper)如果存在该值，提供的映射方法，如果返回非null，返回一个Optional描述结果。 10 static Optional of(T value)返回一个指定非null值的Optional。 11 static Optional ofNullable(T value)如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。 12 T orElse(T other)如果存在该值，返回值， 否则返回 other。 13 T orElseGet(Supplier&lt;? extends T&gt; other)如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。 14 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常 15 String toString()返回一个Optional的非空字符串，用来调试","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringBoot","slug":"Frames/SpringBoot","permalink":"http://kwin1113.github.io/categories/Frames/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://kwin1113.github.io/tags/SpringBoot/"}]},{"title":"属性配置","slug":"Frames/SpringBoot/属性配置","date":"2019-02-04T15:08:37.000Z","updated":"2019-02-04T16:52:22.888Z","comments":true,"path":"passages/Frames/SpringBoot/属性配置/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/SpringBoot/属性配置/","excerpt":"","text":"@Value@Component@ConfigurationProperties@PathVariable@RequestParam@GetMappingSpring-Data-Jpa:JPA（Java Persistence API）定义了一系列对象持久化的标准，目前实现这一规范的产品又Hibernate、TopLink等。","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"SpringBoot","slug":"Frames/SpringBoot","permalink":"http://kwin1113.github.io/categories/Frames/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://kwin1113.github.io/tags/SpringBoot/"}]},{"title":"声明式事务","slug":"Frames/Spring/声明式事务","date":"2019-02-04T14:25:54.000Z","updated":"2019-02-04T16:52:03.134Z","comments":true,"path":"passages/Frames/Spring/声明式事务/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/声明式事务/","excerpt":"","text":"","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"spring整合mybatis","slug":"Frames/Spring/spring整合mybatis","date":"2019-02-04T14:25:17.000Z","updated":"2019-02-04T16:51:53.393Z","comments":true,"path":"passages/Frames/Spring/spring整合mybatis/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/spring整合mybatis/","excerpt":"","text":"例1. 导入jar包spring + mybatis + mysql-connect + mybatis-spring UserDaoImpl.java123456789101112public class UserDaoImpl implements UserDao &#123; private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate; &#125; @Override public List&lt;User&gt; selectAll() &#123; return sqlSessionTemplate.selectList(\"entity.User.selectAll\"); &#125;&#125; beans.xml12345678910111213141516171819&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"sqlSessionTemplate\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"userDao\" class=\"DaoImpl.UserDaoImpl\"&gt; &lt;property name=\"SqlSessionTemplate\" ref=\"sqlSessionTemplate\"/&gt;&lt;/bean&gt; mybatis-config.xml1234567891011&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name=\"entity\"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;mapper resource=\"user-mapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; usermapper.xml123456&lt;mapper namespace=\"entity.User\"&gt; &lt;select id=\"selectAll\" resultType=\"User\"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; 测试类：12345678910public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDao userDao = (UserDao) context.getBean(\"userDao\"); List&lt;User&gt; list = userDao.selectAll(); for (User u : list) &#123; System.out.println(u); &#125; &#125;&#125; 2. 声明式事务要么执行完一个事务，若发生错误则回滚交给spring容器管理 beans.xml1234567891011121314151617&lt;!--声明式事务配置 开始--&gt;&lt;!--配置事务管理器--&gt;&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;!--配置事务通知--&gt;&lt;tx:advice id=\"txAdivce\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;!--配置哪些方法使用什么样的事务，配置事务的传播特性--&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* DaoImpl.UserDaoImpl.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdivce\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt;&lt;!--声明式事务配置 结束--&gt; UserDaoImpl.java1234567891011121314151617public class UserDaoImpl implements UserDao &#123; private SqlSessionTemplate sqlSessionTemplate; public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate; &#125; @Override public List&lt;User&gt; selectAll() &#123; User user = new User(); user.setName(\"bbb\"); user.setPwd(\"1111\"); sqlSessionTemplate.insert(\"entity.User.insertUser\",user); sqlSessionTemplate.delete(\"entity.User.deleteById\", 1); return sqlSessionTemplate.selectList(\"entity.User.selectAll\"); &#125;&#125; 测试类：12345678910public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); UserDao userDao = (UserDao) context.getBean(\"userDao\"); List&lt;User&gt; list = userDao.selectAll(); for (User u : list) &#123; System.out.println(u); &#125; &#125;&#125; 事务的传播特性1. PROPAGATION_REQUIRED： 如果存在一个事务，则支持当前事务。如果没有事务则开启2. PROPAGATION_SUPPORTS： 若果存在一个事务，支持当前事务。如果没有事务，则非事务的执行3. PROPAGATION_MANADATORY： 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常4. PROPAGATION_REQUIRES_NEW： 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起5. PROPAGATION_NOT_SUPPORTED： 总是非事务的执行，并过去任何存在的事务6. PROPAGATION_NEVER： 总是非事务的执行，如果存在一个活动事务，则抛出异常7. PROPAGATION_NESTED： 如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按TransactionDefinition.PROPAGATION_REQUIRED属性执行 3. 使用mybatis-spring-1.2.3以上的整合&emsp;&emsp;在spring配置文件中，不需要管理sqlSessionTemplate。在Dao的实现中，需要继承sqlSessionDaoSupport beans.xml1234567&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"mybatis-config.xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"userDao\" class=\"com.study.DaoImpl.UserDaoImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt; UserDaoImpl.java123456public class UserDaoImpl extends SqlSessionDaoSupport implements UserDao &#123; @Override public List&lt;User&gt; selectAll() &#123; return getSqlSession().selectList(\"com.study.User.selectAll\"); &#125;&#125; 4. 使用注解实现UserDao.java1234public interface UserMapper &#123; @Select(\"select * from user\") public List&lt;User&gt; selectAll();&#125; UserService.java123public interface UserService &#123; public List&lt;User&gt; selectAll();&#125; UserServiceImpl.java123456789101112public class UserServiceImpl implements UserService &#123; private UserMapper userMapper = null; public void setUserMapper(UserMapper userMapper) &#123; this.userMapper = userMapper; &#125; @Override public List&lt;User&gt; selectAll() &#123; return userMapper.selectAll(); &#125;&#125; beans.xml1234567891011121314151617181920&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"configLocation\" value=\"mybatis-config.xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"userMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"Dao.UserMapper\"/&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"ServiceImp.UserServiceImpl\"&gt; &lt;property name=\"userMapper\" ref=\"userMapper\"/&gt;&lt;/bean&gt; mybatis-config.xml123&lt;mappers&gt; &lt;mapper class=\"Dao.UserMapper\"/&gt;&lt;/mappers&gt; 5. 第四种—-不需要mybatis配置文件将所有配置信息 配置到spring配置文件中 UserMapper.java123public interface UserMapper &#123; public List&lt;User&gt; selectAll();&#125; userMapper.xml12345&lt;mapper namespace=\"Dao.UserMapper\"&gt; &lt;select id=\"selectAll\" resultType=\"entity.User\"&gt; SELECT * FROM user &lt;/select&gt;&lt;/mapper&gt; UserService同上 UserServiceImpl同上 beans.xml1234567891011121314151617181920&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"123456\"/&gt;&lt;/bean&gt;&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"mapperLocations\" value=\"Dao/userMapper.xml\"/&gt;&lt;/bean&gt;&lt;bean id=\"userMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;property name=\"mapperInterface\" value=\"Dao.UserMapper\"/&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"ServiceImpl.UserServiceImpl\"&gt; &lt;property name=\"userMapper\" ref=\"userMapper\"/&gt;&lt;/bean&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"面向切面编程 — AOP","slug":"Frames/Spring/面向切面编程-—-AOP","date":"2019-02-04T14:24:40.000Z","updated":"2019-02-04T16:52:08.719Z","comments":true,"path":"passages/Frames/Spring/面向切面编程-—-AOP/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/面向切面编程-—-AOP/","excerpt":"","text":"1. aopaspect oriented programming 面向切面编程 2. aop在spring中作用提供声明式服务（声明式事务）允许用户实现自定义切面 3. aop：在不改变代码的情况下增加新的功能传统的编程模式：纵向的编程 aop的编程模式：横向的编程 4. aop的好处 使得真实角色处理的业务更加纯粹，不再去关注一些公共的事情 公共的业务由代理来完成—实现业务的分工 公共业务发生扩展时变得更加集中和方便5. 名词解释关注点：增加的某个业务，如日志、安全、缓存、事务切面（aspect）：一个关注点的模块化连接点（joinpoint）：在程序执行过程中某个特定的点通知（advice）：在切面的某个特定连接点上执行的动作。 前置通知（Before advice）：在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非他抛出一个异常） 后置通知（After returning advice）：在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回 异常通知（After throwing advice）：在方法抛出异常退出时执行的通知 最终通知（After (finally) advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出） 环绕通知（Around advice）：包围一个连接点的通知，如方法调用。 织入（weaving）：把切面连接到其他的应用程序类型或者对象上，并创建一个被通知的对象。 6. 使用spring实现aop第一种实现方式 — 通过springAPI来实现Log.java — 前置通知123456789101112public class Log implements MethodBeforeAdvice &#123; /** * @param method 被调用的方法对象 * @param args 被调用的方法参数 * @param target 被调用的方法的目标对象 */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被执行\"); &#125;&#125; afterLog.java — 后置通知123456789101112public class AfterLog implements AfterReturningAdvice &#123; /** * @param returnval --- 返回值 * @param method --- 被调用的方法 * @param args --- 被调用的参数 * @param target --- 调用的目标对象 */ @Override public void afterReturning(Object returnval, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + \"的\" + method.getName() + \"被成功执行\"); &#125;&#125; ServiceImpl.java — 目标类12345678910111213141516171819202122public class ServiceImpl implements Service&#123; @Override public void add() &#123; System.out.println(\"添加用户\"); &#125; @Override public void update() &#123; System.out.println(\"修改用户\"); &#125; @Override public void delete() &#123; System.out.println(\"删除用户\"); &#125; @Override public void search() &#123; System.out.println(\"查询用户\"); &#125;&#125; beans.xml12345678&lt;bean id=\"service\" class=\"Service.ServiceImpl\"/&gt;&lt;bean id=\"log\" class=\"Log.Log\"/&gt;&lt;bean id=\"afterLog\" class=\"Log.AfterLog\"/&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.study.ServiceImpl.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt;&lt;/aop:config&gt; Test.java12345678public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"beans.xml\"); Service service = (Service)ac.getBean(\"service\"); service.add(); service.delete(); &#125;&#125; aop的重要性 — 很重要spring aop 就是将公共的业务（如日志、安全等）和领域业务结合。当执行领域业务时，将会把公共业务加进来。领域业务更纯粹。程序猿专注于领域业务。其本质还是动态代理。 第二种实现方式—自定义类实现Log.java12345678910public class Log &#123; public void before() &#123; System.out.println(\"-------准备删除-------\"); &#125; public void after() &#123; System.out.println(\"-------删除成功-------\"); &#125;&#125; ServiceImpl.java123456public class ServiceImpl implements Service &#123; @Override public void delete() &#123; System.out.println(\"-------删除用户-------\"); &#125;&#125; beans.xml123456789&lt;bean id=\"log\" class=\"Log.Log\"/&gt;&lt;bean id=\"service\" class=\"ServiceImpl.ServiceImpl\"/&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"log\"&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* ServiceImpl.ServiceImpl.*(..))\"/&gt; &lt;aop:before method=\"before\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Test.java1234567public class Test &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"beans.xml\"); Service service = (Service)applicationContext.getBean(\"service\"); service.delete(); &#125;&#125; 第三种实现方式—使用注解实现Log.java123456789101112131415161718192021@Aspectpublic class Log &#123; @Before(\"execution(* ServiceImpl.ServiceImpl.*(..))\") public void before() &#123; System.out.println(\"---before delete---\"); &#125; @After(\"execution(* ServiceImpl.ServiceImpl.*(..))\") public void after() &#123; System.out.println(\"----after delete---\"); &#125; @Around(\"execution(* ServiceImpl.ServiceImpl.*(..))\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(\"---before around---\"); Object result = proceedingJoinPoint.proceed(); System.out.println(\"----after around---\"); return result; &#125;&#125; beans.xml123&lt;bean id=\"log\" class=\"Log.Log\"/&gt;&lt;bean id=\"service\" class=\"ServiceImpl.ServiceImpl\"/&gt;&lt;aop:aspectj-autoproxy/&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"动态代理","slug":"Frames/Spring/动态代理","date":"2019-02-04T14:24:19.000Z","updated":"2019-02-04T16:52:00.267Z","comments":true,"path":"passages/Frames/Spring/动态代理/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/动态代理/","excerpt":"","text":"1. 动态代理和静态代理的角色是一样的。2. 动态代理的代理类是动态生成的。3. 分为两类—-基于接口动态代理和基于类的动态代理a）基于接口动态代理—jdk动态代理b）基于类的动态代理—cglib现在javasist来生成动态代理 4、jdk动态代理—Proxy类和InvocationHandler接口&emsp;&emsp;InvocationHandler是代理实例的调用处理程序实现的接口。&emsp;&emsp;每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的invoke方法。|类型|方法||—|—|| Object | invoke(Object proxy, Method method, Object [ ] args) 在代理实例上处理方法调用并返回结果 | &emsp;&emsp;在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。参数：proxy—在其上调用方法的代理实例method—对应与在代理实例上调用的接口方法的Method实例。Method对象的声明类将是在其中声明方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口。args—包含传入代理实例上方法调用的参数值的对象数组，如果接口方法不适用参数，则为null。基本类型的参数被包装在适当基本包装器类（如java.lang.Integer或java.lang.Boolean）的实例中。返回：&emsp;&emsp;从代理实例的方法调用返回的值。如果接口方法的声明返回类型是基本类型，则此方法返回的值一定是相应基本包装对象类的实例；否则，它一定是可分配到声明返回类型的类型。如果此方法返回的值为null并且接口方阿飞的返回类型是基本类型，则代理实例上的方法调用将抛出NullPointerException。否则，如果测方法返回的值与上述接口方法的声明返回类型不兼容，则代理实例上的方法调用将抛出ClassCastException。 Proxy来提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类|类型|方法||—|—||static Object|newProxyInstance(ClassLoader loader, Class&lt;?&gt;[ ] interfaces, InvocationHandler h)返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。| &emsp;&emsp;返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。此方法详单与：Proxy.getProxyClass(loader, interfaces). getConstructor(new Class[ ] { InvocationHandler.class }). newInstance(new Object[ ] { handler}); &emsp;&emsp;Proxy.newProxyInstance抛出IllegalArgumentException，原因与Porxy.getProxyClass相同。参数：loader—定义代理类的类加载器interfaces—代理类要实现的接口列表h—指派方法调用的调用处理程序 Service.java123456789public interface Service &#123; public void add(); public void update(); public void delete(); public void search();&#125; ServiceImpl.java1234567891011121314151617public class ServiceImpl implements Service&#123; public void add() &#123; System.out.println(\"添加用户\"); &#125; public void update() &#123; System.out.println(\"修改用户\"); &#125; public void delete() &#123; System.out.println(\"删除用户\"); &#125; public void search() &#123; System.out.println(\"查询用户\"); &#125;&#125; LogService.java12345678910111213141516171819202122232425import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class LogService implements InvocationHandler &#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; public Object getProxy() &#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log(method.getName()); Object result = method.invoke(target, args); return result; &#125; private void Log(String method) &#123; System.out.println(\"执行\" + method + \"方法\"); &#125;&#125; Test.java123456789public class Test &#123; public static void main(String[] args) &#123; Service service = new ServiceImpl(); LogService logService = new LogService(); logService.setTarget(service); Service Proxy = (Service) logService.getProxy(); Proxy.add(); &#125;&#125; &emsp;&emsp;一个动态代理一般代理某一类业务。一个动态代理可以代理多个类","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"静态代理","slug":"Frames/Spring/静态代理","date":"2019-02-04T14:24:00.000Z","updated":"2019-02-04T16:52:05.895Z","comments":true,"path":"passages/Frames/Spring/静态代理/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/静态代理/","excerpt":"","text":"1. 静态代理角色分析：抽象角色—一般使用接口或抽象类来实现。真实角色—被代理的角色代理角色—代理真实角色-代理真实角色后一般会做一些附属操作。客户—使用代理角色来进行操作 2. 代码实现Rent.java—抽象角色123public interface Rent &#123; public void rent();&#125; Host.java—真实角色123456public class Host implements Rent&#123; @Override public void rent() &#123; System.out.println(\"房屋出租\"); &#125;&#125; Proxy.java—代理角色1234567891011121314151617181920212223242526public class Proxy implements Rent&#123; private Host host; public void setHost(Host host) &#123; this.host = host; &#125; public Proxy(Host host) &#123; this.host = host; &#125; @Override public void rent() &#123; see(); host.rent(); fare(); &#125; public void see() &#123; System.out.println(\"看房\"); &#125; public void fare() &#123; System.out.println(\"收手续费\"); &#125;&#125; client.java—客户1234567public class Client &#123; public static void main(String[] args) &#123; Host host = new Host(); Proxy proxy = new Proxy(host); proxy.rent(); &#125;&#125; 3. 使用静态代理：好处: 使得真实角色处理的业务更加纯粹，不再去关注一些公共的事情 公共的业务由代理来完成—实现业务的分工 公共业务发生扩展时变得更加集中和方便缺点： 类多了—多了代理类。工作量变大，开发效率降低","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"bean的作用域和自动装配","slug":"Frames/Spring/bean的作用域和自动装配","date":"2019-02-04T14:23:37.000Z","updated":"2019-02-04T16:51:45.821Z","comments":true,"path":"passages/Frames/Spring/bean的作用域和自动装配/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/bean的作用域和自动装配/","excerpt":"","text":"作用域scope123456789101112&lt;!--bean的作用域singleton单例 整个容器中只有一个对象 默认是单例prototype原型 每次获取bean都产生一个新的对象request 每次请求时创建一个新的对象session 在会话的范围内创建一个对象global session 只在portlet下有用，表示applicationapplication 在应用范围中创建一个对象--&gt;&lt;bean id=\"user\" class=\"com.study.entity.User\" scope=\"singleton\"&gt; &lt;property name=\"name\" value=\"zhansan\"/&gt; &lt;property name=\"address\" ref=\"=addr\"/&gt;&lt;/bean&gt; 注意：在整合struts2和spring时 需要将action设为scope=”prototype“ 自动装配autowire12345678910&lt;bean id=\"userDao\" class=\"DaoImpl.UserDaoImpl\"/&gt;&lt;!-- autowire即自动装配 简化springpe配置 no 不使用自动装配 byName 根据名称取查找相应的bean，如果由则装配上 byType 根据类型查找相应的bean 甚至可以不配置id 但是同类型的bean只能由一个 慎用 constructor 当通过构造器注入 实例化bean时 使用byType的方式装配构造方法 可以在头文件里设置default-autowire--&gt;&lt;bean id=\"serviceImpl\" class=\"ServiceImpl.ServiceImpl\" autowire=\"byType\"/&gt; 推荐不使用自动装配，而使用annotation","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"依赖注入DI","slug":"Frames/Spring/依赖注入DI","date":"2019-02-04T14:23:15.000Z","updated":"2019-02-04T16:51:57.823Z","comments":true,"path":"passages/Frames/Spring/依赖注入DI/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/依赖注入DI/","excerpt":"","text":"1. 依赖注入—-dependency injection 依赖：指bean对象创建依赖于容器。bean对象的依赖资源 注入：指bean对象依赖的资源由容器来设置和装配。2. spring注入—-构造器注入 ioc创建对象3、spring注入—-setter注入要求被注入的属性必须由set方法。set方法的方法名由set+属性首字母大写。如果属性是Boolean 没有get方法 是is– 常量注入123&lt;bean id=\"user\" class=\"com.study.entity.User\"&gt;&lt;property name=\"name\" value=\"zhansan\"&gt;&lt;/property&gt;&lt;/bean&gt; – bean注入12345&lt;bean id=\"=addr\" class=\"com.study.entity.Address\"/&gt;&lt;bean id=\"user\" class=\"com.study.entity.User\"&gt; &lt;property name=\"name\" value=\"zhansan\"/&gt; &lt;property name=\"address\" ref=\"=addr\"/&gt;&lt;/bean&gt; – 数组注入123456789&lt;bean id=\"user\" class=\"com.study.entity.User\"&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;哈利波特1&lt;/value&gt; &lt;value&gt;哈利波特2&lt;/value&gt; &lt;value&gt;哈利波特3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; – list注入123456789&lt;bean id=\"user\" class=\"com.study.entity.User\"&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;value&gt;乒乓球&lt;/value&gt; &lt;value&gt;羽毛球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; – map注入123456789&lt;property name=\"cards\"&gt; &lt;map&gt; &lt;entry key=\"AA\" value=\"112346346\"&gt;&lt;/entry&gt; &lt;entry&gt; &lt;key&gt;&lt;value&gt;BB&lt;/value&gt;&lt;/key&gt; &lt;value&gt;25337457&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; – set注入1234567&lt;property name=\"games\"&gt; &lt;set&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;dota&lt;/value&gt; &lt;value&gt;dnf&lt;/value&gt; &lt;/set&gt;&lt;/property&gt; – Null注入1&lt;property name=\"wife\"&gt;&lt;/null&gt;&lt;/property&gt; – properties注入123456&lt;property name=\"info\"&gt; &lt;props&gt; &lt;prop key=\"学号\"&gt;1512180129&lt;/prop&gt; &lt;prop key=\"姓名\"&gt;Kwin&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt; – p命名注入注入123&lt;beans xmlns:p=\"http://www.springframework.org/schema/p\"&gt; &lt;bean id=\"people\" class=\"com.study.entity.People\" p:name=\"haha\" p:age=\"123\"&gt;&lt;/bean&gt;&lt;/beans&gt; – c命名空间注入123&lt;beans xmlns:c=\"http://www.springframework.org/schema/c\"&gt; &lt;bean id=\"p1\" class=\"com.study.entity.People\" c:name=\"nico\" c:age=\"14\"/&gt;&lt;/beans&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"ioc实现","slug":"Frames/Spring/ioc实现","date":"2019-02-04T14:22:35.000Z","updated":"2019-02-04T16:51:50.872Z","comments":true,"path":"passages/Frames/Spring/ioc实现/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/ioc实现/","excerpt":"","text":"1. 使用ioc来创建对象有3种方式a）使用无参的构造方法来创建 user.java 123456789101112public class User &#123; private String name; public User() &#123; System.out.println(\"A new User class\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public void show() &#123; System.out.println(\"name=\" + name); &#125;&#125; beans.xml 123&lt;bean id=\"user\" class=\"com.study.entity.User\"&gt; &lt;property name=\"name\" value=\"zhansan\"&gt;&lt;/property&gt;&lt;/bean&gt; b）通过有参构造方法user.java123456789public class User &#123; private String name; public User(String name) &#123; this.name = name; &#125; public void show() &#123; System.out.println(\"name=\" + name); &#125;&#125; beans.xml 第一种 根据参数的下标来设置 1234&lt;bean id=\"user1\" class=\"com.study.entity.User\"&gt; &lt;!-- index指构造参数方法 参数下标从0开始 --&gt; &lt;constructor-arg index=\"0\" value=\"zhangsan\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 第二种 根据参数名称设置 1234&lt;bean id=\"user1\" class=\"com.study.entity.User\"&gt; &lt;!-- name指参数名 --&gt; &lt;constructor-arg name=\"name\" value=\"zhangsan\"&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 第三种 根据参数类型设置 1234&lt;bean id=\"user1\" class=\"com.study.entity.User\"&gt; &lt;!-- type指参数类型 --&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"zhangsan\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; c）通过工厂方法来创建静态工厂UserFactory.java12345public class UserFactory &#123; public static User newInstance(String name) &#123; return new User(name); &#125;&#125; beans.xml123&lt;bean id=\"user1\" class=\"com.study.factory.UserFactory\" factory-method=\"newInstance\"&gt; &lt;constructor-arg name=\"name\" value=\"lisi\"/&gt;&lt;/bean&gt; 动态工厂userdynamicfactory.java12345public class UserDynamicFactory &#123; public User newInstance(String name) &#123; return new User(name); &#125;&#125; beans.xml1234&lt;bean id=\"dynamicFactory\" class=\"com.study.factory.UserDynamicFactory\"/&gt;&lt;bean id=\"user1\" factory-bean=\"dynamicFactory\" factory-method=\"newInstance\"&gt; &lt;constructor-arg name=\"name\" value=\"lisi\"/&gt;&lt;/bean&gt; 2. 给bean设置别名用alias标签设置1&lt;alias name=\"user1\" alias=\"u\"/&gt; 在bean里面直接设置123456789 &lt;!-- id是bean的标识符 要唯一 如果没有配置id，name默认标识符 如果配置id，又配置了name 那么name是别名 name可以设置多个别名 分隔符可以是空格逗号分号 class是bean的全限定名=包名+类名 如果不配置id和name，那么可以根据applicationContext.getBean（class）获取对象--&gt; &lt;bean id=\"user1\" name=\"u1,u1 u3\" class=\"com.study.entity.User\"&gt; &lt;constructor-arg name=\"name\" value=\"lisi\"/&gt; &lt;/bean&gt; import标签 导入spring其他配置文件团队协作通过import实现1&lt;import resource=\"config/spring/entity.xml\"/&gt; 3. Spring-IOC注入方式和场景","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"Spring简介","slug":"Frames/Spring/Spring简介","date":"2019-02-04T14:21:35.000Z","updated":"2019-02-04T16:51:55.568Z","comments":true,"path":"passages/Frames/Spring/Spring简介/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/Spring/Spring简介/","excerpt":"","text":"spring：春天—-给软件行业带来了春天理念：使现有技术更加实用。本身是大杂烩整合现有的框架技术spring优点： 轻量级 ioc容器—控制反转 AOP面向切面编程 对事务的支持 对框架的支持……主要内容 ioc—-inversion of control 控制反转 对象由本来程序本身创建，变为了程序接受对象。 程序员主要精力集中于实现业务实现。 实现了 Service 和 Dao 的解耦工作。Service层和Dao层实现了分离。没有直接依赖关系。 如果Dao的实现发生改变，应用程序本身不用改变。HelloSpring步骤： 导入相关jar包 编写spring配置文件（名称可以自定义）Hello.java1234567891011public class Hello &#123; private String name; public void setName(String name) &#123; this.name = name; &#125; public void show() &#123; System.out.println(\"Hello!\" + name); &#125;&#125; beans.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean name=\"hello\" class=\"com.study.Hello\"&gt; &lt;property name=\"name\" value=\"zhangsan\"/&gt; &lt;/bean&gt;&lt;/beans&gt; test.java1234567public class Test &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Hello hello = (Hello) context.getBean(\"hello\"); hello.show(); &#125;&#125; 思考？ Hello对象是谁创建的？ 由Spring容器创建 Hello对象的属性怎么设置？ 由Spring容器设置 这个过程就叫控制反转 控制的内容：指谁来控制对象的创建：传统的应用程序对象是由程序本身k控制的。使用spring后，是由spring来创建对象的。 反转：正转指程序来创建对象，反转指程序本身不去创建对象，而变为被动地接受对象 总结：以前对象是由程序本身来创建，使用spring后，程序变为被动接收springc创建好的对象。 控制反转—-依赖注入（Dependency Injection） ioc—是一种编程思想。由主动的编程变为被动的接收 ioc的实现是由ioc容器实现的，即BeanFactory","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"Spring","slug":"Frames/Spring","permalink":"http://kwin1113.github.io/categories/Frames/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://kwin1113.github.io/tags/Spring/"}]},{"title":"动态sql","slug":"Frames/MyBatis/动态sql","date":"2019-02-04T14:19:19.000Z","updated":"2019-02-05T08:25:44.907Z","comments":true,"path":"passages/Frames/MyBatis/动态sql/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/动态sql/","excerpt":"","text":"动态sql指根据不同的查询条件生成不同的查询语句mapper文件配置12345678910&lt;mapper namespace=\"User\"&gt; &lt;select id=\"getUser\" resultType=\"User\" parameterType=\"Map\"&gt; SELECT * FROM user &lt;where&gt; &lt;if test=\"name != null\"&gt; name like CONCAT('%',#&#123;name&#125;,'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"关于联表的处理（一对多）","slug":"Frames/MyBatis/关于联表的处理（一对多）","date":"2019-02-04T14:18:28.000Z","updated":"2019-02-05T08:25:47.607Z","comments":true,"path":"passages/Frames/MyBatis/关于联表的处理（一对多）/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/关于联表的处理（一对多）/","excerpt":"","text":"数据库表的设计&emsp;&emsp;&emsp;&emsp; 实体类student.java1234567891011121314151617181920public class Student &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; teacher.java1234567891011121314151617181920212223242526272829public class Teacher &#123; private int id; private String name; private List&lt;Student&gt; students; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125;&#125; 编写映射文件teacher-mapper.xml 第一种 123456789101112131415&lt;mapper namespace=\"Teacher\"&gt; &lt;select id=\"getTeacher\" parameterType=\"int\" resultMap=\"get\"&gt; select s.id sid,s.name sname,s.tid stid,t.id tid,t.name tname from student s,teacher t where s.tid = t.id and t.id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"get\" type=\"Teacher\"&gt; &lt;id column=\"tid\" property=\"id\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;collection property=\"students\" ofType=\"Student\"&gt; &lt;id column=\"sid\" property=\"id\"/&gt; &lt;result column=\"sname\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 第二种 12345678910111213141516&lt;mapper namespace=\"Teacher\"&gt; &lt;select id=\"getTeacher\" resultMap=\"get\"&gt; select * from teacher where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap id=\"get\" type=\"teacher\"&gt; &lt;!-- column是一端在多端的外键 写的是一端主键的列名 --&gt; &lt;collection property=\"students\" ofType=\"Student\" select=\"getStudent\" javaType=\"ArrayList\" column=\"id\"&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getStudent\" resultType=\"Student\"&gt; select * from student where tid=#&#123;tid&#125; &lt;/select&gt;&lt;/mapper&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"关于联表的处理（多对一）","slug":"Frames/MyBatis/关于联表的处理（多对一）","date":"2019-02-04T14:18:03.000Z","updated":"2019-02-05T08:25:46.747Z","comments":true,"path":"passages/Frames/MyBatis/关于联表的处理（多对一）/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/关于联表的处理（多对一）/","excerpt":"","text":"数据库表的设计&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 实体类teacher.java12345678910111213141516171819202122package com.test.entity;public class Teacher &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; student.java12345678910111213141516171819202122232425262728293031package com.test.entity;public class Student &#123; private int id; private String name; private Teacher teacher; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Teacher getTeacher() &#123; return teacher; &#125; public void setTeacher(Teacher teacher) &#123; this.teacher = teacher; &#125;&#125; 编写映射文件student-mapper.xml两种方式： 结果嵌套处理 123456789101112131415161718&lt;mapper namespace=\"Student\"&gt; &lt;!-- 多对一处理方式有两种 1、按结果嵌套处理 2、按查询嵌套处理 --&gt; &lt;select id=\"getStudents\" resultMap=\"get\"&gt; select s.id sid,s.name sname,s.tid stid,t.id tid,t.name tname from student s,teacher t where s.tid = t.id; &lt;/select&gt; &lt;resultMap id=\"get\" type=\"Student\"&gt; &lt;id column=\"sid\" property=\"id\"/&gt; &lt;result column=\"sname\" property=\"name\"/&gt; &lt;association javaType=\"Teacher\" property=\"teacher\"&gt; &lt;id column=\"tid\" property=\"id\"/&gt; &lt;result column=\"tname\" property=\"name\"/&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 查询嵌套处理 12345678910&lt;select id=\"getStudents\" resultMap=\"get\"&gt; select * from student&lt;/select&gt;&lt;resultMap id=\"get\" type=\"Student\"&gt; &lt;association property=\"teacher\" column=\"tid\" select=\"getTeacher\" javaType=\"Teacher\"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id=\"getTeacher\" resultType=\"Teacher\"&gt; SELECT * FROM teacher WHERE id = #&#123;id&#125;&lt;/select&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"使用注解实现mybatis","slug":"Frames/MyBatis/使用注解实现mybatis","date":"2019-02-04T14:17:31.000Z","updated":"2019-02-05T08:25:48.729Z","comments":true,"path":"passages/Frames/MyBatis/使用注解实现mybatis/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/使用注解实现mybatis/","excerpt":"","text":"面向接口编程优点：扩展性好，分层开发中，上层不用关具体的实现，大家都遵循共同的标准，使开发变得容易。规范性更好 注解的实现编写接口1234567891011121314151617public interface UserDao &#123; @Select(\"select * from user where id = #&#123;id&#125;\") public User getById(int id) throws IOException; @Select(\"select * from user\") public List&lt;User&gt; getAll() throws IOException; @Insert(\"insert into user(name, pwd) values(#&#123;name&#125;,#&#123;pwd&#125;)\") public int addUser(User user) throws IOException; @Update(\"update user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id = #&#123;id&#125;\") public int updateUser(User user) throws IOException; @Delete(\"delete from user where id = #&#123;id&#125;\") public int deleteUser(int id) throws IOException;&#125; 在核心配置文件中导入123&lt;mappers&gt; &lt;mapper class=\"com.test.dao.UserDao\"/&gt;&lt;/mappers&gt; 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class UserDaoImpl implements UserDao &#123; @Override public User getById(int id) throws IOException &#123; SqlSession session = Mybatisutil.getsqlSession(); UserDao userDao = session.getMapper(UserDao.class); User user = userDao.getById(id); session.close(); return user; &#125; @Override public List&lt;User&gt; getAll() throws IOException &#123; SqlSession session = Mybatisutil.getsqlSession(); UserDao userDao = session.getMapper(UserDao.class); List&lt;User&gt; list = userDao.getAll(); return list; &#125; @Override public int addUser(User user) throws IOException &#123; SqlSession session = Mybatisutil.getsqlSession(); UserDao userDao = session.getMapper(UserDao.class); int result = userDao.addUser(user); session.commit(); session.close(); return result; &#125; @Override public int updateUser(User user) throws IOException &#123; SqlSession session = Mybatisutil.getsqlSession(); UserDao userDao = session.getMapper(UserDao.class); int result = userDao.updateUser(user); session.commit(); session.close(); return result; &#125; @Override public int deleteUser(int id) throws IOException &#123; SqlSession session = Mybatisutil.getsqlSession(); UserDao userDao = session.getMapper(UserDao.class); int result = userDao.deleteUser(id); session.commit(); session.close(); return result; &#125;&#125; 测试123456789101112public class Test &#123; public static void main(String[] args) throws IOException &#123; UserDaoImpl userDao = new UserDaoImpl(); System.out.println(userDao.getById(1)); System.out.println(userDao.getAll()); User user = new User(\"haha\",\"3333\"); System.out.println(userDao.addUser(user)); User user1 = new User(1,\"heihei\",\"4444\"); System.out.println(userDao.updateUser(user1)); System.out.println(userDao.deleteUser(5)); &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"分页的实现","slug":"Frames/MyBatis/分页的实现","date":"2019-02-04T14:16:53.000Z","updated":"2019-02-05T08:25:45.818Z","comments":true,"path":"passages/Frames/MyBatis/分页的实现/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/分页的实现/","excerpt":"","text":"1. 分析mysql的分页语句：limit startIndex, pageNumselect * from user limit startIndex, pageNum mapper映射文件123&lt;select id=\"selectAll\" parameterType=\"map\" resultType=\"User\"&gt; SELECT * FROM user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; Dao中的写法12345678public List&lt;User&gt; selectAll(int currentPage, int pageSize) throws IOException &#123; SqlSession session = mybatisutil.getSqlSession(); Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"startIndex\", (currentPage - 1) * pageSize); map.put(\"pageSize\", pageSize); List&lt;User&gt; list = session.selectList(\"User.selectAll\", map); return list;&#125; 注意：不用为参数设置类，可以采用map结构来解决 2. 通过RowBounds来实现分页mapper文件不用做任何改变123&lt;select id=\"GetAll\" resultType=\"User\"&gt; SELECT * FROM user&lt;/select&gt; Dao中需要新建RowBounds对象RowBounds rowBounds = new RowBounds(index, size); index是下标，size是数据1234567public List&lt;User&gt; GetAll(int currentPage, int pageSize) throws IOException &#123; SqlSession session = mybatisutil.getSqlSession(); RowBounds rowBounds = new RowBounds((currentPage - 1) * pageSize, pageSize); List&lt;User&gt; list = session.selectList(\"User.GetAll\", null, rowBounds); session.close(); return list;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"解决属性名和列名不一致","slug":"Frames/MyBatis/解决属性名和列名不一致","date":"2019-02-04T14:16:06.000Z","updated":"2019-02-05T08:25:42.646Z","comments":true,"path":"passages/Frames/MyBatis/解决属性名和列名不一致/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/解决属性名和列名不一致/","excerpt":"","text":"1. 数据库列名 2. Java实体类123456public class User &#123; private int id; private String name; private String password; //setter、getter&#125; 3. mapper映射文件123&lt;select id=\"getById\" parameterType=\"int\" resultType=\"User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; //SELECT id, name, pwd FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; 4. 问题：密码没有获取到原因：mybatis会根据查询的列名（会将列名转为小写）取进行设值（列名setter方法） 5. 解决列名和属性名不一致的方法a）为列名指定别名 别名和java实体类的属性名一致123&lt;select id=\"getById\" parameterType=\"int\" resultType=\"User\"&gt; SELECT id, name, pwd password FROM user WHERE id = #&#123;id&#125;&lt;/select&gt; b）设置结果映射类型12345678910&lt;select id=\"getById\" parameterType=\"int\" resultMap=\"UserMap\"&gt; SELECT id, name, pwd password FROM user WHERE id = #&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"UserMap\" type=\"User\"&gt; &lt;!-- id是主键 --&gt; &lt;id column=\"id\" property=\"id\"/&gt; &lt;!-- column是数据库中的列名 property是实体类中的属性名 --&gt; &lt;result column=\"name\" property=\"name\"/&gt; &lt;result column=\"pwd\" property=\"password\"/&gt;&lt;/resultMap&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"配置文件解析","slug":"Frames/MyBatis/配置文件解析","date":"2019-02-04T14:13:24.000Z","updated":"2019-02-05T08:25:41.189Z","comments":true,"path":"passages/Frames/MyBatis/配置文件解析/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/配置文件解析/","excerpt":"","text":"mybatis-config.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 引入外部配置文件 --&gt; &lt;properties resource=\"mysql.properties\"&gt;&lt;/properties&gt; &lt;!-- environments 指mybatis可以配置多个环境 default指向默认的环境每个SqlSessionFactory对应一个环境environment --&gt; &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- type=\"JDBC\" 代表使用JDBC的提交和回滚来管理事务.这个配置直接使用JDBC的提交和回滚功能。它依赖于从数据源获得连接来管理事务的生命周期 MANAGED-这个配置基本上什么都不做，它从不提交或者回滚一个事务。而是让容器（例如：Spring或者J2EE应用服务器）l来管理事务的生命周期 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池，这个数据源的实现缓存了JDBC 连接对象，用于避免每次创建新的数据库连接时都初始化和进行认证，加快程序响应。并发WEB 应用通常通过这种做法来获得快速响应。 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 只是在每次需要的时候简单的打开和关闭连接 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 这个数据源的配置是为了准备与像Spring 或应用服务器能够在外部或者内部配置数据源的容器一起使用，然后在JNDI 上下文中引用它 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 定义映射SQL语句文件 路径用斜杠 --&gt; &lt;mappers&gt; &lt;mapper resource=\"user-mapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; usermapper.xml12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace命名空间 防止sql语句的id重名 namespace命名对应包名+类名/包名+mapper文件名 parameterType 指sql语句参数类型 resultType指返回参数类型--&gt;&lt;mapper namespace=\"com.test.user.UserMapper\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt; &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt; &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt; &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt; &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt; &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 --&gt; &lt;select id=\"getById\" parameterType=\"int\" resultType=\"com.test.user.User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"selectAll\" resultType=\"com.test.user.User\"&gt; select * from user &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"com.test.user.User\" useGeneratedKeys=\"true\"&gt; INSERT INTO user(name, pwd) VALUES (#&#123;name&#125;, #&#123;pwd&#125;) &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"com.test.user.User\"&gt; update user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; SqlSessionFactory和SqlSession123456789101112131415161718public class MyBatisUtil &#123; /* *通过配置文件创建SqlSessionFactory 是一个SqlSession的工厂类 */ public static SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; &#125; /* *SqlSession通过id找到对应的sql语句，执行sql语句 */ public static SqlSession getSqlSession() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); return sqlSessionFactory.openSession(); &#125;&#125; 执行流程读取核心配置文件–&gt;sqlSessionFactory类–&gt;sqlSession–&gt;（执行相关操作） 优化配置文件导入properties配置文件a）在src下加入db.properties1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=123456 b）在mybatis-config.xml中添加properties标签12&lt;!-- 引入外部配置文件 --&gt;&lt;properties resource=\"mysql.properties\"&gt;&lt;/properties&gt; 别名的优化123456&lt;typeAliases&gt; &lt;!-- 为指定类型指定别名，使在mapper文件中可以简化引用 --&gt; &lt;typeAlias type=\"com.test.user.User\" alias=\"User\"/&gt; &lt;!-- 为某个包下的类指定别名，默认别名为类名 --&gt; &lt;package name=\"com.test.user\" /&gt;&lt;/typeAliases&gt;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"基本的crud操作","slug":"Frames/MyBatis/基本的crud操作","date":"2019-02-04T14:12:42.000Z","updated":"2019-02-05T08:25:43.896Z","comments":true,"path":"passages/Frames/MyBatis/基本的crud操作/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/基本的crud操作/","excerpt":"","text":"搭建mybatis框架a）导入相关jar包b）编写核心配置文件（配置数据库连接的相关信息以及配置了mapper映射文件） mybatis-config.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 引入外部配置文件 --&gt; &lt;properties resource=\"mysql.properties\"&gt;&lt;/properties&gt; &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- type=\"JDBC\" 代表使用JDBC的提交和回滚来管理事务 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"user-mapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; c）编写dao操作 userdao.java1234567891011121314151617181920212223242526272829303132333435 public class UserDao &#123; public User getById(int id) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); User user = session.selectOne(\"com.test.user.UserMapper.getById\", id); session.close(); return user; &#125; public int addUser(User user) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); int result = session.insert(\"com.test.user.UserMapper.addUser\", user); session.commit(); session.close(); return result; &#125; public int updateUser(User user)throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); int result = session.update(\"com.test.user.UserMapper.updateUser\", user); session.commit(); session.close(); return result; &#125; public int deleteUser(int id)throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); int result = session.delete(\"com.test.user.UserMapper.deleteUser\", id); session.commit(); session.close(); return result; &#125; public List&lt;User&gt; selectAll() throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); List&lt;User&gt; list = session.selectList(\"com.test.user.UserMapper.selectAll\"); session.close(); return list; &#125;&#125; d）编写mapper映射文件 user-mapper.xml123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.test.user.UserMapper\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt; &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt; &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt; &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt; &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt; &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 --&gt; &lt;select id=\"getById\" parameterType=\"int\" resultType=\"com.test.user.User\"&gt; SELECT * FROM user WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;select id=\"selectAll\" resultType=\"com.test.user.User\"&gt; select * from user &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"com.test.user.User\" useGeneratedKeys=\"true\"&gt; INSERT INTO user(name, pwd) VALUES (#&#123;name&#125;, #&#123;pwd&#125;) &lt;/insert&gt; &lt;update id=\"updateUser\" parameterType=\"com.test.user.User\"&gt; update user set name=#&#123;name&#125;, pwd=#&#123;pwd&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;delete id=\"deleteUser\" parameterType=\"int\"&gt; delete from user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; e）编写实体类 user.java实体类 123456789101112131415161718192021222324252627 public class User &#123; private int id; private String name; private String pwd; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return \"id=\" + id +\", name=\" + name + \", pwd=\" + pwd; &#125;&#125; 调用dao进行测试","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]},{"title":"什么是MyBatis","slug":"Frames/MyBatis/什么是MyBatis","date":"2019-02-04T14:02:26.000Z","updated":"2019-02-05T08:25:49.882Z","comments":true,"path":"passages/Frames/MyBatis/什么是MyBatis/","link":"","permalink":"http://kwin1113.github.io/passages/Frames/MyBatis/什么是MyBatis/","excerpt":"","text":"什么是MyBatis&emsp;&emsp;MyBatis是一个基于Java的持久层框架。&emsp;&emsp;MyBatis是支持普通SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。&emsp;&emsp;MyBatis就是帮助程序猿将数据存入数据库中，和从数据库中取数据。&emsp;&emsp;MyBatis是一个半自动化的ORM（Object Relational Mapping）框架。 持久化&emsp;&emsp;数据从瞬时状态变为持久状态。 持久层&emsp;&emsp;完成持久化工作的代码块。—–DAO 传统的jdbc操作&emsp;&emsp;有很多重复代码块。比如：数据取出时的封装、数据库的建立连接等。通过框架可以减少重复代码，提高开发效率 如何使用MyBatis步骤： 导入mybatis相关jar包asm cglib commons-logging javassist-GA log4j log4j-api log4j-core mybatis slf4j-api slf4j-log4j 数据库驱动包 编写mybatis-config.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 引入外部配置文件 --&gt; &lt;properties resource=\"mysql.properties\"&gt;&lt;/properties&gt; &lt;!-- environments 指mybatis可以配置多个环境 default指向默认的环境 每个SqlSessionFactory对应一个环境eenvironment &lt;!-- 配置mybatis运行环境 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;!-- type=\"JDBC\" 代表使用JDBC的提交和回滚来管理事务 这个配置直接使用JDBC的提交和回滚功能。它依赖于从数据源获得连接来管理事务的生命周期 MANAGED-这个配置基本上什么都不做，它从不提交或者回滚一个事务。而是让容器（例如：Spring或者J2EE应用服务器）l来管理事务的生命周期 --&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;!-- mybatis提供了3种数据源类型，分别是：POOLED,UNPOOLED,JNDI --&gt; &lt;!-- POOLED 表示支持JDBC数据源连接池，这个数据源的实现缓存了JDBC 连接对象，用于避免每次创建新的数据库连接时都初始化和进行认证，加快程序响应。并发WEB 应用通常通过这种做法来获得快速响应。 --&gt; &lt;!-- UNPOOLED 表示不支持数据源连接池 只是在每次需要的时候简单的打开和关闭连接 --&gt; &lt;!-- JNDI 表示支持外部数据源连接池 这个数据源的配置是为了准备与像Spring 或应用服务器能够在外部或者内部配置数据源的容器一起使用，然后在JNDI 上下文中引用它 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 定义映射SQL语句文件 路径用斜杠 --&gt; &lt;mappers&gt; &lt;mapper resource=\"user-mapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 创建SqlSessionFactory以及获得SqlSession 123456789101112public class MyBatisUtil &#123; public static SqlSessionFactory getSqlSessionFactory() throws IOException &#123; String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); return sqlSessionFactory; &#125; public static SqlSession getSqlSession() throws IOException &#123; SqlSessionFactory sqlSessionFactory = getSqlSessionFactory(); return sqlSessionFactory.openSession(); &#125;&#125; 构造一个实体类 1234567891011121314151617181920212223242526272829public class User &#123; private int id; private String name; private String pwd; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125;&#125; 编写 sql 语句的映射文件—–添加到核心配置文件中 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.test.entity.UserMapper\"&gt; &lt;!-- 在映射文件中配置很多sql语句 --&gt; &lt;!-- 将sql语句封装到mappedStatement对象中，所以将id称为statement的id --&gt; &lt;!-- parameterType：指定输入参数的类型，这里指定int型 #&#123;&#125;表示一个占位符号 --&gt; &lt;!-- #&#123;id&#125;：其中的id表示接收输入的参数，参数名称就是id，如果输入 --&gt; &lt;!-- 参数是简单类型，#&#123;&#125;中的参数名可以任意，可以value或其它名称 --&gt; &lt;!-- resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象。 --&gt; &lt;!-- 表名要对，但是不区分大小写，resultType要写类名，同样不区分大小写 --&gt; &lt;select id=\"selectUser\" parameterType=\"int\" resultType=\"com.test.entity.User\"&gt; SELECT * FROM user WHERE id = #&#123;value&#125; &lt;/select&gt;&lt;/mapper&gt; 测试 1234567public class Test &#123; public static void main(String[] args) throws IOException &#123; SqlSession session = MyBatisUtil.getSqlSession(); User user = session.selectOne(\"com.test.entity.UserMapper.selectUser\", 1); System.out.println(\"id=\" + user.getId() + \", name=\" + user.getName() + \", pwd=\" + user.getPwd()); &#125;&#125;","categories":[{"name":"Frames","slug":"Frames","permalink":"http://kwin1113.github.io/categories/Frames/"},{"name":"MyBatis","slug":"Frames/MyBatis","permalink":"http://kwin1113.github.io/categories/Frames/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://kwin1113.github.io/tags/MyBatis/"}]}]}