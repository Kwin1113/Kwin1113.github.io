<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kwin的学习博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kwin1113.github.io/"/>
  <updated>2019-02-28T03:13:58.017Z</updated>
  <id>http://kwin1113.github.io/</id>
  
  <author>
    <name>Kwin Jing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis云平台Cachecloud</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E4%BA%91%E5%B9%B3%E5%8F%B0Cachecloud/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis云平台Cachecloud/</id>
    <published>2019-02-28T03:13:27.000Z</published>
    <updated>2019-02-28T03:13:58.017Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Redis云平台CacheCloud"><a href="#Redis云平台CacheCloud" class="headerlink" title="Redis云平台CacheCloud"></a>Redis云平台CacheCloud</h3><ul><li>Redis规模化运维</li><li>快速构建</li><li>机器部署</li><li>应用接入</li><li>用户功能</li><li>运维功能</li></ul><h4 id="Redis规模化运维困扰"><a href="#Redis规模化运维困扰" class="headerlink" title="Redis规模化运维困扰"></a>Redis规模化运维困扰</h4><ol><li>发布构建繁琐，私搭乱盖</li><li>节点&amp;机器等运维成本</li><li>监控报警初级</li></ol><h4 id="CacheCloud"><a href="#CacheCloud" class="headerlink" title="CacheCloud"></a>CacheCloud</h4><ol><li>一键开启Redis。（Standalone、Sentinel、Cluster）</li><li>机器、应用、实例监控和报警。</li><li>客户端：透明使用、性能上报。</li><li>可视化运维：配置、扩容、Failover、机器/应用/实例上下线。</li><li>已存在Redis直接接入和数据迁移。</li><li><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">开源平台</a></li></ol><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ol><li>全量视频缓存（视频播放API）：跨机房高可用</li><li>消息队列同步（RedisMQ中间件）</li><li>分布式布隆过滤器（百万QPS）</li><li>计数系统：计数（播放数）</li><li>其他：排行榜、社交（直播）、实时计算（反作弊）等。</li></ol><h4 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h4><p><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">开源平台</a></p><h4 id="机器部署"><a href="#机器部署" class="headerlink" title="机器部署"></a>机器部署</h4><h4 id="应用接入"><a href="#应用接入" class="headerlink" title="应用接入"></a>应用接入</h4><p><img src="/passages/Tools/Redis/Redis云平台Cachecloud/1.png" alt="f13803c517f11481dc5f56b33c5440f9.png"><br><img src="/passages/Tools/Redis/Redis云平台Cachecloud/2.png" alt="65547a5db441927cd8ebd49346bd6384.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存的使用与设计</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/缓存的使用与设计/</id>
    <published>2019-02-28T03:11:51.000Z</published>
    <updated>2019-02-28T03:13:19.046Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="缓存的使用与设计"><a href="#缓存的使用与设计" class="headerlink" title="缓存的使用与设计"></a>缓存的使用与设计</h3><ul><li>缓存的受益与成本</li><li>缓存更新策略</li><li>缓存粒度控制</li><li>缓存穿透优化</li><li>无底洞问题优化</li><li>缓存雪崩优化</li><li>热点key重建优化</li></ul><h4 id="缓存的收益与成本"><a href="#缓存的收益与成本" class="headerlink" title="缓存的收益与成本"></a>缓存的收益与成本</h4><h5 id="收益"><a href="#收益" class="headerlink" title="收益"></a>收益</h5><ol><li>加速读写</li></ol><ul><li>通过缓存加速读写速度：CPU L1/L2/L3 Cache、Linux page Cache加速硬盘读写、浏览器缓存、Ehcache缓存数据库结果。</li></ul><ol start="2"><li>降低后端负载</li></ol><ul><li>后端服务器通过前端缓存降低负载：业务端使用Redis降低后端MySQL负载等。</li></ul><h5 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h5><ol><li>数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关。</li><li>代码维护成本：多了一层缓存逻辑。</li><li>运维成本：例如Redis Cluster</li></ol><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ol><li>降低后端负载：</li></ol><ul><li>对高消耗的SQL：join结果集/分组统计结果缓存。</li></ul><ol start="2"><li>加速请求响应：</li></ol><ul><li>利用Redis/Memcache</li></ul><ol start="3"><li>大量写合并为批量写：</li></ol><ul><li>如计数器先Redis累加再批量写DB</li></ul><h4 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h4><ol><li>LRU/LFU/FIFO算法剔除：例如maxmemory-policy。</li><li>超时剔除：例如expire。</li><li>主动更新：开发控制生命周期。</li></ol><table><thead><tr><th>策略</th><th>一致性</th><th>维护成本</th></tr></thead><tbody><tr><td>LRU/LIRS算法剔除</td><td>最差</td><td>低</td></tr><tr><td>超时剔除</td><td>较差</td><td>低</td></tr><tr><td>主动更新</td><td>强</td><td>高</td></tr></tbody></table><h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5><ol><li>低一致性：最大内存和淘汰策略</li><li>高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底。</li></ol><h4 id="缓存粒度控制"><a href="#缓存粒度控制" class="headerlink" title="缓存粒度控制"></a>缓存粒度控制</h4><p><img src="/passages/Tools/Redis/缓存的使用与设计/1.png" alt="afbb147a0498a7aa428dbf80b66a3a4f.png"></p><ol><li>从MySQL获取用户信息：<br>-select * from user where id={id}</li><li>设置用户信息缓存：<br>-set user:{id} <code>select * from user where id={id}</code></li><li>缓存粒度：<br>-全部属性：set user:{id} <code>select * from user where id={id}</code><br>-部分重要属性：set user:{id} <code>select importantColumn1..importantColumn2 from user where id={id}</code></li></ol><h5 id="三个角度"><a href="#三个角度" class="headerlink" title="三个角度"></a>三个角度</h5><ol><li>通用性：全量属性更好。</li><li>占用空间：部分属性更好。</li><li>代码维护：表面上全量属性更好。</li></ol><h4 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h4><p><img src="/passages/Tools/Redis/缓存的使用与设计/2.png" alt="038e9dfe40e6dae69da30ea480421406.png"></p><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ol><li>业务代码自身问题</li><li>恶意攻击、爬虫等</li></ol><h5 id="如何发现"><a href="#如何发现" class="headerlink" title="如何发现"></a>如何发现</h5><ol><li>业务的对应时间</li><li>业务本身问题</li><li>相关指标：总调用数、缓存层命中数、存储层命中数</li></ol><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><ol><li>缓存空对象<br><img src="/passages/Tools/Redis/缓存的使用与设计/3.png" alt="b0ebd26c49a140adbe0cf60fd937cf6a.png"></li></ol><ul><li>问题：<ul><li>需要更多的键。</li><li>缓冲层和存储层数据“短期”不一致。</li></ul></li><li>实例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassThrough</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String cacheValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(cacheValue))&#123;</span><br><span class="line">        String storageValue = storage.get(key);</span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">//如果存储数据为空，需要设置一个过期时间（300秒）</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(storageValue))&#123;</span><br><span class="line">            cache.expire(key, <span class="number">60</span>*<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>布隆过滤器拦截<br><img src="/passages/Tools/Redis/缓存的使用与设计/4.png" alt="410d335b681a3f671af7aeab843a02ea.png"></li></ol><h4 id="无底洞问题优化"><a href="#无底洞问题优化" class="headerlink" title="无底洞问题优化"></a>无底洞问题优化</h4><p>问题关键点：</p><ul><li>更多的机器 != 更高的性能</li><li>批量接口需求（mget,mset等）</li><li>数据增长与水平扩展需求<br><img src="/passages/Tools/Redis/缓存的使用与设计/5.png" alt="7a56bb590ef2a780e5a86e6540e96ed0.png"></li></ul><p><strong><em>优化IO的几种方法</em></strong></p><ol><li>命令本身优化：例如慢查询keys、hgetall bigkey</li><li>减少网络通信次数</li><li>降低接入成本：例如客户端长连接/连接池、NIO等<h4 id="热点key重建优化"><a href="#热点key重建优化" class="headerlink" title="热点key重建优化"></a>热点key重建优化</h4><img src="/passages/Tools/Redis/缓存的使用与设计/6.png" alt="d9d1a95369fd7814908517f7d9618bb9.png"><h5 id="三个目标和两个解决"><a href="#三个目标和两个解决" class="headerlink" title="三个目标和两个解决"></a>三个目标和两个解决</h5><h6 id="三个目标"><a href="#三个目标" class="headerlink" title="三个目标"></a>三个目标</h6></li></ol><ul><li>减少重缓存的次数</li><li>数据尽可能一致</li><li>减少潜在危险</li></ul><h6 id="两个解决"><a href="#两个解决" class="headerlink" title="两个解决"></a>两个解决</h6><ul><li><p>互斥锁<br><img src="/passages/Tools/Redis/缓存的使用与设计/7.png" alt="effce1c63ad816057b3c660f9acc0ea7.png"><br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    String value = redis.get(key);</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="keyword">null</span>)&#123;</span><br><span class="line">        String mutexKey = <span class="string">"mutex:key:"</span> + key;</span><br><span class="line">        <span class="keyword">if</span>(redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>))&#123;</span><br><span class="line">            value = db.get(key);</span><br><span class="line">            redis.set(key, value);</span><br><span class="line">            redis.delete(mutexKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他线程休息50毫秒后充实</span></span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>永不过期</p></li></ul><ol><li>缓存层面：没有设置过期时间（没有用expire）。</li><li>功能层面：为每个value添加逻辑过期时间，但发现超过逻辑过期时间后，会使用单独的线程去构建缓存。<br><img src="/passages/Tools/Redis/缓存的使用与设计/8.png" alt="05ecc4004581fe0bf8f3b6d241e2d13b.png"><br>示例代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">get</span><span class="params">(<span class="keyword">final</span> String key)</span></span>&#123;</span><br><span class="line">    V v = redis.get(key);</span><br><span class="line">    String value = v.getValue();</span><br><span class="line">    <span class="keyword">long</span> logicTimeout = v.getLogicTimeout();</span><br><span class="line">    <span class="keyword">if</span>(logicTimeout &gt;= System.currentTimeMillis())&#123;</span><br><span class="line">        String mutexKey = <span class="string">"mutex:key:"</span> + key;</span><br><span class="line">        <span class="keyword">if</span>(redis.set(mutexKey, <span class="string">"1"</span>, <span class="string">"ex 180"</span>, <span class="string">"nx"</span>))&#123;</span><br><span class="line">            <span class="comment">//异步更新后台异常执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    String dbValue = db.get(key);</span><br><span class="line">                    redis.set(key, (dbValue, newLogicTimeout));</span><br><span class="line">                    redis.delete(keyMutex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>对比</li></ul><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>互斥锁</td><td>思路简单、保持一致性</td><td>代码复杂度增加、存在死锁的风险</td></tr><tr><td>永远不过期</td><td>基本杜绝热点key重建问题</td><td>不保证一致性、逻辑过期时间增加维护成本和内存成本</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>缓存收益：加速读写、降低后端存储负载。</li><li>缓存成本：缓存和存储数据不一致性、代码维护成本、运维成本。</li><li>推荐结合剔除、超时、主动更新三种方案共同完成。</li><li>穿透问题：使用缓存空对象和布隆过滤器来解决，注意它们各自的使用场景和局限性。</li><li>无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。有四种批量操作方式：串行命令、串行IO、并行IO、hash_tag。</li><li>雪崩问题：缓存曾高可用、客户端降级、提前演练是解决雪崩问题的重要方法。</li><li>热点key问题：互斥锁、“永远不过期”能够在一定程度上解决热点key问题，开发人员在使用时要了解它们各自的使用成本。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>RedisCluster开发运维常见问题</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/RedisCluster%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/RedisCluster开发运维常见问题/</id>
    <published>2019-02-28T03:10:47.000Z</published>
    <updated>2019-02-28T03:11:32.655Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="RedisCluster开发运维常见问题"><a href="#RedisCluster开发运维常见问题" class="headerlink" title="RedisCluster开发运维常见问题"></a>RedisCluster开发运维常见问题</h3><ul><li>集群完成性</li><li>带宽消耗</li><li>Pub/Sub广播</li><li>数据倾斜</li><li>读写分离</li><li>数据迁移</li><li>集群vs单机</li></ul><h4 id="集群完整性"><a href="#集群完整性" class="headerlink" title="集群完整性"></a>集群完整性</h4><ul><li>cluster-require-full-coverage默认为yes<ul><li>集群中16384个槽全部可用：保证集群完整性</li><li>节点故障或者正在故障转移<br>（error)CLUSTERDOWN The cluster is down</li></ul></li><li>大多数业务无法容忍，cluster-require-full-coverage建议设置为no</li></ul><h4 id="带宽消耗"><a href="#带宽消耗" class="headerlink" title="带宽消耗"></a>带宽消耗</h4><p><img src="/passages/Tools/Redis/RedisCluster开发运维常见问题/1.png" alt="b23f17cca8f53682b2f689cc9d7bee5e.png"></p><ul><li>官方建议：不超过1000个</li><li>ping/pong消息</li><li>不容忽视的带宽消耗<h5 id="三个方面"><a href="#三个方面" class="headerlink" title="三个方面"></a>三个方面</h5></li><li>消息发送频率：节点发现与其他节点最后通信时间超过cluster-node-timeout/2时会直接发送ping消息</li><li>消息数据量：slots槽数组（2KB空间）和整个集群1/10的状态数据（10个节点状态数据约1KB）</li><li>节点部署的及其规模：集群分布的机器越多且每台机器划分的节点数越均匀，则集群内整体的可用带宽越高。<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5></li><li>避免”大“集群：避免多业务使用一个集群，大业务可以多集群</li><li>cluster-node-timeout：带宽和故障转移速度的均衡。</li><li>尽量均匀分配到多机器上：保证高可用和带宽。</li></ul><h4 id="Pub-Sub广播"><a href="#Pub-Sub广播" class="headerlink" title="Pub/Sub广播"></a>Pub/Sub广播</h4><p><img src="/passages/Tools/Redis/RedisCluster开发运维常见问题/2.png" alt="75cdbaacf97468550fc420d83d61366f.png"></p><ul><li>问题：publish在集群每个节点广播：加重带宽</li><li>解决：单独“走”一套Redis Sentinel</li></ul><h4 id="集群倾斜"><a href="#集群倾斜" class="headerlink" title="集群倾斜"></a>集群倾斜</h4><h5 id="数据倾斜：内存不均"><a href="#数据倾斜：内存不均" class="headerlink" title="数据倾斜：内存不均"></a>数据倾斜：内存不均</h5><ul><li>节点和槽分配不均<ul><li>redis-trib.rb info ip:port查看节点、槽、键值分布</li><li>redis-trib.rb rebalance ip:port进行均衡（谨慎使用）</li></ul></li><li>不同槽对应键值数量差异较大<ul><li>CRC16正常情况下比较均匀</li><li>可能存在hash_tag</li><li>cluster countkeysinslot {slot}获取槽对应键值个数</li></ul></li><li>包含bigkey<ul><li>bigkey：例如大字符串、几百万的元素的hash、set等</li><li>从节点：redis-cli –bigkeys</li><li>优化：优化数据结构</li></ul></li><li>内存相关配置不一致<ul><li>hash-max-ziplist-value、set-max-intset-entries等</li><li>优化：定义“检查”配置一致性<h5 id="请求倾斜：热点"><a href="#请求倾斜：热点" class="headerlink" title="请求倾斜：热点"></a>请求倾斜：热点</h5></li></ul></li><li>热点key：重要的key或者bigkey</li><li>优化：<br>  -避免bigkey<br>  -热键不要用hash_tag<br>  -当一致性不高时，可以使用本地缓存 + MQ</li></ul><h4 id="集群读写分离"><a href="#集群读写分离" class="headerlink" title="集群读写分离"></a>集群读写分离</h4><ul><li>只读连接：集群模式的从节点不接受任何写请求。<ul><li>重定向到负责槽的主节点</li><li>readonly命令可以读：连接级别命令</li></ul></li><li>读写分离：更加复杂<ul><li>同样的问题：复制延迟、读取过期数据、从节点故障</li><li>修改客户端：cluster slaves {nodeId}</li></ul></li></ul><h4 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h4><h5 id="离线-在线迁移"><a href="#离线-在线迁移" class="headerlink" title="离线/在线迁移"></a>离线/在线迁移</h5><ul><li>官方迁移工具：redis-trib.rb import<ul><li>只能从单机迁移到集群</li><li>不支持在线迁移：source需要停写</li><li>不支持断点续传</li><li>单线程迁移：影响速度</li></ul></li><li>在线迁移：<ul><li>唯品会：redis-migrate-tool</li><li>豌豆荚：redis-port</li></ul></li></ul><h4 id="集群单机对比"><a href="#集群单机对比" class="headerlink" title="集群单机对比"></a>集群单机对比</h4><h5 id="集群限制"><a href="#集群限制" class="headerlink" title="集群限制"></a>集群限制</h5><ul><li>key批量操作支持有限：例如mget、mset必须在一个slot</li><li>key事务和lua支持有限：操作的key必须在一个节点</li><li>key是数据分区的最小粒度：不支持bigkey分区</li><li>不支持多个数据库：集群模式下之后一个db0</li><li>复制只支持一层：不支持属性复制结构</li></ul><p><strong><em>分布式Redis不一定好</em></strong></p><ol><li>Redis Cluster：满足容量和性能的扩展性，很多业务“不需要”。</li></ol><ul><li>大多数客户端性能会“降低”。</li><li>命令无法跨节点使用：mget、keys、scan、flush、sinter等。</li><li>lua和事务无法跨节点使用。</li><li>客户端伟华更复杂：SDK和应用本身消耗（例如更多的连接池）。</li></ul><ol start="2"><li>很多场景Redis Sentinel已经足够好。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Redis  Cluster数据分区规则采用虚拟槽方式（16384个槽），每个节点负责一部分槽和相关数据，实现数据和请求的负载均衡。</li><li>搭建集群划分四个步骤：准备节点、节点握手、分配槽、复制。<ul><li>redis-trib.rb工具用于快速搭建集群。</li></ul></li><li>集群伸缩通过在节点之间移动槽和相关数据实现。<ul><li>扩容时根据槽迁移计划把槽从源节点迁移到新节点。</li><li>收缩时如果下线的节点有负责的槽需要迁移到其他节点，再通过cluster forget命令让集群内所有节点忘记被下线节点。</li></ul></li></ul><h4 id="集群总结"><a href="#集群总结" class="headerlink" title="集群总结"></a>集群总结</h4><ul><li>使用smart客户端操作集群达到通信效率最大化，客户端内部负责计算维护键-》槽-&gt;节点的映射，用于快速定位到目标节点。</li><li>集群自动故障转移过程分为故障发现和节点恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的从节点触发故障恢复流程，保证集群的可用性。</li><li>开发运维常见问题包括：超大规模集群带宽消耗，pub/sub广播问题，集群倾斜问题，单机和集群对比等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis-Cluster/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis-Cluster/</id>
    <published>2019-02-28T03:06:05.000Z</published>
    <updated>2019-02-28T03:10:26.787Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><ul><li>呼唤集群</li><li>数据分布</li><li>搭建集群</li><li>集群伸缩</li><li>客户端路由</li><li>集群原理</li><li>故障转移</li><li>开发运维常见问题</li></ul><h4 id="呼唤集群"><a href="#呼唤集群" class="headerlink" title="呼唤集群"></a>呼唤集群</h4><p><strong>1. 并发量</strong><br><img src="/passages/Tools/Redis/Redis-Cluster/1.png" alt="4c53f1ccbcf54eeaa510986cf0618f01.png"><br><strong>2. 数据量</strong><br><img src="/passages/Tools/Redis/Redis-Cluster/2.png" alt="4be4230484669d458bd3196d762f1dec.png"><br><strong>3. 网络流量</strong></p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>分布式：简单的认为加机器</p><h5 id="集群：规模化需求"><a href="#集群：规模化需求" class="headerlink" title="集群：规模化需求"></a>集群：规模化需求</h5><ol><li>并发量：OPS</li><li>数据量：”大数据”</li></ol><h4 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h4><h5 id="分布式数据库-数据分区"><a href="#分布式数据库-数据分区" class="headerlink" title="分布式数据库-数据分区"></a>分布式数据库-数据分区</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/3.png" alt="ec271f7332b0840126bcf408154e58ee.png"></p><h5 id="顺序分区和哈希分区"><a href="#顺序分区和哈希分区" class="headerlink" title="顺序分区和哈希分区"></a>顺序分区和哈希分区</h5><ul><li><p>顺序分布<br><img src="/passages/Tools/Redis/Redis-Cluster/4.png" alt="26cdd825a4847d74dbddbbf8a5fa29dc.png"></p></li><li><p>哈希分布（例如节点取模）<br><img src="/passages/Tools/Redis/Redis-Cluster/5.png" alt="5a6b6f382161e01d9141f8949fdb6081.png"></p></li></ul><h5 id="数据分布对比"><a href="#数据分布对比" class="headerlink" title="数据分布对比"></a>数据分布对比</h5><table><thead><tr><th>分布方式</th><th>特点</th><th>典型产品</th></tr></thead><tbody><tr><td>哈希分布</td><td>数据分散度高、键值分布业务无关、无法顺序访问、支持批量操作</td><td>一致性哈希Memcache、Redis Cluster、其他缓存产品</td></tr><tr><td>顺序分布</td><td>数据分散度易倾斜、键值业务相关、可顺序访问、支持批量操作</td><td>Big Table、HBase</td></tr></tbody></table><h5 id="哈希分布"><a href="#哈希分布" class="headerlink" title="哈希分布"></a>哈希分布</h5><ul><li>节点取余分区</li><li>一致性哈希分区</li><li>虚拟槽分区</li></ul><h6 id="节点取余分区：hash-key-nodes"><a href="#节点取余分区：hash-key-nodes" class="headerlink" title="节点取余分区：hash(key)%nodes"></a>节点取余分区：hash(key)%nodes</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/6.png" alt="3c971b0ea421c5bcf6de3019e083ec1f.png"></p><ul><li>多倍扩容<br><img src="/passages/Tools/Redis/Redis-Cluster/7.png" alt="7e40b1dc4d18e1a4c93aece969d07f83.png"></li><li>客户端分片：哈希+取余</li><li>节点伸缩：数据节点关系变化，导致数据迁移</li><li>迁移数量和添加节点数量有关：建议翻倍扩容</li></ul><h6 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/8.png" alt="0184808c809945b27a22cf3f71d55dfa.png"></p><ul><li>扩容<br><img src="/passages/Tools/Redis/Redis-Cluster/9.png" alt="99dfddd38e209c0715b3b7b02b015fc5.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/10.png" alt="483882f7e012729b7cd38d3497fbc075.png"></li><li>客户端分片：哈希+顺时针（优化取余）</li><li>节点伸缩：只影响邻近节点，但是还是有数据迁移</li><li>翻倍伸缩：保证最小迁移数据和负载均衡</li></ul><h6 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h6><ul><li>预设虚拟槽：每个槽映射一个数据子集，一般比节点数大</li><li>良好的哈希函数：例如CRC16</li><li>服务端管理节点、槽、数据：例如Redis Cluster</li></ul><p><img src="/passages/Tools/Redis/Redis-Cluster/11.png" alt="f11e258b82e7b93119db245139673ad6.png"></p><h4 id="搭建集群-基本架构"><a href="#搭建集群-基本架构" class="headerlink" title="搭建集群-基本架构"></a>搭建集群-基本架构</h4><h5 id="单机架构"><a href="#单机架构" class="headerlink" title="单机架构"></a>单机架构</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/12.png" alt="7cea22b8436e6b97c3af6970c49b9a8b.png"></p><h5 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/13.png" alt="77f477c5198406c962c9157ef1b04201.png"></p><h5 id="Redis-Cluster架构"><a href="#Redis-Cluster架构" class="headerlink" title="Redis Cluster架构"></a>Redis Cluster架构</h5><ol><li>节点</li><li>meet</li><li>指派槽</li><li>复制</li></ol><h6 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h6><p>cluster-enabled yes</p><h6 id="meet"><a href="#meet" class="headerlink" title="meet"></a>meet</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/14.png" alt="40b9c1438bc5c1af38eba3defee243b8.png"><br>所有节点共享消息</p><h6 id="指派槽"><a href="#指派槽" class="headerlink" title="指派槽"></a>指派槽</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/15.png" alt="3fcd3f76bf756d7f3f26a83d39489853.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/16.png" alt="f207190c4b92c65143b1f9060cb588d1.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/17.png" alt="3b2333adba337aa7f62de8a658fc54dc.png"></p><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ol><li>复制</li><li>高可用</li><li>分片</li></ol><h5 id="Redis-Cluster安装"><a href="#Redis-Cluster安装" class="headerlink" title="Redis Cluster安装"></a>Redis Cluster安装</h5><ol><li>原生命令安装</li><li>官方工具安装</li></ol><h5 id="原生命令安装-理解架构"><a href="#原生命令安装-理解架构" class="headerlink" title="原生命令安装-理解架构"></a>原生命令安装-理解架构</h5><ol><li>配置开启节点<br><img src="/passages/Tools/Redis/Redis-Cluster/18.png" alt="46bc9667ffe4340debe83e3dab6a3bfa.png"></li><li><p>meet<br><strong><em>cluster meet ip port</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7003</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7004</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br></pre></td></tr></table></figure></li><li><p>Cluster节点主要配置<br><img src="/passages/Tools/Redis/Redis-Cluster/19.png" alt="6eb486f5073ba04e27170b995a964e4c.png"></p></li><li><p>指派槽<br><strong><em>cluster addslots slot [slot …]</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7000 cluster addslots &#123;0..5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7001 cluster addslots &#123;5462..10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7002 cluster addslots &#123;10923..16383&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置主从<br><strong><em>cluster replicate node-id</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 7003 cluster replicate $&#123;node-id-7000&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7004 cluster replicate $&#123;node-id-7001&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 7005 cluster replicate $&#123;node-id-7002&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="官方工具Ruby安装"><a href="#官方工具Ruby安装" class="headerlink" title="官方工具Ruby安装"></a>官方工具Ruby安装</h5><ol><li>下载、编译、安装Ruby</li><li>安装rubygem redis</li><li>安装redis-trib.rb</li></ol><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><strong><em>使用redis-trib.rb create 或者 redis-cli create 命令</em></strong><br><strong><em>可视化部署</em></strong></p><h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><ul><li>伸缩原理</li><li>扩容集群</li><li>缩容集群</li></ul><h5 id="伸缩原理"><a href="#伸缩原理" class="headerlink" title="伸缩原理"></a>伸缩原理</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/20.png" alt="2b9b1ab91dde67c5e6225e7c762730ed.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/21.png" alt="e69b5d77ba31351907bbb4fd4ddfa0e9.png"><br><strong><em>集群伸缩=槽和数据在节点之间的移动</em></strong></p><h5 id="扩容集群"><a href="#扩容集群" class="headerlink" title="扩容集群"></a>扩容集群</h5><ul><li>准备新节点</li><li>加入集群</li><li>迁移槽和数据</li></ul><h6 id="准备新节点"><a href="#准备新节点" class="headerlink" title="准备新节点"></a>准备新节点</h6><p><strong><em>新节点：</em></strong></p><ul><li>集群模式</li><li>配置和其他节点同意</li><li>启动后是孤儿节点<br><img src="/passages/Tools/Redis/Redis-Cluster/22.png" alt="6870c3b54484f8fac199bd97834055bb.png"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6385.conf</span><br><span class="line">redis-server conf/redis-6386.conf</span><br></pre></td></tr></table></figure></li></ul><h6 id="加入集群"><a href="#加入集群" class="headerlink" title="加入集群"></a>加入集群</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379 &gt; cluster meet 127.0.0.1 6385</span><br><span class="line">127.0.0.1:6379 &gt; cluster meet 127.0.0.1 6386</span><br></pre></td></tr></table></figure><p><img src="/passages/Tools/Redis/Redis-Cluster/23.png" alt="8bfbd164c3f45cd55cc976ea7e3d7fe5.png"><br><strong><em>作用</em></strong></p><ul><li>为他迁移槽和数据实现扩容</li><li>作为从节点负责故障转移<br><strong><em>redis-trib.rb</em></strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb add-node new_host:new_port existing_hos:existing_port --slave --master-id &lt;arg&gt;</span><br><span class="line">redis-trib.rb add-node 127.0.0.1:7006 127.0.0.1:7000</span><br><span class="line">//建议使用redis-trib.rb能够避免新节点已经加入了其他集群，造成故障</span><br><span class="line">//新版本使用redis-cli --cluster add-node</span><br></pre></td></tr></table></figure></li></ul><h6 id="迁移槽和数据"><a href="#迁移槽和数据" class="headerlink" title="迁移槽和数据"></a>迁移槽和数据</h6><ul><li><p>槽迁移计划</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//新版本使用redis-cli --cluster reshard</span><br></pre></td></tr></table></figure></li><li><p>迁移数据</p></li><li>添加从节点</li></ul><ol><li>槽迁移计划<br><img src="/passages/Tools/Redis/Redis-Cluster/24.png" alt="57e080461f9bd9653acd5e9e5b114fbf.png"></li><li>迁移数据</li><li>对目标节点发送：cluster setslot {slot} importing {sourceNodeId} 命令，让目标节点准备导入槽的数据。</li><li>对源节点发送：cluster setslot {slot} migrating {targetNodeId} 命令，让源节点准备迁出槽的数据。</li><li>源节点循环执行cluster getkeysinslot {slot} {count} 命令，每次获取count个属于槽的键。</li><li>在源节点上执行migrate {targetIp} {targetPort} key 0 {timeout} 命令把指定key迁移。</li><li>重复执行步骤3~4知道槽下所有的键数据迁移到目标节点。</li><li>向集群内所有主节点发送cluster setslot {slot} node {targetNodeId} 命令，通知槽分配给目标节点。<br><img src="/passages/Tools/Redis/Redis-Cluster/25.png" alt="787e5aad38bbebf6c1160f252da0b217.png"></li></ol><h5 id="收缩集群"><a href="#收缩集群" class="headerlink" title="收缩集群"></a>收缩集群</h5><ol><li>下线迁移槽</li><li>忘记节点</li><li>关闭节点</li></ol><p><img src="/passages/Tools/Redis/Redis-Cluster/26.png" alt="5e50a73ab51465553805ee587f8f1f7f.png"></p><h6 id="下线槽"><a href="#下线槽" class="headerlink" title="下线槽"></a>下线槽</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/27.png" alt="9a51944a3c2a9b8547b8e83bb31b024e.png"></p><h6 id="忘记槽"><a href="#忘记槽" class="headerlink" title="忘记槽"></a>忘记槽</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli &gt; cluster forget &#123;downNodeId&#125;</span><br><span class="line"></span><br><span class="line">del-node</span><br></pre></td></tr></table></figure><p><img src="/passages/Tools/Redis/Redis-Cluster/28.png" alt="7510cdb477a9634e693f9268c0ee7600.png"></p><h4 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h4><ul><li>moved重定向</li><li>ask重定向</li><li>smart客户端</li></ul><h5 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/29.png" alt="67b02da18c72042945d3edec00c5a3fe.png"></p><h6 id="槽命中"><a href="#槽命中" class="headerlink" title="槽命中"></a>槽命中</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/30.png" alt="345f51553dcc8ccd8f9c96b01218b85b.png"></p><h6 id="槽不命中：moved异常"><a href="#槽不命中：moved异常" class="headerlink" title="槽不命中：moved异常"></a>槽不命中：moved异常</h6><p><img src="/passages/Tools/Redis/Redis-Cluster/31.png" alt="85468a9c664a7b306a8cb57c63f5a81d.png"></p><h5 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h5><p><img src="/passages/Tools/Redis/Redis-Cluster/32.png" alt="67971de02f266bbf1e0abe620d99b613.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/33.png" alt="e8351e4f9651c35bd91b76ff3db9ca32.png"></p><h5 id="moved和ask"><a href="#moved和ask" class="headerlink" title="moved和ask"></a>moved和ask</h5><ul><li>两者都是客户端重定向</li><li>moved：槽已经确定迁移</li><li>ask：槽还在迁移中<h5 id="smart客户端"><a href="#smart客户端" class="headerlink" title="smart客户端"></a>smart客户端</h5></li><li>smart客户端原理</li><li>smart客户端使用：JedisCluster</li></ul><h6 id="smart客户端原理：追求性能"><a href="#smart客户端原理：追求性能" class="headerlink" title="smart客户端原理：追求性能"></a>smart客户端原理：追求性能</h6><ol><li>从集群中选一个可运行节点，使用cluster slots初始化槽和节点映射。</li><li>将cluster slots的结果映射到本地，为每个节点创建JedisPool。</li><li>准备执行命令。</li></ol><p><strong><em>执行命令</em></strong><br><img src="/passages/Tools/Redis/Redis-Cluster/34.png" alt="09d50d6bfc47b244e31e2ebec0d94a11.png"></p><h6 id="smart客户端使用：JedisCluster"><a href="#smart客户端使用：JedisCluster" class="headerlink" title="smart客户端使用：JedisCluster"></a>smart客户端使用：JedisCluster</h6><p><strong><em>JedisCluster基本使用</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt; nodeList = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST1, PORT1));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST2, PORT2));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST3, PORT3));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST4, PORT4));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST5, PORT5));</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(HOST6, PORT6));</span><br><span class="line">JedisCluster redisCluster = <span class="keyword">new</span> JedisCluster(nodeList, timeout, poolConfig);</span><br><span class="line">redisCluster.command...</span><br></pre></td></tr></table></figure></p><p><strong>使用技巧</strong></p><ol><li>单例：内置了所有节点的连接池</li><li>无需手动借还连接池</li><li>合理设置commons-pool<br><strong><em>整合spring</em></strong><br><a href="https://blog.csdn.net/u010199866/article/details/80705797" target="_blank" rel="noopener">springBoot整合redisCluster(redis集群)模式</a><br>注意搭建集群时ip的配置，避免整合客户端时连接失败。<br><strong><em>多节点命令实现</em></strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, JedisPool&gt; jedisPoolMap = jedisCluster.getClusterNodes();</span><br><span class="line">for (Entry&lt;String, JedisPool&gt; entry : jedisPoolMap.entrySet())&#123;</span><br><span class="line">    //获取每个节点的Jedis连接</span><br><span class="line">    Jedis jedis = entry.getValue().getResource();</span><br><span class="line">    //只删除主节点数据</span><br><span class="line">    if(!isMaster(jedis))&#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line">    //finally close</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong><em>批量命令实现</em></strong><br>mget mset 必须在一个槽上</p><ul><li>四种批量优化的方法</li></ul><ol><li><p>串行mget<br><img src="/passages/Tools/Redis/Redis-Cluster/35.png" alt="8665d2b02476093bf46b133e0bd72b7c.png"></p></li><li><p>串行IO<br><img src="/passages/Tools/Redis/Redis-Cluster/36.png" alt="bb8c1707302803657c804c5dad42cf2d.png"></p></li><li><p>并行IO<br><img src="/passages/Tools/Redis/Redis-Cluster/37.png" alt="9238ec76455dc756c83673112b8d1711.png"></p></li><li><p>hash_tag<br><img src="/passages/Tools/Redis/Redis-Cluster/38.png" alt="d1fb2631aafff0c0e5ec6e6deca4cad9.png"></p></li></ol><ul><li>四种方案优缺点分析</li></ul><table><thead><tr><th>方案</th><th>优点</th><th>缺点</th><th>网络IO</th></tr></thead><tbody><tr><td>串行mget</td><td>编程简单、少量keys满足需求</td><td>大量keys请求延迟严重</td><td>O(keys)</td></tr><tr><td>串行IO</td><td>编程简单、少量节点满足需求</td><td>大量node延迟严重</td><td>O(nodes)</td></tr><tr><td>并行IO</td><td>利用并行特性、延迟取决于最慢的节点</td><td>编程复杂、超时定位问题难</td><td>O(max_slow(node))</td></tr><tr><td>hash_tag</td><td>性能最高</td><td>读写增加tag维护成本、tag分布易出现数据倾斜</td><td>O(1)</td></tr></tbody></table><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h5><ul><li>通过ping/pong消息实现故障发现：不需要sentinel</li><li>主观下线/客观下线<br><img src="/passages/Tools/Redis/Redis-Cluster/39.png" alt="c1170013554b6c412c5933afbd2ee10c.png"><br><img src="/passages/Tools/Redis/Redis-Cluster/40.png" alt="06658900bd791aeed9508206887d0b7a.png"></li><li>尝试客观下线<br><img src="/passages/Tools/Redis/Redis-Cluster/41.png" alt="a4c428dc4c692a0f78d605dbc631e621.png"></li></ul><ol><li>通知集群内所有节点标记故障节点为客观下线</li><li>通知故障节点的从节点触发故障转移流程</li></ol><h5 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h5><ul><li>资格检查</li></ul><ol><li>每个从节点检查与故障主节点的断线时间</li><li>超过cluster-node-timeout * cluster-slave-validity-factor取消资格</li><li>cluster-slave-validity-factor：默认是10</li></ol><ul><li><p>准备选举时间<br><img src="/passages/Tools/Redis/Redis-Cluster/42.png" alt="9d1680d94e31b8689c2d78d5f1ea0a14.png"></p></li><li><p>选举投票<br><img src="/passages/Tools/Redis/Redis-Cluster/43.png" alt="a769e29410b63a32b2395076ff22f77f.png"></p></li><li><p>替换主节点</p></li></ul><ol><li>当前从节点取消复制变为主节点。（slaveof no one）</li><li>执行clusterDelSlot撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽分配给自己。</li><li>向集群广播自己的pong消息，表明已经替换了故障从节点。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel开发运维常见问题</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel开发运维常见问题/</id>
    <published>2019-02-28T03:04:43.000Z</published>
    <updated>2019-02-28T03:05:29.646Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="常见开发运维问题"><a href="#常见开发运维问题" class="headerlink" title="常见开发运维问题"></a>常见开发运维问题</h3><ul><li>节点运维</li><li>高可用读写分离</li></ul><h4 id="节点运维"><a href="#节点运维" class="headerlink" title="节点运维"></a>节点运维</h4><h5 id="节点上线和下线"><a href="#节点上线和下线" class="headerlink" title="节点上线和下线"></a>节点上线和下线</h5><ul><li>主节点</li><li>从节点</li><li>sentinel节点</li></ul><h5 id="节点下线"><a href="#节点下线" class="headerlink" title="节点下线"></a>节点下线</h5><p>机器下线：例如过保等情况<br>机器性能不足：例如CPU、内存、硬盘、网络等<br>节点自身故障：例如服务不稳定等</p><p><strong>主节点：</strong><br>sentinel failover <mastername><br><img src="/passages/Tools/Redis/Redis-Sentinel开发运维常见问题/1.png" alt="2d135bfe7d8509817883a7e61325dad2.png"><br><strong>从节点：</strong><br>临时下线还是永久下线，例如是否做一些清理工作，但是要考虑读写分离的情况。<br><strong>Sentinel节点：</strong><br>同上</mastername></p><h5 id="节点上线"><a href="#节点上线" class="headerlink" title="节点上线"></a>节点上线</h5><p><strong>主节点：</strong><br>sentinel failover进行替换<br><strong>从节点：</strong><br>slaveof即可，sentinel节点可以感知<br><strong>sentinel节点:</strong><br>参考其他sentinel节点启动即可</p><h4 id="高可用读写分离"><a href="#高可用读写分离" class="headerlink" title="高可用读写分离"></a>高可用读写分离</h4><h5 id="从节点的作用"><a href="#从节点的作用" class="headerlink" title="从节点的作用"></a>从节点的作用</h5><ol><li>副本：高可用的基础</li><li>扩展：读能力<br><img src="/passages/Tools/Redis/Redis-Sentinel开发运维常见问题/2.png" alt="47dd3eb3706f6ecf7dba8321ab6193f1.png"><h5 id="三个“消息”"><a href="#三个“消息”" class="headerlink" title="三个“消息”"></a>三个“消息”</h5></li></ol><ul><li>+switch-master：切换主节点（从节点晋升主节点）</li><li>+convert-to-slave：切换从节点（原主节点降为从节点）</li><li>+sdown：主观下线<br><img src="/passages/Tools/Redis/Redis-Sentinel开发运维常见问题/3.png" alt="a444cd9c93be9b3a7594d80b3a041b1f.png"></li></ul><h3 id="Redis-Sentinel总结"><a href="#Redis-Sentinel总结" class="headerlink" title="Redis Sentinel总结"></a>Redis Sentinel总结</h3><ul><li>Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</li><li>Redis Sentinel从Redis2.8版本开始才正式生产可用，之前版本生产不可用。</li><li>尽可能在不同物理机上部署Redis Sentinel所有节点。</li><li>Redis Sentinel中的Sentinel节点个数应该为大于等于3且最好为奇数。</li><li>Redis Sentinel中的数据节点与普通数据节点没有区别。</li><li>客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理。</li><li>Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控。</li><li>Redis Sentinel在对节点做失败判定时分为主观下线和客观下线。</li><li>看懂Redis Sentinel故障转移日志对于Redis Sentinel以及问题排查非常有帮助。</li><li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis-Sentinel/</id>
    <published>2019-02-28T03:01:09.000Z</published>
    <updated>2019-02-28T03:04:04.946Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><ul><li>主从复制高可用</li><li>架构说明</li><li>安装配置</li><li>客户端连接</li><li>实现原理</li><li>常见开发运维问题</li></ul><h4 id="主从复制高可用"><a href="#主从复制高可用" class="headerlink" title="主从复制高可用"></a>主从复制高可用</h4><h5 id="主从复制问题"><a href="#主从复制问题" class="headerlink" title="主从复制问题"></a>主从复制问题</h5><ol><li>手动故障转移</li><li>写能力和存储能力受限</li></ol><h4 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h4><p><img src="/passages/Tools/Redis/Redis-Sentinel/1.png" alt="dec6b0131c075e46e81c08e69e7ad546.png"></p><h5 id="Redis-Sentinel故障转移"><a href="#Redis-Sentinel故障转移" class="headerlink" title="Redis Sentinel故障转移"></a>Redis Sentinel故障转移</h5><ol><li>多个sentinel发现并确认master有问题</li><li>选举出一个sentinel作为领导</li><li>选出一个slave作为master</li><li>通知其余slave称为新的master的slave</li><li>通知客户端主从变化</li><li>等待老的master复活称为新master的slave</li></ol><h5 id="一套sentinel可以控制多套主从架构"><a href="#一套sentinel可以控制多套主从架构" class="headerlink" title="一套sentinel可以控制多套主从架构"></a>一套sentinel可以控制多套主从架构</h5><p><img src="/passages/Tools/Redis/Redis-Sentinel/2.png" alt="1fbaea06934c0eebefd05ece28dffa1c.png"></p><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><ol><li>配置开启主从节点</li><li>配置开启sentinel监控主节点。（sentinel是特殊的redis）</li><li>多机器</li><li>详细配置节点<br><img src="/passages/Tools/Redis/Redis-Sentinel/3.png" alt="f9171e3ee61eae4856e05e8d385e44ba.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/4.png" alt="fdd7876b54a3e003f7825b85a027e5bf.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/5.png" alt="eaf8e1edf261a2d1639689bd818b7c57.png"></li></ol><h4 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h4><ol><li>请求响应流程</li><li>Jedis</li></ol><h5 id="客户端实现基本原理"><a href="#客户端实现基本原理" class="headerlink" title="客户端实现基本原理"></a>客户端实现基本原理</h5><p><img src="/passages/Tools/Redis/Redis-Sentinel/6.png" alt="c7147e6e273ae4bcd3e232313e45ffcb.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/7.png" alt="9caa6b8a4815622c394c355688b1af6f.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/8.png" alt="79ca56b0915e2ab9ab4cb1152374884f.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/9.png" alt="ab6ff8e856ae8a645143fa0d29dad4a6.png"></p><h5 id="客户端接入流程"><a href="#客户端接入流程" class="headerlink" title="客户端接入流程"></a>客户端接入流程</h5><ol><li>Sentinel地址集合</li><li>masterName</li><li>不是代理模式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinelSet, poolConfig, timeout);</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    jedis = redisSentinelPool.getResource();</span><br><span class="line">    <span class="comment">//jedis command</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    logger.error(e.getMessage(), e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><ol><li>客户端高可用观察</li><li>服务端日志分析：数据节点和sentinel节点</li></ol><h5 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h5><ol><li>每10秒每个sentinel对master和slave执行info</li></ol><ul><li>发现slave节点</li><li>确认主从关系</li></ul><ol start="2"><li>每2秒每个sentinel通过master节点的channel交换信息（pub/sub）（发布订阅）</li></ol><ul><li>通过<em>sentinel</em>:hello频道交互</li><li>交互对节点的“看法”和自身信息</li></ul><ol start="3"><li>每1秒每个sentinel对其他sentinel和redis执行ping</li></ol><ul><li>心跳检测</li><li>失败判定</li></ul><h5 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor <span class="tag">&lt;<span class="name">masterName</span>&gt;</span> <span class="tag">&lt;<span class="name">ip</span>&gt;</span> <span class="tag">&lt;<span class="name">port</span>&gt;</span> <span class="tag">&lt;<span class="name">quorum</span>&gt;</span></span><br><span class="line">sentinel monitor myMaster 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds <span class="tag">&lt;<span class="name">masterName</span>&gt;</span> <span class="tag">&lt;<span class="name">timeout</span>&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br></pre></td></tr></table></figure><ul><li>主观下线：每个sentinel节点对Redis节点失败的“偏见”</li><li>客观下线：所有sentinel节点对Redis节点失败的“达成共识”（超过quorum个统一）<br>sentinel is-master-down-by-addr</li></ul><h5 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h5><ul><li>原因：只有一个sentinel节点完成故障转移</li><li>选举：通过sentinel is-master-down-by-addr命令都希望成为领导者</li></ul><ol><li>每个做主观下线的Sentinel节点向其他Sentinel节点发送请求，要求将它设置为领导者。</li><li>收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令，那么将同意该请求，否则拒绝。</li><li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum，那么它将成为领导者。<br><img src="/passages/Tools/Redis/Redis-Sentinel/10.png" alt="5732dcef0b281a402cd5c4424ff57aa8.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/11.png" alt="2f1ac1cbacbeaa244d9f4212097de012.png"><br><img src="/passages/Tools/Redis/Redis-Sentinel/12.png" alt="a450d5154350ff823e3203e80b382c10.png"><h5 id="故障转移（sentinel领导者节点完成）"><a href="#故障转移（sentinel领导者节点完成）" class="headerlink" title="故障转移（sentinel领导者节点完成）"></a>故障转移（sentinel领导者节点完成）</h5></li><li>从slave节点中选出一个“合适的”节点作为新的master节点。</li><li>对上面的slave节点执行slaveof no one命令让其成为master节点。</li><li>向剩余的slave节点发送命令，让他们成为新的master节点和slave节点，复制规则和parallel-syncs参数有关。</li><li>更新对原来的master节点配置为slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。</li></ol><h5 id="选择“合适的”slave节点"><a href="#选择“合适的”slave节点" class="headerlink" title="选择“合适的”slave节点"></a>选择“合适的”slave节点</h5><ol><li>选择slave-priority（slave节点优先级）最高的slave节点，如果存在则返回，不存在则继续。</li><li>选择复制偏移量最大的slave节点（复制的最完整），如果存在则返回，不存在则继续。</li><li>选择runId最小的slave节点。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis复制的原理与优化</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis复制的原理与优化/</id>
    <published>2019-02-28T02:58:37.000Z</published>
    <updated>2019-02-28T03:00:47.278Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Redis复制的原理与优化"><a href="#Redis复制的原理与优化" class="headerlink" title="Redis复制的原理与优化"></a>Redis复制的原理与优化</h3><ul><li>什么是主从复制</li><li>复制的配置</li><li>全量复制和部分复制</li><li>故障处理</li><li>开发运维常见问题</li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><img src="/passages/Tools/Redis/Redis复制的原理与优化/1.png" alt="69e8afd2905e6c8d13f3e15d574f7c4d.png"><br><img src="/passages/Tools/Redis/Redis复制的原理与优化/2.png" alt="05feb9424f30235af132bcb04bf1f7d8.png"></p><h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ol><li>数据副本</li><li>扩展读性能</li></ol><h4 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h4><ol><li>一个master可以有多个slave</li><li>一个slave只能由一个master</li><li>数据流向是单向的，master到slave</li></ol><h4 id="主从复制的配置"><a href="#主从复制的配置" class="headerlink" title="主从复制的配置"></a>主从复制的配置</h4><h5 id="slaveof命令"><a href="#slaveof命令" class="headerlink" title="slaveof命令"></a>slaveof命令</h5><p><img src="/passages/Tools/Redis/Redis复制的原理与优化/3.png" alt="d00bcac56c9daf3ed24930a5d0640db9.png"><br><img src="/passages/Tools/Redis/Redis复制的原理与优化/4.png" alt="190889397b384b2cb834513ae2e8c3a6.png"></p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p><img src="/passages/Tools/Redis/Redis复制的原理与优化/5.png" alt="5f2e63472e32e59d5f18420fab39815a.png"></p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><table><thead><tr><th>方式</th><th>命令</th><th>配置</th></tr></thead><tbody><tr><td>优点</td><td>无需重启</td><td>统一配置</td></tr><tr><td>缺点</td><td>不便于管理</td><td>需要重启</td></tr></tbody></table><h4 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h4><h5 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h5><p><img src="/passages/Tools/Redis/Redis复制的原理与优化/6.png" alt="d60dc59ffa4a3deb0f70d053fa2d1c15.png"></p><h6 id="全量复制开销"><a href="#全量复制开销" class="headerlink" title="全量复制开销"></a>全量复制开销</h6><ol><li>bgsave时间</li><li>RDB文件网络传输时间</li><li>从节点清空数据时间</li><li>从节点加载RDB的时间</li><li>可能的AOF重写时间</li></ol><h5 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h5><p><img src="/passages/Tools/Redis/Redis复制的原理与优化/7.png" alt="6ed0da1cb42df940f146cc33bff4824e.png"></p><h4 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h4><h5 id="主从结构-故障转移"><a href="#主从结构-故障转移" class="headerlink" title="主从结构-故障转移"></a>主从结构-故障转移</h5><ol><li><p>slave宕掉<br><img src="/passages/Tools/Redis/Redis复制的原理与优化/8.png" alt="f03d3ce31e88baba53e460742455b2d7.png"></p></li><li><p>master宕掉<br><img src="/passages/Tools/Redis/Redis复制的原理与优化/9.png" alt="75036c1e22baa662598cb1f2084e8cd0.png"></p><h4 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h4></li><li>读写分离</li><li>主从配置不一致</li><li>规避全量复制</li><li>规避复制风暴<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5></li><li>读流量分摊到从节点<br><img src="/passages/Tools/Redis/Redis复制的原理与优化/10.png" alt="0fe73f93449fc78c74aa7139efb26fd0.png"></li><li>可能遇到问题：</li></ol><ul><li>复制数据延迟</li><li>读到过期数据</li><li>从节点故障<h5 id="配置不一致"><a href="#配置不一致" class="headerlink" title="配置不一致"></a>配置不一致</h5></li></ul><ol><li>例如maxmemory不一致：丢失数据</li><li>例如数据结构优化参数（例如hash-max-ziplist-entried）：内存不一致</li></ol><h5 id="规避全量复制"><a href="#规避全量复制" class="headerlink" title="规避全量复制"></a>规避全量复制</h5><ol><li>第一次全量复制</li></ol><ul><li>第一次不可避免</li><li>小主节点、低峰</li></ul><ol start="2"><li>节点运行ID不匹配</li></ol><ul><li>主节点重启（运行ID变化）</li><li>故障转移，例如哨兵或集群</li></ul><ol start="3"><li>复制积压缓冲区不足</li></ol><ul><li>网络中断，部分复制无法满足</li><li>增大复制缓冲区配置rel_backlog_size，网络“增强”</li></ul><h5 id="规避复制风暴"><a href="#规避复制风暴" class="headerlink" title="规避复制风暴"></a>规避复制风暴</h5><ol><li>单主节点复制风暴：<br>问题：主节点重启，多从节点复制<br>解决：更换复制拓扑</li><li>单机器复制风暴<br>问题：机器宕机后，大量全量复制<br>解决：主从节点分散多机器</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis开发运维常见问题</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis开发运维常见问题/</id>
    <published>2019-02-28T02:57:38.000Z</published>
    <updated>2019-02-28T02:58:19.201Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="开发运维常见问题"><a href="#开发运维常见问题" class="headerlink" title="开发运维常见问题"></a>开发运维常见问题</h3><h4 id="fork操作"><a href="#fork操作" class="headerlink" title="fork操作"></a>fork操作</h4><ol><li>同步操作</li><li>与内存量息息相关：内存越大，耗时越长（与机器类型有关）</li><li>info：latest_fork_usec<h5 id="改善fork"><a href="#改善fork" class="headerlink" title="改善fork"></a>改善fork</h5></li><li>优先使用物理机或者高效支持fork操作的虚拟化技术</li><li>控制Redis实例最大可用内存：maxmemory</li><li>合理配置Linux内存分配策略：vm.overcommit_memory=1</li><li>降低fork频率：例如放宽AOF重写自动触发时机，不必要的全量复制<h4 id="进程外开销"><a href="#进程外开销" class="headerlink" title="进程外开销"></a>进程外开销</h4><h5 id="子进程开销和优化"><a href="#子进程开销和优化" class="headerlink" title="子进程开销和优化"></a>子进程开销和优化</h5></li><li>CPU：</li></ol><ul><li>开销：RDB和AOF文件生成，属于CPU密集型</li><li>优化：不做CPU绑定，不和CPU密集型部署</li></ul><ol start="2"><li>内存：</li></ol><ul><li>开销：fork内存开销，copy-on-write</li><li>优化：echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</li></ul><ol start="3"><li>硬盘</li></ol><ul><li>开销：AOF和RDB文件写入，可以结合iostat，iotop分析</li><li>优化：</li></ul><ol><li>不要和高硬盘负载服务部署在一起：存储服务、消息队列等</li><li>no-appendfsync-on-rewrite=yes</li><li>根据写入量决定磁盘类型：例如ssd</li><li>单机多实例持久化文件目录可以考虑分盘<h4 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h4><img src="/passages/Tools/Redis/Redis开发运维常见问题/1.png" alt="56cad869cc787660563d0afa49d0b83a.png"></li></ol><h4 id="单机多实例部署"><a href="#单机多实例部署" class="headerlink" title="单机多实例部署"></a>单机多实例部署</h4>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化的取舍和选择</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%8F%96%E8%88%8D%E5%92%8C%E9%80%89%E6%8B%A9/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis持久化的取舍和选择/</id>
    <published>2019-02-28T02:53:41.000Z</published>
    <updated>2019-02-28T02:57:05.018Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Redis持久化的取舍和选择"><a href="#Redis持久化的取舍和选择" class="headerlink" title="Redis持久化的取舍和选择"></a>Redis持久化的取舍和选择</h3><ul><li>持久化的作用</li><li>RDB</li><li>AOF</li><li>RDB和AOF的抉择</li></ul><h4 id="持久化的作用"><a href="#持久化的作用" class="headerlink" title="持久化的作用"></a>持久化的作用</h4><ul><li>什么是持久化</li><li>持久化的实现方式<h5 id="什么是持久化"><a href="#什么是持久化" class="headerlink" title="什么是持久化"></a>什么是持久化</h5>redis所有数据保存在内存中，对数据的更新将异步地保存到磁盘上<h5 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h5></li></ul><ol><li>快照——MySql Dump、Redis RDB</li><li>写日志——MySql Binlog、Hbase HLog、Redis AOF</li></ol><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><ul><li>什么是RDB</li><li>触发机制—主要三种方式</li><li>触发机制—不容忽略方式</li><li>试验<h5 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h5><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/1.png" alt="35c4c7f02503d184327bd0213b6506c1.png"><h5 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h5></li></ul><ol><li>save命令<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/2.png" alt="9c18d0b0954d3798e4cb3b077ec9f6b7.png"><br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/3.png" alt="b4dd05cce67ddd4a45572eaf23a6d249.png"></li><li>bgsave<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/4.png" alt="be43b960a87a3f10c044e4f1afd298a0.png"></li><li>自动<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/5.png" alt="417ddff2f6a91b49b5ff1bbbefa6b783.png"></li></ol><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fork）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fork，消耗内存</td></tr></tbody></table><h5 id="不容忽略方式"><a href="#不容忽略方式" class="headerlink" title="不容忽略方式"></a>不容忽略方式</h5><ol><li>全量复制</li><li>debug reload</li><li>shutdown<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5></li><li>RDB是Redis内存到硬盘的快照，用于持久化</li><li>save通常会阻塞Redis</li><li>bgsave不会阻塞Redis，但是会fork新进程</li><li>save自动配置满足任一就会被执行</li><li>有些触发机制不容忽视</li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><ul><li>RDB现存问题</li><li>什么是AOF</li><li>AOF三种策略</li><li>AOF重写</li></ul><h5 id="RDB问题"><a href="#RDB问题" class="headerlink" title="RDB问题"></a>RDB问题</h5><ol><li>耗时、耗性能<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/6.png" alt="ebda1d272024a596a381c29781c53682.png"></li><li>不可控、丢失数据<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/7.png" alt="8d0d85046ffb92d05e6961ca0b802b45.png"></li></ol><h5 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h5><p><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/8.png" alt="image.png"><br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/9.png" alt="8a0280753c82c38c206677ae1d46e3a7.png"></p><h5 id="AOF的三种策略"><a href="#AOF的三种策略" class="headerlink" title="AOF的三种策略"></a>AOF的三种策略</h5><ol><li>always<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/10.png" alt="22165b3d499da7dfde6ae6167c11c40f.png"></li><li>everysec<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/11.png" alt="bc40bbe18ce0b132751e3b5617b28679.png"></li><li>no<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/12.png" alt="f2e8e815f3408e84796a966f6db56fd5.png"></li></ol><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次fsync 丢一秒数据</td><td>不用管</td></tr><tr><td>缺点</td><td>IO开销较大，一般的sata盘只有几百TPS</td><td>丢一秒数据</td><td>不可控</td></tr></tbody></table><h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/13.png" alt="953a7f1dfea538a97d5d20d835555d71.png"><br><strong>作用</strong></p><ul><li>减少硬盘占用量</li><li>加速恢复速度<h5 id="AOF重写实现两种方式"><a href="#AOF重写实现两种方式" class="headerlink" title="AOF重写实现两种方式"></a>AOF重写实现两种方式</h5></li><li>bgrewriteaof<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/14.png" alt="007105915d809402f3a88cc80640c678.png"></li><li>AOF重写配置<br><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/15.png" alt="0cf5968c43cfe83aebe54fdc21d7270c.png"><h5 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h5><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/16.png" alt="4614918af153520537a225c1c31d1d6b.png"><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><img src="/passages/Tools/Redis/Redis持久化的取舍和选择/17.png" alt="1faa03f0cf546230146e7cb9c40f2bd8.png"><h4 id="RDB与AOF的抉择"><a href="#RDB与AOF的抉择" class="headerlink" title="RDB与AOF的抉择"></a>RDB与AOF的抉择</h4></li></ul><table><thead><tr><th>命令</th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h5 id="RDB最佳策略"><a href="#RDB最佳策略" class="headerlink" title="RDB最佳策略"></a>RDB最佳策略</h5><ol><li>“关”</li><li>集中管理</li><li>主从，从开？</li></ol><h5 id="AOF最佳策略"><a href="#AOF最佳策略" class="headerlink" title="AOF最佳策略"></a>AOF最佳策略</h5><ol><li>“开”：缓存和存储</li><li>AOF重写集中管理</li><li>everysec</li></ol><h5 id="最佳策略"><a href="#最佳策略" class="headerlink" title="最佳策略"></a>最佳策略</h5><ol><li>小分片</li><li>缓存或者存储</li><li>监控（硬盘、内存、负载、网络）</li><li>足够的内存</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的功能</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E7%9A%84%E5%8A%9F%E8%83%BD/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis的功能/</id>
    <published>2019-02-28T02:50:24.000Z</published>
    <updated>2019-02-28T02:52:43.877Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><ul><li>生命周期</li><li>两个配置</li><li>三个命令</li><li>运维经验<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><img src="/passages/Tools/Redis/Redis的功能/1.png" alt="b0bfe9347adced510230b963d9cd23bb.png"><br>两点说明：<br>（1）慢查询发生在第三阶段<br>（2）客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素<h4 id="两个配置"><a href="#两个配置" class="headerlink" title="两个配置"></a>两个配置</h4><h5 id="slowlog-max-len"><a href="#slowlog-max-len" class="headerlink" title="slowlog-max-len"></a>slowlog-max-len</h5></li></ul><ol><li>先进先出队列</li><li>固定长度</li><li>保存在内存内<br><img src="/passages/Tools/Redis/Redis的功能/2.png" alt="77357fd9758a2e0c2d05788ad6de6088.png"><h5 id="slowlog-log-slower-than"><a href="#slowlog-log-slower-than" class="headerlink" title="slowlog-log-slower-than"></a>slowlog-log-slower-than</h5></li><li>慢查询阈值（单位：微秒）</li><li>slowlog-log-slower-than=0，记录所有命令</li><li>slowlog-log-slower-than&lt;0，不记录任何命令<h5 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h5></li><li>默认值</li></ol><ul><li>config get slowlog-max-len = 128</li><li>config get slowlog-log-slower-than = 10000</li></ul><ol start="2"><li>修改配置文件重启</li><li>动态配置</li></ol><ul><li>config set slowlog-max-len 1000</li><li>config set slowlog-log-slower-than 1000<h4 id="三个命令"><a href="#三个命令" class="headerlink" title="三个命令"></a>三个命令</h4></li></ul><ol><li>slowlog get [n]：获取慢查询队列</li><li>slowlog len：获取慢查询队列长度</li><li>slowlog reset：清空慢查询队列<h4 id="运维经验"><a href="#运维经验" class="headerlink" title="运维经验"></a>运维经验</h4></li><li>slowlog-max-len不要设置过大，默认10ms，通常设置1ms</li><li>slowlog-log-slower-than不要设置过小，通常设置1000左右</li><li>理解命令生命周期</li><li>定期持久化慢查询</li></ol><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><ul><li>什么是流水线</li><li>客户端实现</li><li>与原生操作对比</li><li>使用建议<h4 id="一次网络命令通信模型"><a href="#一次网络命令通信模型" class="headerlink" title="一次网络命令通信模型"></a>一次网络命令通信模型</h4><img src="/passages/Tools/Redis/Redis的功能/3.png" alt="image.png"><h4 id="批量网络命令通信模型"><a href="#批量网络命令通信模型" class="headerlink" title="批量网络命令通信模型"></a>批量网络命令通信模型</h4><img src="/passages/Tools/Redis/Redis的功能/4.png" alt="6090cac2e31229256de8afcc7d25818b.png"><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><img src="/passages/Tools/Redis/Redis的功能/5.png" alt="6ce4930a65838cc434eebffe20ab7250.png"><h5 id="流水线的作用"><a href="#流水线的作用" class="headerlink" title="流水线的作用"></a>流水线的作用</h5></li></ul><table><thead><tr><th>命令</th><th>N个命令操作</th><th>1次pipeline（n个命令）</th></tr></thead><tbody><tr><td>时间</td><td>n次网络+n次命令</td><td>1次网络+n次命令</td></tr><tr><td>数据量</td><td>1条命令</td><td>n条命令</td></tr></tbody></table><p><strong>两点注意</strong><br>**1. Redis的命令时间是微秒级别。</p><ol start="2"><li>pipeline每次条数要控制（网络）。**<h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4></li><li>注意每次pipeline携带数据量</li><li>pipeline每次只能作用在一个Redis节点上</li><li>M操作与pipeline区别</li></ol><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><ul><li>角色</li><li>模型</li><li>API</li><li>发布订阅和消息队列<br><img src="/passages/Tools/Redis/Redis的功能/6.png" alt="3e42dd122163d744699cd003624607f6.png"><br><img src="/passages/Tools/Redis/Redis的功能/7.png" alt="40da62412a27ac1cc0a21fc22d374d5a.png"><br><img src="/passages/Tools/Redis/Redis的功能/8.png" alt="05ce5546655de44c925eb4dcc67a870d.png"><br><img src="/passages/Tools/Redis/Redis的功能/9.png" alt="8668466891b92c86e2eb67084f9884ad.png"><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3></li><li>位图</li><li>相关命令</li><li>独立用户统计</li></ul><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><h3 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h3>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Jedis</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Jedis/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Jedis/</id>
    <published>2019-02-28T02:48:53.000Z</published>
    <updated>2019-02-28T02:50:38.511Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Jedis直连"><a href="#Jedis直连" class="headerlink" title="Jedis直连"></a>Jedis直连</h3><p><img src="/passages/Tools/Redis/Jedis/1.png" alt="c1edecbacaa2edf170185f8d8a019a62.png"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#1.生成一个Jedis对象，这个对象负责和指定Redis节点进行通信</span></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//#2.jedis执行set操作</span></span><br><span class="line">jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line"><span class="comment">//#3.jedis执行get操作，value="world"</span></span><br><span class="line">String value = jedis.get(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></p><p><strong><em>Jedis(String host, int port, int connectionTimeout, int soTimeout)</em></strong></p><ul><li>host：Redis节点的所在机器的IP</li><li>port：Redis节点的端口</li><li>connectionTimeout：客户端连接超时</li><li>soTimeout：客户端读写超时<h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><img src="/passages/Tools/Redis/Jedis/2.png" alt="724eb79a0570c01a80fe894836ea160f.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化Jedis连接池，通常来讲JedisPool是单例的。GenericObjectPoolConfig</span></span><br><span class="line">poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">JedisPool  jedisPool = <span class="keyword">new</span> JedisPool(poolConfig,<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1.从连接池获取jedis对象</span></span><br><span class="line">    jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//2.执行操作</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">null</span> != jedis)&#123;</span><br><span class="line">    <span class="comment">//如果使用JedisPool，close操作不是关闭连接，代表归还连接池</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>直连</td><td>简单方便、适用于少量长期连接的场景</td><td>存在每次新建/关闭TCP开销、资源无法控制，存在连接泄露的可能、Jedis对象线程不安全</td></tr><tr><td>连接池</td><td>Jedis预先生成，降低开销使用、连接池的形式保护和控制资源的使用</td><td>相对于直连，使用相对麻烦，尤其在资源的管理上需要很多参数来保证，一旦规划不合理也会出现问题</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>基本特性与基于LinuxZK命令行</title>
    <link href="http://kwin1113.github.io/passages/Tools/ZooKeeper/%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E4%B8%8E%E5%9F%BA%E4%BA%8ELinuxZK%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://kwin1113.github.io/passages/Tools/ZooKeeper/基本特性与基于LinuxZK命令行/</id>
    <published>2019-02-04T15:45:50.000Z</published>
    <updated>2019-02-04T16:56:19.849Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="zk常用命令行操作"><a href="#zk常用命令行操作" class="headerlink" title="zk常用命令行操作"></a>zk常用命令行操作</h3><ul><li>通过./zkCli.sh打开zk的客户端进行命令行后台</li><li>ls与ls2命令</li><li>get与stat命令</li><li>create命令</li><li>set命令</li><li>delete命令<h3 id="zk特性-session的基本原理"><a href="#zk特性-session的基本原理" class="headerlink" title="zk特性-session的基本原理"></a>zk特性-session的基本原理</h3></li><li>客户端和服务端之间的连接存在会话</li><li>每个会话都可以设置一个超时时间</li><li>心跳结束，session则过期</li><li>Session过期，则临时节点znode会被抛弃</li><li>心跳机制：客户端向服务端的ping包请求<h3 id="zk特性-watcher机制"><a href="#zk特性-watcher机制" class="headerlink" title="zk特性-watcher机制"></a>zk特性-watcher机制</h3></li><li>针对每个节点的操作，都会有一个监督者-&gt;watcher</li><li>当监控的某个对象（znode）发生了变化，则触发watcher事件</li><li>zk中的watcher是一次性的，触发后立即销毁</li><li>父节点，子节点增删改都能触发其watcher</li><li>针对不同类型的操作，触发的watcher事件也不同</li></ul><ol><li>（子）节点创建事件</li><li>（子）节点删除事件</li><li>（子）节点数据变化事件<h3 id="watcher命令行"><a href="#watcher命令行" class="headerlink" title="watcher命令行"></a>watcher命令行</h3></li></ol><ul><li>通过get path [watcher] 设置watcher</li><li>父节点增删改操作触发watcher</li><li>子节点增删改操作触发watcher<h3 id="watcher事件类型"><a href="#watcher事件类型" class="headerlink" title="watcher事件类型"></a>watcher事件类型</h3></li><li>创建父节点触发：NodeCreated</li><li>修改父节点数据触发：NodeDataChanged</li><li>删除父节点触发：NodeDeleted</li><li>ls为父节点设置watcher，创建子节点触发：NodeChildrenChanged</li><li>ls为父节点设置watcher，删除子节点触发：NodeChildrenChanged</li><li>ls为父节点设置watcher，修改子节点不触发事件<h3 id="使用watcher统一资源配置"><a href="#使用watcher统一资源配置" class="headerlink" title="使用watcher统一资源配置"></a>使用watcher统一资源配置</h3><img src="/passages/Tools/ZooKeeper/基本特性与基于LinuxZK命令行/1.png" alt="1e139a7309075333800889174e51abf6.png"><h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><h4 id="ACL（Access-Control-Lists）权限控制"><a href="#ACL（Access-Control-Lists）权限控制" class="headerlink" title="ACL（Access Control Lists）权限控制"></a>ACL（Access Control Lists）权限控制</h4></li><li>针对节点可以设置相关读写等权限，目的为了保障数据安全性</li><li>权限permissions可以指定不同的权限范围以及角色<h4 id="ACL命令行"><a href="#ACL命令行" class="headerlink" title="ACL命令行"></a>ACL命令行</h4></li><li>getAcl：获取某个节点的acl权限信息</li><li>setAcl：设置某个节点的acl权限信息</li><li>addauth：输入认证授权信息，注册时输入明文密码（登陆），但是在zk的系统中，密码是以加密的形式存在的</li></ul><h4 id="ACL的构成"><a href="#ACL的构成" class="headerlink" title="ACL的构成"></a>ACL的构成</h4><ul><li>zk的acl通过[scheme:id:permissions]来构成权限列表</li><li>scheme：代表采用的某种权限机制</li><li>id：代表允许访问的用户</li><li>permissions：权限组合字符串<h5 id="scheme"><a href="#scheme" class="headerlink" title="scheme"></a>scheme</h5></li><li>world：world下只有一个id，即只有一个用户，也就是anyone，那么组合的写法就是world:anyone:[permissions]</li><li>auth：代表认证登陆，需要注册用户有权限就可以，形式为auth:user:password:[permissions]</li><li>digest：需要对密码加密才能访问，组合形式为diges:username:BASE64(SHA1(password)):[permissions]</li><li>简而言之，auth和digest的区别就是，前者明文，后者密文，setAcl /path auth:lee:lee:cdrwa与setAcl /path digest:lee:BASE64(SHA1(password))cdrwa是等价的，在通过addauth digest lee:lee后都能操作指定节点的权限</li><li>ip：当设置为ip指定的ip地址，此时限制ip进行访问，比如ip：192.168.1.1:[permissions]</li><li><p>super：代表超级管理员，拥有所有的权限</p><h5 id="permissions"><a href="#permissions" class="headerlink" title="permissions"></a>permissions</h5><p>权限字符串缩写 crdwa</p></li><li><p>CREATE：创建子节点</p></li><li>READ：获取节点/子节点</li><li>DELETE：删除子节点</li><li>WRITE：设置节点数据</li><li>ADMIN：设置权限<h3 id="ZooKeeper集群搭建"><a href="#ZooKeeper集群搭建" class="headerlink" title="ZooKeeper集群搭建"></a>ZooKeeper集群搭建</h3></li><li>zk集群，主从节点，心跳机制（选举模式）<br><img src="/passages/Tools/ZooKeeper/基本特性与基于LinuxZK命令行/2.png" alt="2482ccce2dea05f2325c2f8a19035199.png"><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4></li><li>配置数据文件 myid 1/2/3 对应 server.1/2/3</li><li>通过./zkCli.sh -server [ip]:[port] 检测集群是否配置成功<h4 id="真实环境搭建"><a href="#真实环境搭建" class="headerlink" title="真实环境搭建"></a>真实环境搭建</h4></li><li>环境变量的配置，ip配置不同，端口号可以相同</li><li>集群测试，选举测试</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="ZooKeeper" scheme="http://kwin1113.github.io/categories/Tools/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="http://kwin1113.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper简介</title>
    <link href="http://kwin1113.github.io/passages/Tools/ZooKeeper/ZooKeeper%E7%AE%80%E4%BB%8B/"/>
    <id>http://kwin1113.github.io/passages/Tools/ZooKeeper/ZooKeeper简介/</id>
    <published>2019-02-04T15:45:21.000Z</published>
    <updated>2019-02-04T16:56:15.462Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ul><li>中间件，提供协调服务</li><li>作用于分布式系统，发挥其优势，可以为大数据服务</li><li>支持java，提供java和c语言api<h3 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h3></li><li>很多台计算机组成一个整体，一个整体一致对外并且处理同一请求</li><li>内部的每台计算机都可以相互通信（rest/rpc）</li><li>客户端到服务端的一次请求到相应结束会历经多台计算机<h4 id="分布式系统图解"><a href="#分布式系统图解" class="headerlink" title="分布式系统图解"></a>分布式系统图解</h4><img src="/passages/Tools/ZooKeeper/ZooKeeper简介/1.png" alt="bdde75723bdd7ed6656afbe94c0fcfff.png"><br><img src="/passages/Tools/ZooKeeper/ZooKeeper简介/2.png" alt="fae191b0a38debc86523abf122200ced.png"><h3 id="ZooKeeper的特性"><a href="#ZooKeeper的特性" class="headerlink" title="ZooKeeper的特性"></a>ZooKeeper的特性</h3></li><li>一致性：数据一致性，数据按照顺序分批入库</li><li>原子性：事务要么成功，要么失败，不会局部化</li><li>单一视图：客户端连接集群中的任一zk节点，数据都是一致的</li><li>可靠性：每次对zk的操作状态都会保存在服务端</li><li>实时性：客户端可以读取到zk服务端的最新数据<h3 id="zoo-cfg配置"><a href="#zoo-cfg配置" class="headerlink" title="zoo.cfg配置"></a>zoo.cfg配置</h3></li><li>tickTime：用于计算的事件单元。比如session超时：N*tickTime。</li><li>initLimit：用于集群，允许从节点连接并同步到master节点的初始化连接事件，以tickTime的倍数表示。</li><li>syncLimit：用于集群，master主节点与从节点之间发送消息，请求和应答事件长度。（心跳机制）</li><li>dataDir：数据目录（必须配置。</li><li>dataLogDir：日志目录，如果不配置会和dataDir公用</li><li><p>clientPort：连接服务器的端口，默认2181</p><h3 id="ZooKeeper基本数据模型"><a href="#ZooKeeper基本数据模型" class="headerlink" title="ZooKeeper基本数据模型"></a>ZooKeeper基本数据模型</h3><p><img src="/passages/Tools/ZooKeeper/ZooKeeper简介/3.png" alt="6d07cfe8d023be77e2d75f87ef484a05.png"><br><img src="/passages/Tools/ZooKeeper/ZooKeeper简介/4.png" alt="5ec00d5550b0327403e830f0c93de6b5.png"></p></li><li><p>zk的数据模型也可以理解为linux/unix的文件目录：/usr/local/…</p></li><li>每一个节点都称之为znode，它可以有子节点，也可以有数据</li><li>每个节点分为临时节点和永久节点，临时节点在客户端断开后消失</li><li>每个zk节点都有各自的版本号，可以通过命令行来显示节点信息</li><li>每当节点数据发生变化，那么节点的版本号会累加（乐观锁）</li><li>删除/修改过时节点，版本号不匹配则会报错</li><li>每个zk节点存储的数据不宜过大，几K即可</li><li>节点可以设置权限acl，可以通过权限来限制用户访问<h3 id="ZooKeeper数据模型基本操作"><a href="#ZooKeeper数据模型基本操作" class="headerlink" title="ZooKeeper数据模型基本操作"></a>ZooKeeper数据模型基本操作</h3></li><li>客户端连接</li><li>查看znode结构</li><li>关闭客户端连接<h3 id="zk的作用体现"><a href="#zk的作用体现" class="headerlink" title="zk的作用体现"></a>zk的作用体现</h3></li><li>master节点选举，主节点挂了以后，从节点就会接收工作，并且保证这个节点是唯一的，这也是所谓首脑模式，从而保证我们的集群是高可用的。</li><li>统一配置文件管理，即只需要部署一台服务器，则可以把相同的配置文件同步更新到其他所有服务器，此操作在云计算中用的特别多</li><li>发布与订阅，类似消息队列MQ（amq，rmq…），dubbo发布者把数据存到znode上，订阅者会读取这个数据</li><li>提供分布式锁，分布式环境中不同进程之间争夺资源，类似于多线程中的锁</li><li>集群管理，集群中保证数据的强一致性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="ZooKeeper" scheme="http://kwin1113.github.io/categories/Tools/ZooKeeper/"/>
    
    
      <category term="ZooKeeper" scheme="http://kwin1113.github.io/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat容器等级</title>
    <link href="http://kwin1113.github.io/passages/Tools/Servlet/Tomcat%E5%AE%B9%E5%99%A8%E7%AD%89%E7%BA%A7/"/>
    <id>http://kwin1113.github.io/passages/Tools/Servlet/Tomcat容器等级/</id>
    <published>2019-02-04T15:44:33.000Z</published>
    <updated>2019-02-04T16:56:05.842Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><p>Tomcate的容器分为四个等级，Servlet的容器管理Context容器，一个Context对应一个Web工程!<br><a href="1.png">72b9432000240ce54a5302f40c0379da.png</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Servlet" scheme="http://kwin1113.github.io/categories/Tools/Servlet/"/>
    
    
      <category term="Servlet" scheme="http://kwin1113.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://kwin1113.github.io/passages/Tools/Servlet/Servlet/"/>
    <id>http://kwin1113.github.io/passages/Tools/Servlet/Servlet/</id>
    <published>2019-02-04T15:44:10.000Z</published>
    <updated>2019-02-04T16:56:02.381Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Servlet是什么？"><a href="#Servlet是什么？" class="headerlink" title="Servlet是什么？"></a>Servlet是什么？</h3><p>&emsp;&emsp;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p><h3 id="Servlet任务"><a href="#Servlet任务" class="headerlink" title="Servlet任务"></a>Servlet任务</h3><p>Servlet 执行以下主要任务：</p><ul><li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li><li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li><li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li><li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li><li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。<h3 id="Servlet包"><a href="#Servlet包" class="headerlink" title="Servlet包"></a>Servlet包</h3>&emsp;&emsp;Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。<h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</li><li>Servlet 通过调用 init () 方法进行初始化。</li><li>Servlet 调用 service() 方法来处理客户端的请求。</li><li>Servlet 通过调用 destroy() 方法终止（结束）。</li><li>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。<h3 id="编写一个Servlet"><a href="#编写一个Servlet" class="headerlink" title="编写一个Servlet"></a>编写一个Servlet</h3></li></ul><p>1.继承HttpServlet<br>2.重写doGet()或doPost()<br>3.在web.xml中注册Servlet</p><p>MyEclipseb编写Servlet<br>1.src -&gt; new -&gt; Servlet<br>2.重写doGet()或doPost()<br>3.部署运行</p><h3 id="Servlet容器装载Servlet"><a href="#Servlet容器装载Servlet" class="headerlink" title="Servlet容器装载Servlet"></a>Servlet容器装载Servlet</h3><p>在下列时刻Servlet容器装载Servlet：<br>Servlet容器启动时自动装载某些Servlet，实现它只需要在web.xml文件中的<servlet></servlet>之间添加如下代码：</p><p><load-on-startup>1</load-on-startup><br>数字越小表示优先级越高</p><p>在Servlet容器启动后，客户首次向Servlet发送请求</p><p>Servlet类文件被更新后，重新装载Servlet</p><h3 id="Servlet与JSP内置对象的对应关系"><a href="#Servlet与JSP内置对象的对应关系" class="headerlink" title="Servlet与JSP内置对象的对应关系"></a>Servlet与JSP内置对象的对应关系</h3><p><img src="/passages/Tools/Servlet/Servlet/1.png" alt="565cb40f85167f23b421e739d86ccb94.png"></p><h3 id="路径跳转"><a href="#路径跳转" class="headerlink" title="路径跳转"></a>路径跳转</h3><p>绝对路径<br>相对路径</p><p>重定向：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath()+<span class="string">"test.jsp"</span>);</span><br></pre></td></tr></table></figure></p><p>服务器内部跳转：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的斜线表示项目的根目录</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"/test.jsp"</span>).forward(request,response);</span><br><span class="line"><span class="comment">//..表示回到上一层目录</span></span><br><span class="line">request.getRequestDispatcher(<span class="string">"../test.jsp"</span>).forward(request,response);</span><br></pre></td></tr></table></figure></p><h3 id="获取初始化参数"><a href="#获取初始化参数" class="headerlink" title="获取初始化参数"></a>获取初始化参数</h3><p>在web.xml中配置Servlet时，可以配置一些初始化参数。而在Servlet中可以通过ServletConfig接口提供的方法来获取这些参数。</p><h3 id="Model1简介"><a href="#Model1简介" class="headerlink" title="Model1简介"></a>Model1简介</h3><p><img src="/passages/Tools/Servlet/Servlet/2.png" alt="f88bdf942d20ab8d2f47841e22fb01ca.png"></p><h3 id="Model2简介"><a href="#Model2简介" class="headerlink" title="Model2简介"></a>Model2简介</h3><p>Java Web的Model2开发模型就是MVC思想的体现<br><img src="/passages/Tools/Servlet/Servlet/3.png" alt="692a967878ac8f7dc3fa59f021988093.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Servlet" scheme="http://kwin1113.github.io/categories/Tools/Servlet/"/>
    
    
      <category term="Servlet" scheme="http://kwin1113.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>Redis的数据结构</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/Redis的数据结构/</id>
    <published>2019-02-04T15:43:04.000Z</published>
    <updated>2019-02-04T16:55:54.074Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="五种数据类型："><a href="#五种数据类型：" class="headerlink" title="五种数据类型："></a>五种数据类型：</h3><ul><li>字符串（String）</li><li>哈希（Hash）</li><li>字符串列表（List）</li><li>字符串集合（Set）</li><li>有序字符串集合（sorted set）</li></ul><h3 id="Key定义的注意点"><a href="#Key定义的注意点" class="headerlink" title="Key定义的注意点"></a>Key定义的注意点</h3><ul><li>不要过长</li><li>不要过短</li><li>统一的命名规范</li></ul><h3 id="存储String"><a href="#存储String" class="headerlink" title="存储String"></a>存储String</h3><ul><li>二进制安全的，存入和获取的数据相同</li><li>Value最多可以容纳的数据长度是512M<h4 id="存储String常用命令"><a href="#存储String常用命令" class="headerlink" title="存储String常用命令"></a>存储String常用命令</h4></li><li>赋值取值：set、get、getset</li><li>删除：del</li><li>数值增减：incr、decr、incrby、decrby</li><li>扩展命令：append<br><img src="/passages/Tools/Redis/Redis的数据结构/1.png" alt="0836bcd80456855d221dbcdc69d3babd.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/2.png" alt="c39e9cb895dd5e0590f2a1f893da9450.png"><h3 id="存储Hash"><a href="#存储Hash" class="headerlink" title="存储Hash"></a>存储Hash</h3></li><li>String Key和String Value的map容器</li><li>每一个Hash可以存储4294967295个键值对<h4 id="存储Hash常用命令"><a href="#存储Hash常用命令" class="headerlink" title="存储Hash常用命令"></a>存储Hash常用命令</h4></li><li>赋值取值：hset、hget、hmset、hmget、hgetall</li><li>删除：del、hdel</li><li>自学命令：hexists、hlen、hkeys、hvals<br><img src="/passages/Tools/Redis/Redis的数据结构/3.png" alt="f93ba168be712d6757e8fae9b643085a.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/4.png" alt="1c1ac4e5acbb4727efc68d75d6b28557.png"><h3 id="存储List"><a href="#存储List" class="headerlink" title="存储List"></a>存储List</h3></li><li>ArrayList使用数组方式</li><li>LinkedList使用双向链接方式</li><li>双向链表中增加数据</li><li>双向链表中删除数据<h4 id="存储List常用命令"><a href="#存储List常用命令" class="headerlink" title="存储List常用命令"></a>存储List常用命令</h4></li><li>两端添加、弹出：hpush、rpush、lpop、rpop、lpushx、rpoplpush</li><li>查看列表：lrange</li><li>获取列表元素个数：llen</li><li>扩展命令：lrem、linsert (before)(after)<br><img src="/passages/Tools/Redis/Redis的数据结构/5.png" alt="a80a5bcbea4390e2d8514ad93cc6e447.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/6.png" alt="d6d69283136965e21865745c663c46a6.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/7.png" alt="484244f1a03ab048367709b10bcda24e.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/8.png" alt="d79d97782c0f8d013217c93211c5e7bf.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/9.png" alt="858b6f082f21987bf1bf862ec659167c.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/10.png" alt="f9f8716f3674cf8b5afc923fe2f6f8df.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/11.png" alt="7969ea95dc3366a48990e063e1cbec63.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/12.png" alt="280c7681d6fd7c8b52104e010355b48f.png"><h3 id="存储Set"><a href="#存储Set" class="headerlink" title="存储Set"></a>存储Set</h3></li><li>和List类型不同的是，Set集合中不允许出现重复的元素</li><li>Set可包含的最大元素数量是4294967295<h4 id="存储set常用命令"><a href="#存储set常用命令" class="headerlink" title="存储set常用命令"></a>存储set常用命令</h4></li><li>添加删除元素：sadd、srem、</li><li>获得集合中的元素：smembers、sismembers</li><li>集合中的差集运算：sdiff</li><li>集合中的交集运算：sinter</li><li>集合中的并集运算：sunion</li><li>扩展命令：scard、srandmember、sdiffstore、sinterstore、sunionstore<br><img src="/passages/Tools/Redis/Redis的数据结构/13.png" alt="d756ffa784034432c85efaae3742b8a4.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/14.png" alt="6f088e987618e9c3e713d5889c3ea343.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/15.png" alt="deb391986de4ae9fe97ab2adcdcc072d.png"><h4 id="存储Set使用场景"><a href="#存储Set使用场景" class="headerlink" title="存储Set使用场景"></a>存储Set使用场景</h4></li><li>跟踪一些唯一性数据</li><li>用于维护数据对象之间的关联关系<h3 id="存储Sorted-Set"><a href="#存储Sorted-Set" class="headerlink" title="存储Sorted-Set"></a>存储Sorted-Set</h3></li><li>Sorted-Set和Set的区别</li><li>Sorted-Set中的成员在集合中的位置是有序的<h4 id="存储Sorted-Set常用命令"><a href="#存储Sorted-Set常用命令" class="headerlink" title="存储Sorted-Set常用命令"></a>存储Sorted-Set常用命令</h4></li><li>添加元素、删除元素：zadd、zrem</li><li>获得元素：zscore</li><li>范围查询：zrange withscores、zrevrange withscores</li><li>扩展命令：zcard、zremrangebyrank、zremrangebyscore limit、zcount<br><img src="/passages/Tools/Redis/Redis的数据结构/16.png" alt="80c3ee0abd4234ed7a35a1edb4d6a93d.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/17.png" alt="9160833a2331aed9b5e1920c8ba2b974.png"><br><img src="/passages/Tools/Redis/Redis的数据结构/18.png" alt="ecd812add1c1570b28031a41334e4da1.png"><h4 id="Sorted-Set使用场景"><a href="#Sorted-Set使用场景" class="headerlink" title="Sorted-Set使用场景"></a>Sorted-Set使用场景</h4></li><li>如大型在线游戏积分排行榜</li><li>构建索引数据</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL、Redis、Jedis</title>
    <link href="http://kwin1113.github.io/passages/Tools/Redis/NoSQL%E3%80%81Redis%E3%80%81Jedis/"/>
    <id>http://kwin1113.github.io/passages/Tools/Redis/NoSQL、Redis、Jedis/</id>
    <published>2019-02-04T15:42:33.000Z</published>
    <updated>2019-02-04T16:55:50.640Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><ul><li>NoSQL=Not Only SQL</li><li>非关系型的数据库</li><li>High performance - 高并发读写</li><li>Huge Storage - 海量数据的高效率存储和访问</li><li>High Scalability &amp;&amp; High Availability - 高可扩展性和高可用性<h4 id="NoSQL数据的四大分类"><a href="#NoSQL数据的四大分类" class="headerlink" title="NoSQL数据的四大分类"></a>NoSQL数据的四大分类</h4></li><li>键值存储</li><li>列存储</li><li>文档数据库</li><li>图形数据库</li></ul><table><thead><tr><th>分类</th><th>相关产品</th><th>典型应用</th><th>数据模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>键值</td><td>Tokto Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</td><td>内容缓存、主要用于处理大量数据的高访问负载</td><td>一系列键值对</td><td>快速查询</td><td>存储的数据缺少结构化</td></tr><tr><td>列存储数据库</td><td>Cassandra、HBase、Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td>文档型数据库</td><td>CouchDB、MongoDB</td><td>Web应用</td><td>一系列键值对</td><td>数据结构要求不严格</td><td>查询性能不强，而且缺乏统一的查询语法</td></tr><tr><td>图形数据库</td><td>Neo4J、InfoGrid、Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法</td><td>需要对整个图做计算才能得出结果，不容易做分布式的集群方案</td></tr></tbody></table><h4 id="NoSQL的特点"><a href="#NoSQL的特点" class="headerlink" title="NoSQL的特点"></a>NoSQL的特点</h4><ul><li>易扩展</li><li>大数据量，高性能</li><li>灵活的数据模型</li><li><p>高可用</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h4><p>高性能键值对数据库，支持的键值数据类型：</p></li><li><p>字符串类型</p></li><li>散列类型</li><li>列表类型</li><li>集合类型</li><li>有序集合类型<h4 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h4></li><li>缓存</li><li>任务队列</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理</li><li>分布式集群架构中的session分离<h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3>引入Jedis的jar包<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisTestTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单例例子</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.200.25"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        jedis.set(<span class="string">"name"</span>, <span class="string">"kwin"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(jedis.get(<span class="string">"name"</span>));</span><br><span class="line"></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用连接池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"></span><br><span class="line">        config.setMaxTotal(<span class="number">30</span>);</span><br><span class="line">        config.setMaxIdle(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.200.25"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            jedis.set(<span class="string">"name"</span>, <span class="string">"kk"</span>);</span><br><span class="line">            String value = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedisPool) &#123;</span><br><span class="line">                jedisPool.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Redis(持更...)" scheme="http://kwin1113.github.io/categories/Tools/Redis-%E6%8C%81%E6%9B%B4/"/>
    
    
      <category term="Redis" scheme="http://kwin1113.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="http://kwin1113.github.io/passages/Tools/Maven/Maven/"/>
    <id>http://kwin1113.github.io/passages/Tools/Maven/Maven/</id>
    <published>2019-02-04T15:41:52.000Z</published>
    <updated>2019-02-04T16:55:41.798Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="Maven介绍及环境搭建"><a href="#Maven介绍及环境搭建" class="headerlink" title="Maven介绍及环境搭建"></a>Maven介绍及环境搭建</h3><p>Maven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具<br>maven项目结构<br>src<br>        -main<br>         .      -java<br>         .              -package<br>        -test<br>          .     -java<br>          .              -package<br>        -resources</p><h3 id="Maven的常见命令"><a href="#Maven的常见命令" class="headerlink" title="Maven的常见命令"></a>Maven的常见命令</h3><p>mvn -v 查看maven版本<br>        compile 编译<br>        test 测试<br>        package 打包<br>        clean 删除target<br>        install 安装jar包到本地仓库中</p><pre><code>创建目录的两种方式：1.archetype:generate 按照提示进行选择2.archetype：generate -DgroupId=组织名，公司地址的反写+项目名                                    -DartifactId=项目名-模块名                                    -Dversion=版本号                                    -Dpackage=代码所存在的包名</code></pre><p>坐标<br>        构件<br>仓库<br>        本地仓库和远程仓库<br>镜像仓库</p><p>完整的项目构建过程包括：<br>清理、编译、测试、打包、集成测试、验证、部署<br>clean、compile、test、package、install</p><h3 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h3><p>clean    清理项目<br>                            pre-clean   执行清理前的工作<br>                            clean         清理上一次构建生成的所有文件<br>                            post-clean 执行清理后的文件<br>default  构建项目（最核心）<br>                            compile    test    package    install<br>site        生成项目站点<br>                            pre-site      在生成项目站点前要完成的工作<br>                            site            生成项目的站点文档<br>                            post-site    在生成项目站点后要完成的工作<br>                            site-deploy发布生成的站点到服务器上</p><h3 id="pom-xml常用元素"><a href="#pom-xml常用元素" class="headerlink" title="pom.xml常用元素"></a>pom.xml常用元素</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定了当前pom的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第一个0表示大版本号</span></span><br><span class="line"><span class="comment">     第二个0表示分支版本号</span></span><br><span class="line"><span class="comment">     第三个0表示小版本号</span></span><br><span class="line"><span class="comment">     0.0.1</span></span><br><span class="line"><span class="comment">     snapshot快照</span></span><br><span class="line"><span class="comment">     alpha内部测试</span></span><br><span class="line"><span class="comment">     beta公测</span></span><br><span class="line"><span class="comment">     Release稳定</span></span><br><span class="line"><span class="comment">     GA正式发布</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 打包方式</span></span><br><span class="line"><span class="comment">     默认是jar</span></span><br><span class="line"><span class="comment">     war zip pom</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span><span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 项目描述名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开发人员 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span><span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 许可证 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 组织信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span>&gt;</span><span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span><span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span><span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置依赖是否可选 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span><span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 排除依赖传递列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖的管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插件列表 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖的范围"><a href="#依赖的范围" class="headerlink" title="依赖的范围"></a>依赖的范围</h3><p>compile：默认<br>provided：在编译和测试时有效<br>runtime：在测试和运行时有效<br>test：只在测试时有效<br>system：与本机系统相关联，可移植性差<br>import：导入的范围，它只使用在dependencyManagement中，表示从其他的pom中导入dependency的配置</p><h3 id="Maven依赖传递"><a href="#Maven依赖传递" class="headerlink" title="Maven依赖传递"></a>Maven依赖传递</h3><p>通过<dependency>引入依赖<br>通过<exclusions><exclusion>排除依赖</exclusion></exclusions></dependency></p><h3 id="依赖冲突"><a href="#依赖冲突" class="headerlink" title="依赖冲突"></a>依赖冲突</h3><p>1.短路优先<br>2.如果路径长度相同，先声明优先</p><h3 id="聚合和继承"><a href="#聚合和继承" class="headerlink" title="聚合和继承"></a>聚合和继承</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 聚合 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">module</span>&gt;</span><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖的管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 继承 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Maven" scheme="http://kwin1113.github.io/categories/Tools/Maven/"/>
    
    
      <category term="Maven" scheme="http://kwin1113.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Junit4</title>
    <link href="http://kwin1113.github.io/passages/Tools/Junit4/Junit4/"/>
    <id>http://kwin1113.github.io/passages/Tools/Junit4/Junit4/</id>
    <published>2019-02-04T15:41:09.000Z</published>
    <updated>2019-02-04T16:55:35.862Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><p>1、测试方法上必须使用@Test进行修饰<br>2、测试方法必须使用public void进行修饰，不能带任何的参数<br>3、新建一个源代码目录来存放我们的测试代码<br>4、测试类的包应该和被测试类保持一致<br>5、测试单元中的每个方法必须可以独立测试，测试方法间不能由任何的依赖<br>6、测试类使用Test作为类名的后缀（不是必须）<br>7、测试方法使用test作为方法名的前缀（不是必须）</p><p>1、Failure一般由单元测试使用的断言方法判断失败所引起的，这表示测试点发现了问题，就是说程序输出的结果和我们预期的不一样<br>2、error是由代码异常引起的，它可以产生于测试代码本身的错误，也可以是被测试代码中的一个隐藏bug<br>3、测试用例不是用来证明你是对的，而是用来证明你没有错。</p><p>1、@BeforeClass修饰的方法会在所有方法被调用前被执行，而且该方法是静态的，所以当测试类被加载后接着就会运行它，而且在内存中它只会存在一份实例，它比较适合加载配置文件。<br>2、@AfterClass所修饰的方法通常用来对资源的清理，如关闭数据库的连接<br>3、@Before和@After会在每个测试方法的前后各执行一次</p><p>@Test：将一个普通的方法修饰成为一个测试方法<br>    @Test(expected=XX.class)<br>    @Test(timeout=毫秒)<br>@BeforeClass：它会在所有的方法运行前被执行，static修饰<br>@AfterClass：它会在所有的方法运行结束后被执行，static修饰<br>@Before：会在每一个测试方法被运行前执行一次<br>@After：会在每一个测试方法运行后被执行一次<br>@Ignore：所修饰的测试方法会被测试运行器忽略<br>@RunWith：可以更改测试运行器org.junit.runner.Runner</p><p>测试套件就是组织测试类一起运行的</p><p>写一个作为测试套件的入口类，这个类里不包含其他的方法<br>更改测试运行器Suite.class<br>将要测试的类作为数组传入到Suite.SuiteClasses({ })</p><p>1、更改默认的测试运行期为RunWith(Parameterized.class)<br>2、声明变量来存放预期值和结果值<br>3、声明一个返回值为Collection的公共静态方法，并使用@Parameters进行修饰<br>4、为测试类声明一个带有参数的公共构造函数，并在其中为之声明变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(Parameterized.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> excepted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Parameterized</span>.Parameters</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; t() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> Object[][]&#123;</span><br><span class="line">                &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParameterTest</span><span class="params">(<span class="keyword">int</span> excepted, <span class="keyword">int</span> input1, <span class="keyword">int</span> input2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.excepted = excepted;</span><br><span class="line">        <span class="keyword">this</span>.input1 = input1;</span><br><span class="line">        <span class="keyword">this</span>.input2 = input2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(excepted, <span class="keyword">new</span> Calculate().add(input1, input2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Junit4" scheme="http://kwin1113.github.io/categories/Tools/Junit4/"/>
    
    
      <category term="Junit4" scheme="http://kwin1113.github.io/tags/Junit4/"/>
    
  </entry>
  
  <entry>
    <title>Spring JMS</title>
    <link href="http://kwin1113.github.io/passages/Tools/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/Spring-JMS/"/>
    <id>http://kwin1113.github.io/passages/Tools/Java消息中间件/Spring-JMS/</id>
    <published>2019-02-04T15:40:25.000Z</published>
    <updated>2019-02-04T16:55:22.874Z</updated>
    
    <content type="html"><![CDATA[<!-- 文章的摘要内容 --><a id="more"></a><!-- 文章的正式内容 --><h3 id="使用Spring集成JMS连接ActiveMQ"><a href="#使用Spring集成JMS连接ActiveMQ" class="headerlink" title="使用Spring集成JMS连接ActiveMQ"></a>使用Spring集成JMS连接ActiveMQ</h3><ul><li>ConnectionFactory：用于管理连接的连接工厂</li><li>JmsTemplate：用于发送和接收消息的模板类</li><li>MessageListener：消息监听器<h4 id="ConnectionFactory"><a href="#ConnectionFactory" class="headerlink" title="ConnectionFactory"></a>ConnectionFactory</h4></li><li>一个Spring为我们提供的连接池</li><li>JmsTemplate每次发消息都会重新创建连接，会话和productor</li><li>spring中提供了SingleConnectionFactory和CachingConnectionFactory<h4 id="JmsTemplate"><a href="#JmsTemplate" class="headerlink" title="JmsTemplate"></a>JmsTemplate</h4></li><li>是spring提供的，只需向spring容器中注册这个类就可以使用JmsTemplate方便的操作jms</li><li>JmsTemplate类是线程安全的，可以在整个应用范围使用<h4 id="MessageListener"><a href="#MessageListener" class="headerlink" title="MessageListener"></a>MessageListener</h4></li><li>实现一个onMessage方法，该方法只接收一个Messgae参数。<br><img src="/passages/Tools/Java消息中间件/Spring-JMS/1.png" alt="a8248bacfdd7cdbfa27755c2c53aca50.png"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--ActiveMQ为我们提供的ConnectionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.spring.ActiveMQConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"brokerURL"</span> <span class="attr">value</span>=<span class="string">"tcp://192.168.200.25:61616"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Spring jms为我们提供连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"connectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.connection.SingleConnectionFactory"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetConnectionFactory"</span> <span class="attr">ref</span>=<span class="string">"targetConnectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--一个队列目的地，点对点的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"queueDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQQueue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"queue"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"topicDestination"</span> <span class="attr">class</span>=<span class="string">"org.apache.activemq.command.ActiveMQTopic"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"topic"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入公共配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"common.xml"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置消息监听器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"consumerMessageListener"</span> <span class="attr">class</span>=<span class="string">"com.kwin.jms.consumer.ConsumerMessageListener"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置消息监听容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsContainer"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.listener.DefaultMessageListenerContainer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">ref</span>=<span class="string">"queueDestination"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageListener"</span> <span class="attr">ref</span>=<span class="string">"consumerMessageListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"common.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置jmsTemplate，用来发送消息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jmsTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jms.core.JmsTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionFactory"</span> <span class="attr">ref</span>=<span class="string">"connectionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.kwin.jms.producer.ProducerServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.jms.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.jms.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.jms.JMSException;</span><br><span class="line"><span class="keyword">import</span> javax.jms.Message;</span><br><span class="line"><span class="keyword">import</span> javax.jms.MessageListener;</span><br><span class="line"><span class="keyword">import</span> javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        TextMessage textMessage = (TextMessage) message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"接受消息"</span> + textMessage.getText());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JMSException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.jms.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"producer.xml"</span>);</span><br><span class="line">        ProducerService service = context.getBean(ProducerService.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            service.sendMessage(<span class="string">"test"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        ((ClassPathXmlApplicationContext) context).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.jms.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kwin.jms.producer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.MessageCreator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.jms.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProducerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"queueDestination"</span>)</span><br><span class="line">    Destination destination;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用JmsTemplate发送消息</span></span><br><span class="line">        jmsTemplate.send(destination, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="comment">//创建一个消息</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                TextMessage textMessage = session.createTextMessage(message);</span><br><span class="line">                <span class="keyword">return</span> textMessage;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"发送消息"</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Topic模式方法类似</p>]]></content>
    
    <summary type="html">
    
      &lt;!-- 文章的摘要内容 --&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://kwin1113.github.io/categories/Tools/"/>
    
      <category term="Java消息中间件" scheme="http://kwin1113.github.io/categories/Tools/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java消息中间件" scheme="http://kwin1113.github.io/tags/Java%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
